/*
This program, let's call it rsTeX to not confuse it with any other TeX system
is copyright (C) 2018 by Richard Sandberg (mylodon at gmail dot com).
The original tex.web is copyright (C) 1982 by Donald Knuth.

License,
This program is for educational purpose only, all commercial use
is strictly forbidden.

This is a manual translation of tex.web version 3.14159265 into C++.
Mostly it's a direct translation of the original pascal source with very minimal changes.
The amount of C++ (that is not also C) used is very minimal. Notably I added an array
class to keep the same indexing as in the orignal and to also get boundschecking.
With some work it's possible to use straight C arrays instead but this will make
the code alot more cluttered. I also use the stream classes to print statistics,
this can easily be changed to C format routines instead, if one wishes.
But who has a C compiler and no C++ compiler these days?

What is the purpose of this program? Well, I've long been fascinated by
Donald Knuth and his work and especially TeX. TeX is one of the most well
documented programs out there and the source code is of course readily available
but, one lacking feature of current implementations is that because the source code is
machine converted into C it's not easy to understand or step through the code
in a debugger. So that's why I decided to translate the program to C++. By doing so
one also hopefully gains some understanding of what the code does.
Another aspect was that I was interested in knowing how long it would take
to write the program. I didn't keep a stop watch at hand but a rough estimate is
that it took about 30 hours to type the whole program in and more than twice that to
fix all typos and other bugs introduced. Which was kind of what I expected except I 
thought the debugging time would be on par with the time it took to type it in.
Had I been more systematic in my approach and introduced more asserts and checks
from the beginning the debugging time would have been considerably shorter.

The program consists of two files rstex.h.pre and rstex.cpp.pre.
These two files must be preprocessed by another program which converts all
special strings in the program to numbers (as the original tangle program does),
and makes a string pool file.
After this preprocessing we are left with three files rstex.h,
rstex.cpp, and tex.pool.
rstex.cpp can then be compiled by any C++ compiler, and the executable can be run.

Notable omissions:
* Currently no path searching is done so all files the program needs are supposed
  to exist in the current directory. (Maybe should add checking of a few locations given by env. vars).
* No command line processing is done, so input files must be entered at the prompt. (Just put it in!)
* No system specific handling of current time. (Just put it in!)
* No special defines for excluding init, stat, or debug code (most likely easy to add these),
  although I don't think it hurts much to keep it in.
* No other files needed for a complete system is included, i.e. fmt files, fonts, tfm files
  macro packages etc.

Disclaimer,
This is NOT the official version of TeX, it is only based upon the official version of TeX.
It may contain bugs not present in the official version. It does pass the trip test,
but the trip test does not test everything. In no way shall the author of this program
be responsible for any damages, direct or indirect, that may result out of its use.
It is not meant to be a working typesetting system, it is meant for educational purpose,
for those who want to understand how this complex software works.

*/

#include <sstream>
#include <cmath>
#include <cstdlib>
#include "rstex.h"

bool myodd(int c)
{
	return ((c % 2) != 0);
}

// 21,23,24
void setup_char_arrays()
{
	for (int i = 0; i < 32; i++)
		xchr[i] = i;


	for (int i = 127; i < 256; i++)
		xchr[i] = ' ';

	xchr[32] = ' '; xchr[33] = '!'; xchr[34] = '\"'; xchr[35] = '#'; xchr[36] = '$';
	xchr[37] = '%'; xchr[38] = '&'; xchr[39] = '\''; xchr[40] = '('; xchr[41] = ')';
	xchr[42] = '*'; xchr[43] = '+'; xchr[44] = ','; xchr[45] = '-'; xchr[46] = '.';
	xchr[47] = '/'; xchr[48] = '0'; xchr[49] = '1'; xchr[50] = '2'; xchr[51] = '3';
	xchr[52] = '4'; xchr[53] = '5'; xchr[54] = '6'; xchr[55] = '7'; xchr[56] = '8';
	xchr[57] = '9'; xchr[58] = ':'; xchr[59] = ';'; xchr[60] = '<'; xchr[61] = '=';
	xchr[62] = '>'; xchr[63] = '?'; xchr[64] = '@'; xchr[65] = 'A'; xchr[66] = 'B';
	xchr[67] = 'C'; xchr[68] = 'D'; xchr[69] = 'E'; xchr[70] = 'F'; xchr[71] = 'G';
	xchr[72] = 'H'; xchr[73] = 'I'; xchr[74] = 'J'; xchr[75] = 'K'; xchr[76] = 'L';
	xchr[77] = 'M'; xchr[78] = 'N'; xchr[79] = 'O'; xchr[80] = 'P'; xchr[81] = 'Q';
	xchr[82] = 'R'; xchr[83] = 'S'; xchr[84] = 'T'; xchr[85] = 'U'; xchr[86] = 'V';
	xchr[87] = 'W'; xchr[88] = 'X'; xchr[89] = 'Y'; xchr[90] = 'Z'; xchr[91] = '[';
	xchr[92] = '\\'; xchr[93] = ']'; xchr[94] = '^'; xchr[95] = '_'; xchr[96] = '`';
	xchr[97] = 'a'; xchr[98] = 'b'; xchr[99] = 'c'; xchr[100] = 'd'; xchr[101] = 'e';
	xchr[102] = 'f'; xchr[103] = 'g'; xchr[104] = 'h'; xchr[105] = 'i'; xchr[106] = 'j';
	xchr[107] = 'k'; xchr[108] = 'l'; xchr[109] = 'm'; xchr[110] = 'n'; xchr[111] = 'o';
	xchr[112] = 'p'; xchr[113] = 'q'; xchr[114] = 'r'; xchr[115] = 's'; xchr[116] = 't';
	xchr[117] = 'u'; xchr[118] = 'v'; xchr[119] = 'w'; xchr[120] = 'x'; xchr[121] = 'y';
	xchr[122] = 'z'; xchr[123] = '{'; xchr[124] = '|'; xchr[125] = '}'; xchr[126] = '~';
	
	for (int i = 0; i < 256; i++) {
		xord[i] = 127;
	}
	for (int i = 128; i < 256; i++) {
		int ind = xchr[i];
		xord[ind] = i;
	}
	for (int i = 0; i < 127; i++) {
		int ind = xchr[i];
		xord[ind] = i;
	}
}

// 34
void update_terminal()
{}
void clear_terminal()
{}
void wake_up_terminal()
{}



// 81
void jump_out()
{
	do_end_of_TEX();
}

// routine called when tex says goto final_end
void do_final_end()
{
	ready_already = 0;
	wterm_cr;

	if (history <= warning_issued)
		exit(0);
	else
		exit(1);
}

// routine called when tex says goto end_of_TEX
void do_end_of_TEX()
{
	close_files_and_terminate();
	do_final_end();
}


// 58
void print_char(ASCII_code s)
{
	if (s == new_line_char) // character s is the current new-line character (244)
		if (selector < pseudo) {
			print_ln(); return;
		}

	switch (selector) {
		case term_and_log:
			wterm_c(xchr[s]);
			wlog_c(xchr[s]);
			incr(term_offset);
			incr(file_offset);
			if (term_offset == max_print_line) {
				wterm_cr;
				term_offset = 0;
			}
			if (file_offset == max_print_line) {
				wlog_cr;
				file_offset = 0;
			}
			break;

		case log_only:
			wlog_c(xchr[s]);
			incr(file_offset);
			if (file_offset == max_print_line)
				print_ln();
			break;

		case term_only:
			wterm_c(xchr[s]);
			incr(term_offset);
			if (term_offset == max_print_line)
				print_ln();
			break;

		case no_print:
			// do_nothing
			break;
			
		case pseudo:
			if (tally < trick_count)
				trick_buf[tally % error_line] = s;
			break;
			
		case new_string:
			if (pool_ptr < pool_size)
				append_char(s);
			break;

		default:
			fputc(xchr[s], write_file[selector]);
			break;
	}
	incr(tally);
}


// 59
void print(int s)
{
	pool_pointer j;
	int nl;

	if (s >= str_ptr) s = TEX_STRING("???");
	else if (s < 256)
		if (s < 0) s = TEX_STRING("???");
		else {
			if (selector > pseudo) {
				print_char(s); return;
			}
			if (
				#pragma region <Character s is the current new-line character 244>
				s == new_line_char
				#pragma endregion
				)
				if (selector < pseudo) {
					print_ln(); return;
				}
			nl = new_line_char; new_line_char = -1;
			j = str_start[s];
			while (j < str_start[s + 1]) {
				print_char(so(str_pool[j])); incr(j);
			}
			new_line_char = nl; return;
		}


	j = str_start[s];
	while (j < str_start[s + 1]) {
		print_char(so(str_pool[j]));
		incr(j);
	}
}

void print_the_digs(eight_bits k)
{
	while (k > 0) {
		decr(k);
		if (dig[k] < 10)
			print_char(TEX_STRING("0") + dig[k]);
		else
			print_char(TEX_STRING("A") - 10 + dig[k]);
	}
}

//67
void print_hex(int n)
{
	int k; // 0..22

	k = 0; print_char(TEX_STRING(""""));
	do {
		dig[k] = n % 16; n = n / 16; incr(k);
	} while (!(n == 0));
	print_the_digs(k);
}

//65
void print_int(int n)
{
	int k;
	int m;
	k = 0;
	if (n < 0) {
		print_char(TEX_STRING("-"));
		if (n > -100000000)
			negate(n);
		else {
			m = -1 - n; n = m / 10; m = (m % 10) + 1; k = 1;
			if (m < 10)
				dig[0] = m;
			else {
				dig[0] = 0;
				incr(n);
			}
		}
	}
	do {
		dig[k] = n % 10; n = n / 10; incr(k);
	} while (!(n == 0));
	print_the_digs(k);
}

// 57
void print_ln()
{
	switch (selector) {
		case term_and_log:
			wterm_cr;
			wlog_cr;
			term_offset = 0;
			file_offset = 0;
			break;

		case log_only:
			wlog_cr;
			file_offset = 0;
			break;

		case term_only:
			wterm_cr;
			term_offset = 0;
			break;

		case no_print:
		case pseudo:
		case new_string:
			//do_nothing:
			break;
		default:
			fputc('\n', write_file[selector]);
			break;

	}
}

void print_nl(str_number s)
{
	if(term_offset > 0 && myodd(selector) || file_offset > 0 && selector >= log_only)
		print_ln();
	print(s);
}

// 60
void slow_print(int s)
{
	pool_pointer j;
	if (s >= str_ptr || s < 256)
		print(s);
	else {
		j = str_start[s];
		while (j < str_start[s + 1]) {
			print(str_pool[j]);
			incr(j);
		}
	}
}

// 66
void print_two(int n)
{
	n = abs(n) % 100;
	print_char(TEX_STRING("0") + (n / 10));
	print_char(TEX_STRING("0") + (n % 10));
}

// 69
void print_roman_int(int n)
{
	pool_pointer j, k;
	nonnegative_integer u, v;

	j = str_start[TEX_STRING("m2d5c2l5x2v5i")]; v = 1000;
	while (1) {
		while (n >= v) {
			print_char(so(str_pool[j])); n -= v;
		}
		if (n <= 0) return;
		k = j + 2; u = v / (so(str_pool[k - 1]) - TEX_STRING("0"));
		if (str_pool[k - 1] == si(TEX_STRING("2"))) {
			k += 2; u = u / (so(str_pool[k - 1]) - TEX_STRING("0"));
		}
		if (n + u >= v) {
			print_char(so(str_pool[k])); n += u;
		}
		else {
			j += 2; v = v / (so(str_pool[j - 1]) - TEX_STRING("0"));
		}
	}

}

void print_esc(str_number s)
{
	int c;

	#pragma region <Set variable c to the current escape character 243>
	c = escape_char;
	#pragma endregion

	if (c >= 0)
		if (c < 256)
			print(c);

	slow_print(s);
}

// 94
void overflow(str_number s, int n)
{
	normalize_selector();
	print_err(TEX_STRING("TeX capacity exceeded, sorry ["));
	print(s); print_char('=');
	print_int(n); print_char(']');
	help2(TEX_STRING("If you really absolutely need more capacity,"),
		TEX_STRING("you can ask a wizard to enlarge me."));
	succumb;
}

// 43
str_number make_string()
{
	if (str_ptr == max_strings)
		overflow(TEX_STRING("number of strings"), max_strings - init_str_ptr);
	incr(str_ptr); str_start[str_ptr] = pool_ptr;
	return str_ptr - 1;
}


// 45
bool str_eq_buf(str_number s, int k)
{
	pool_pointer j;
	bool result;

	j = str_start[s];
	while (j < str_start[s + 1]) {
		if (so(str_pool[j]) != buffer[k]) {
			result = false;
			goto not_found;
		}
		incr(j); incr(k);
	}
	result = true;
not_found:
	return result;
}

// 46
bool str_eq_str(str_number s, str_number t)
{
	pool_pointer j, k;
	bool result;

	result = false;
	if (length(s) != length(t))
		goto not_found;
	j = str_start[s]; k = str_start[t];
	while (j < str_start[s + 1]) {
		if (str_pool[j] != str_pool[k])
			goto not_found;
		incr(j); incr(k);
	}
	result = true;
not_found:
	return result;
}

// 100
int half(int x)
{
	if (myodd(x))return (x + 1) / 2;
	else return x / 2;
}

// 102
scaled round_decimals(small_number k)
{
	int a;

	a = 0;
	while (k > 0) {
		decr(k); a = (a + dig[k] * two) / 10;
	}
	return (a + 1) / 2;
}


// 103
void print_scaled(scaled s)
{
	scaled delta;
	if (s < 0) {
		print_char(TEX_STRING("-")); negate(s);
	}
	print_int(s / unity);
	print_char(TEX_STRING(".")); s = 10 * (s%unity) + 5; delta = 10;
	do {
		if (delta > unity)
			s = s + 0100000 - 50000;
		print_char(TEX_STRING("0") + (s / unity)); s = 10 * (s % unity); delta = delta * 10;
	} while (!(s <= delta));
}

// 105
scaled mult_and_add(int n, scaled x, scaled y, scaled max_answer)
{
	if (n < 0) {
		negate(x); negate(n);
	}
	if (n == 0)return y;
	else if (x <= (max_answer - y) / n && -x <= (max_answer + y) / n) return n * x + y;
	else {
		arith_error = true; return 0;
	}
}

//167
//debug
void check_mem(bool print_locs)
{
	pointer q, p;
	bool clobbered;

	for (p = mem_min; p <= lo_mem_max; p++)
		_free[p] = false;
	for (p = hi_mem_min; p <= mem_end; p++)
		_free[p] = false;

	#pragma region <Check single word avail list 168>
	p = avail; q = null; clobbered = false;
	while (p != null) {
		if (p > mem_end || p < hi_mem_min) clobbered = true;
		else if (_free[p]) clobbered = true;
		if (clobbered) {
			print_nl(TEX_STRING("AVAIL list clobbered at "));
			print_int(q);
			goto done1;
		}
		_free[p] = true; q = p; p = link(q);
	}
done1:
#pragma endregion

	#pragma region <Check varaible-size avail list 169>
	p = rover; q = null; clobbered = false;
	do {
		if (p >= lo_mem_max || p < mem_min) clobbered = true;
		else if (rlink(p) >= lo_mem_max || rlink(p) < mem_min) clobbered = true;
		else if (!is_empty(p) || node_size(p) < 2 || p + node_size(p) > lo_mem_max ||
			llink(rlink(p)) != p) clobbered = true;

		if (clobbered) {
			print_nl(TEX_STRING("Double-AVAIL list clobbered at "));
			print_int(q); goto done2;
		}
		for (q = p; q <= p + node_size(p) - 1; q++) {
			if (_free[q]) {
				print_nl(TEX_STRING("Doubly free location at "));
				print_int(q); goto done2;
			}
			_free[q] = true;
		}
		q = p; p = rlink(p);
	} while (!(p==rover));
done2:

#pragma endregion

	#pragma region <Check flags of unavailable nodes 170>
	p = mem_min;
	while (p <= lo_mem_max) {
		if (is_empty(p)) {
			print_nl(TEX_STRING("Bad flag at "));
			print_int(p);
		}
		while (p <= lo_mem_max && !_free[p]) incr(p);
		while (p <= lo_mem_max && _free[p]) incr(p);
	}

#pragma endregion

	if (print_locs) 
		#pragma region <Print newly busy locations 171>
	{
		print_nl(TEX_STRING("New busy locs:"));
		for(p = mem_min; p <= lo_mem_max; p++)
			if (!_free[p] && (p > was_lo_max || was_free[p]))
			{
				print_char(TEX_STRING(" ")); print_int(p);
			}
		for(p=hi_mem_min; p <= mem_end; p++)
			if (!_free[p] && (p<was_hi_min || p> was_mem_end || was_free[p]))
			{
				print_char(TEX_STRING(" ")); print_int(p);
			}
	}
#pragma endregion


	for (p = mem_min; p <= lo_mem_max; p++)
		was_free[p] = _free[p];
	for (p = hi_mem_min; p <= mem_end; p++)
		was_free[p] = _free[p];
	was_mem_end = mem_end; was_lo_max = lo_mem_max; was_hi_min = hi_mem_min;
}
//gubed


//172
//debug
void search_mem(pointer p)
{
	int q;

	for (q = mem_min; q <= lo_mem_max; q++) {
		if (link(q) == p) {
			print_nl(TEX_STRING("LINK(")); print_int(q); print_char(TEX_STRING(")"));
		}
		if (info(q) == p) {
			print_nl(TEX_STRING("INFO(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}
	for (q = hi_mem_min; q <= mem_end; q++) {
		if (link(q) == p) {
			print_nl(TEX_STRING("LINK(")); print_int(q); print_char(TEX_STRING(")"));
		}
		if (info(q) == p) {
			print_nl(TEX_STRING("INFO(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}

	#pragma region <Search eqtb for equivalents equal to p 255>
	for (q = active_base; q <= box_base + 255; q++) {
		if (equiv(q) == p) {
			print_nl(TEX_STRING("EQUIV(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}
	#pragma endregion

#	pragma region <Search save_stack for equivalents that point to p 285>
	if(save_ptr > 0)
		for (q = 0; q <= save_ptr - 1; q++) {
			if (equiv_field(save_stack[q]) == p) {
				print_nl(TEX_STRING("SAVE(")); print_int(q); print_char(TEX_STRING(")"));
			}
		}
	#pragma endregion

	#pragma region <Search hyph_list for pointers to p 933>
	for (q = 0; q <= hyph_size; q++) {
		if (hyph_list[q] == p) {
			print_nl(TEX_STRING("HYPH(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}
	#pragma endregion
}
//gubed


// 136
pointer new_null_box()
{
	pointer p;
	p = get_node(box_node_size);
	type(p) = hlist_node; subtype(p) = min_quarterword;
	width(p) = 0; depth(p) = 0; height(p) = 0; shift_amount(p) = 0; list_ptr(p) = null;
	glue_sign(p) = normal; glue_order(p) = normal; set_glue_ratio_zero(glue_set(p));
	return p;
}


// 147
pointer new_math(scaled w, small_number s)
{
	pointer p;
	p = get_node(small_node_size); type(p) = math_node; subtype(p) = s; width(p) = w;
	return p;
}

// 156
pointer new_kern(scaled w)
{
	pointer p;
	p = get_node(small_node_size); type(p) = kern_node; subtype(p) = normal; width(p) = w;
	return p;
}

// 177
void print_glue(scaled d, int order, str_number s)
{
	print_scaled(d);
	if (order < normal || order > filll)
		print(TEX_STRING("foul"));
	else if (order > normal) {
		print(TEX_STRING("fil"));
		while (order > fil) {
			print_char(TEX_STRING("l")); decr(order);
		}
	}
	else if (s != 0)
		print(s);
}

// 178
void print_spec(int p, str_number s)
{
	if (p < mem_min || p >= lo_mem_max)
		print_char(TEX_STRING("*"));
	else {
		print_scaled(width(p));
		if (s != 0)
			print(s);
		if (stretch(p) != 0) {
			print(TEX_STRING(" plus ")); print_glue(stretch(p), stretch_order(p), s);
		}
		if (shrink(p) != 0) {
			print(TEX_STRING(" minus ")); print_glue(shrink(p), shrink_order(p), s);
		}
	}
}

// 216
void push_nest()
{
	if (nest_ptr > max_nest_stack) {
		max_nest_stack = nest_ptr;
		if (nest_ptr == nest_size) overflow(TEX_STRING("semantic nest size"), nest_size);
	}
	nest[nest_ptr] = cur_list;
	incr(nest_ptr); head = get_avail(); tail = head; prev_graf = 0; mode_line = line;
}

// 217
void pop_nest()
{
	free_avail(head); decr(nest_ptr); cur_list = nest[nest_ptr];
}

// 1119
void build_discretionary()
{
	pointer p, q;
	int n;

	unsave();

	#pragma region <Prune the current list, if necessary, until it contains onlychar_node, kern_node, hlist_node.. 1121>
	q = head; p = link(q); n = 0;
	while (p != null) 
	{ if(!is_char_node(p))
		if(type(p) > rule_node)
			if(type(p) != kern_node)
				if (type(p) != ligature_node) {
					print_err(TEX_STRING("Improper discretionary list"));
					help1(TEX_STRING("Discretionary lists must contain only boxes and kerns."));
					error();
					begin_diagnostic();
					print_nl(TEX_STRING("The following discretionary sublist has been deleted:")); show_box(p);
					end_diagnostic(true); flush_node_list(p); link(q) = null; goto done;
				}
		q = p; p = link(q); incr(n);
	}
done:
	#pragma endregion

	p = link(head); pop_nest();
	switch (saved(-1)) {
	case 0: pre_break(tail) = p; break;
	case 1: post_break(tail) = p; break;
	case 2: 
		#pragma region <Attach list p to the current list, and record its length; then finish up and return 1120>
		if (n > 0 && abs(mode) == mmode) {
			print_err(TEX_STRING("Illegal math ")); 
			print_esc(TEX_STRING("discretionary"));
			help2(TEX_STRING("Sorry: The third part of a discretionary break must be"),
				TEX_STRING("empty, in math formulas. I had to delete your third part."));
			flush_node_list(p); n = 0;
			error();
		}
		else link(tail) = p;
		if (n <= max_quarterword) replace_count(tail) = n;
		else {
			print_err(TEX_STRING("Discretionary list is too long"));
			help2(TEX_STRING("Wow---I never thought anybody would tweak me here."),
				TEX_STRING("You can't seriously need such a huge discretionary list?"));
			error();
		}
		if (n > 0)tail = q;
		decr(save_ptr); goto _exit;
		#pragma endregion
		break;
	}
	incr(saved(-1)); new_save_level(disc_group); scan_left_brace(); push_nest(); mode = (mode_type)-hmode;
	space_factor = 1000;

_exit:
	;
}

// 47
//init
bool get_strings_started()
{
	int k, l; // 0..255
	text_char m, n;
	str_number g;
	int a;
	bool c;


	pool_ptr = 0;
	str_ptr = 0;
	str_start[0] = 0;

	#pragma region <Make the first 256 strings 48>
	for (k = 0; k <= 255; k++) {
		if ( k < TEX_STRING(" ") || 
			 k > TEX_STRING("~")) {
			append_char(TEX_STRING("^")); 
			append_char(TEX_STRING("^"));
			if (k < 0100)
				append_char(k + 0100);
			else if (k < 0200)
				append_char(k - 0100);
			else {
				app_lc_hex(k / 16); app_lc_hex(k % 16);
			}
		}
		else
			append_char(k);
		g = make_string();
	}
	#pragma endregion

	#pragma region <Read the other strings from the TEX.POOL file and return true, or give an error message and return false 51>

	strcpy(name_of_file.get_c_str(), pool_name);
	if (a_open_in(&pool_file)) {
		c = false;
		do {
			#pragma region <Read one string, but return false if the string memory space is getting too tight for comfort 52>
			{
				if (feof(pool_file))
					bad_pool("! tex.pool has no checksum.", true);
				m = fgetc(pool_file);
				n = fgetc(pool_file);
				if (m == '*') 
					#pragma region <check the pool checksum 53>
				{
					a = 0;
					k = 1;
					while (1) {
						if (xord[n] < '0' || xord[n] > '9')
							bad_pool("! tex.pool check sum doesn\'t have nine digits.", true);
						a = 10 * a + xord[n] - '0';
						if (k == 9) goto done;
						k++;
						n = fgetc(pool_file);
					}
				done:
					if (a != @$)
						bad_pool("! tex.pool doesn\'t match; TANGLE me again.", true);
					c = true;
				}
	#pragma endregion
				else {
					if (xord[m] < TEX_STRING("0") || xord[m]> TEX_STRING("9") || xord[n] < TEX_STRING("0") || xord[n] > TEX_STRING("9"))
						bad_pool("! tex.pool line does not begin with two digits.", true);
					l = xord[m] * 10 + xord[n] - TEX_STRING("0") * 11;
					if (pool_ptr + l + string_vacancies > pool_size)
						bad_pool("! You have to increase POOLSIZE.", true);
					for (k = 1; k <= l; k++) {
						int ch = fgetc(pool_file);
						if (ch == '\n')
							m = ' ';
						else
							m = ch;
						append_char(xord[m]);
					}
					int new_line = fgetc(pool_file); // read and discard new line
					g = make_string();
			
				}
			}
			#pragma endregion
		} while (!c);
		a_close(pool_file);

		return true;
	}
	else
		bad_pool("! I cannot read tex.pool.", false);
	#pragma endregion

}
//tini


// 71
void term_input()
{
	int k;
	update_terminal();
	if (!input_ln(term_in, true))
		fatal_error(TEX_STRING("End of file on the terminal!"));
	term_offset = 0;
	decr(selector);
	if (last != first)
		for (k = first; k <= last - 1; k++) print(buffer[k]);
	print_ln(); incr(selector);
}
// 329
void end_file_reading()
{
	first = start; line = line_stack[index];
	if (name > 17) a_close(cur_file);
	pop_input;
	decr(in_open);
}

// 330
void clear_for_error_prompt()
{
	while (state != token_list && terminal_input && input_ptr > 0 && loc > limit)
		end_file_reading();
	print_ln(); clear_terminal();
}


bool a_open_in(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "r");
	return *f;
}

bool a_open_out(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "w");
	return *f;
}

bool b_open_in(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "rb");
	return *f;
}

bool b_open_out(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "wb");
	return *f;
}


bool w_open_in(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "rb");
	return *f;
}

bool w_open_out(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "wb");
	return *f;
}



void a_close(FILE *f)
{
	fclose(f);
}

void b_close(FILE *f)
{
	fclose(f);
}

void w_close(FILE *f)
{
	fclose(f);
}

// 70
void print_current_string()
{
	pool_pointer j;
	j = str_start[str_ptr];
	while (j < pool_ptr) {
		print_char(so(str_pool[j])); incr(j);
	}
}

// 176
void print_font_and_char(int p)
{
	if (p > mem_end)
		print_esc(TEX_STRING("CLOBBERED."));
	else {
		if (font(p) < font_base || font(p) > font_max)
			print_char(TEX_STRING("*"));
		else 
			#pragma region <Print the font identifier for font(p) 267>
			print_esc(font_id_text(font(p)));
			#pragma endregion
		print_char(TEX_STRING(" ")); print_ASCII(qo(character(p)));
	}
}

void print_mark(int p)
{
	print_char(TEX_STRING("{"));
	if (p < hi_mem_min || p > mem_end) print_esc(TEX_STRING("CLOBBERED."));
	else show_token_list(link(p), null, max_print_line - 10);
	print_char(TEX_STRING("}"));
}

void print_rule_dimen(scaled d)
{
	if (is_running(d)) print_char(TEX_STRING("*"));
	else print_scaled(d);
}


// 92
void normalize_selector()
{
	if (log_opened)
		selector = term_and_log;
	else selector = term_only;
	if (job_name == 0)open_log_file();
	if (interaction == batch_mode)decr(selector);
}

// 93
void fatal_error(str_number s)
{
	normalize_selector();
	print_err(TEX_STRING("Emergency stop"));
	help1(s);
	succumb;
}

// 106
scaled x_over_n(scaled x, int n)
{
	bool negative;
	scaled ret;
	negative = false;
	if (n == 0) {
		arith_error = true;		
		ret = 0;
		_remainder = x;
	}
	else {
		if (n < 0) {
			negate(x); negate(n); negative = true;
		}
		if (x >= 0) {
			ret = x / n; _remainder = x % n;
		}
		else {
			ret = -((-x) / n); _remainder = -((-x) % n);
		}
	}
	if (negative)
		negate(_remainder);
	return ret;
}

// 108
halfword badness(scaled t, scaled s)
{
	int r;
	if (t == 0)
		return 0;
	else if (s <= 0)
		return inf_bad;
	else {
		if (t <= 7230584)
			r = (t * 297) / s;
		else if (s >= 1663497)
			r = t / (s / 297);
		else
			r = t;
		if (r > 1290)
			return inf_bad;
		else
			return (r*r*r + 0400000) / 01000000;
	}
}

// 298
void print_cmd_chr(quarterword cmd, halfword chr_code)
{
	switch (cmd) {
	case left_brace:
		chr_cmd(TEX_STRING("begin-group character "));
		break;
	case right_brace:
		chr_cmd(TEX_STRING("end-group character "));
		break;
	case math_shift:
		chr_cmd(TEX_STRING("math shift character "));
		break;
	case mac_param:
		chr_cmd(TEX_STRING("macro parameter character "));
		break;
	case sup_mark:
		chr_cmd(TEX_STRING("superscript character "));
		break;
	case sub_mark:
		chr_cmd(TEX_STRING("subscript character "));
		break;
	case endv:
		print(TEX_STRING("end of alignment template"));
		break;
	case spacer:
		chr_cmd(TEX_STRING("blank space "));
		break;
	case letter:
		chr_cmd(TEX_STRING("the letter "));
		break;
	case other_char:
		chr_cmd(TEX_STRING("the character "));
		break;
	#pragma region <Cases of print_cmd_chr for symbolic printing of primitives 227>
	case assign_glue:
	case assign_mu_glue:
		if (chr_code < skip_base)
			print_skip_param(chr_code - glue_base);
		else if (chr_code < mu_skip_base) {
			print_esc(TEX_STRING("skip")); print_int(chr_code - skip_base);
		}
		else {
			print_esc(TEX_STRING("muskip")); print_int(chr_code - mu_skip_base);
		}
		break;

	case assign_toks:
		if (chr_code >= toks_base) {
			print_esc(TEX_STRING("toks")); print_int(chr_code - toks_base);
		}
		else switch (chr_code) {
		case output_routine_loc: print_esc(TEX_STRING("output")); break;
		case every_par_loc: print_esc(TEX_STRING("everypar")); break;
		case every_math_loc: print_esc(TEX_STRING("everymath")); break;
		case every_display_loc: print_esc(TEX_STRING("everydisplay")); break;
		case every_hbox_loc: print_esc(TEX_STRING("everyhbox")); break;
		case every_vbox_loc: print_esc(TEX_STRING("everyvbox")); break;
		case every_job_loc: print_esc(TEX_STRING("everyjob")); break;
		case every_cr_loc: print_esc(TEX_STRING("everycr")); break;
		default: print_esc(TEX_STRING("errhelp")); break;
		}
		break;

	case assign_int:
		if (chr_code < count_base) print_param(chr_code - int_base);
		else {
			print_esc(TEX_STRING("count")); print_int(chr_code - count_base);
		}
		break;

	case assign_dimen:
		if (chr_code < scaled_base) print_length_param(chr_code - dimen_base);
		else {
			print_esc(TEX_STRING("dimen")); print_int(chr_code - scaled_base);
		}
		break;

	case accent: print_esc(TEX_STRING("accent")); break;
	case advance: print_esc(TEX_STRING("advance")); break;
	case after_assignment: print_esc(TEX_STRING("afterassignment")); break;
	case after_group: print_esc(TEX_STRING("aftergroup")); break;
	case assign_font_dimen: print_esc(TEX_STRING("fontdimen")); break;
	case begin_group: print_esc(TEX_STRING("begingroup")); break;
	case break_penalty: print_esc(TEX_STRING("penalty")); break;
	case char_num: print_esc(TEX_STRING("char")); break;
	case cs_name: print_esc(TEX_STRING("csname")); break;
	case def_font: print_esc(TEX_STRING("font")); break;
	case delim_num: print_esc(TEX_STRING("delimiter")); break;
	case divide: print_esc(TEX_STRING("divide")); break;
	case end_cs_name: print_esc(TEX_STRING("endcsname")); break;
	case end_group: print_esc(TEX_STRING("endgroup")); break;
	case ex_space: print_esc(TEX_STRING(" ")); break;
	case expand_after: print_esc(TEX_STRING("expandafter")); break;
	case halign: print_esc(TEX_STRING("halign")); break;
	case hrule: print_esc(TEX_STRING("hrule")); break;
	case ignore_spaces: print_esc(TEX_STRING("ignorespaces")); break;
	case insert: print_esc(TEX_STRING("insert")); break;
	case ital_corr: print_esc(TEX_STRING("/")); break;
	case mark: print_esc(TEX_STRING("mark")); break;
	case math_accent: print_esc(TEX_STRING("mathaccent")); break;
	case math_char_num: print_esc(TEX_STRING("mathchar")); break;
	case math_choice: print_esc(TEX_STRING("mathchoice")); break;
	case multiply: print_esc(TEX_STRING("multiply")); break;
	case no_align: print_esc(TEX_STRING("noalign")); break;
	case no_boundary: print_esc(TEX_STRING("noboundary")); break;
	case no_expand: print_esc(TEX_STRING("noexpand")); break;
	case non_script: print_esc(TEX_STRING("nonscript")); break;
	case omit: print_esc(TEX_STRING("omit")); break;
	case radical: print_esc(TEX_STRING("radical")); break;
	case read_to_cs: print_esc(TEX_STRING("read")); break;
	case relax: print_esc(TEX_STRING("relax")); break;
	case set_box: print_esc(TEX_STRING("setbox")); break;
	case set_prev_graf: print_esc(TEX_STRING("prevgraf")); break;
	case set_shape: print_esc(TEX_STRING("parshape")); break;
	case the: print_esc(TEX_STRING("the")); break;
	case toks_register: print_esc(TEX_STRING("toks")); break;
	case vadjust: print_esc(TEX_STRING("vadjust")); break;
	case valign: print_esc(TEX_STRING("valign")); break;
	case vcenter: print_esc(TEX_STRING("vcenter")); break;
	case vrule: print_esc(TEX_STRING("vrule")); break;

	//335
	case par_end: print_esc(TEX_STRING("par")); break;

	//377
	case input:
		if (chr_code == 0) print_esc(TEX_STRING("input"));
		else print_esc(TEX_STRING("endinput"));
		break;

	//385
	case top_bot_mark:
		switch (chr_code) {
		case first_mark_code: print_esc(TEX_STRING("firstmark")); break;
		case bot_mark_code: print_esc(TEX_STRING("botmark")); break;
		case split_first_mark_code: print_esc(TEX_STRING("splitfirstmark")); break;
		case split_bot_mark_code: print_esc(TEX_STRING("splitbotmark")); break;
		default: print_esc(TEX_STRING("topmark")); break;
		}
		break;

	//412
	case _register:
		if (chr_code == int_val) print_esc(TEX_STRING("count"));
		else if(chr_code == dimen_val) print_esc(TEX_STRING("dimen"));
		else if(chr_code == glue_val) print_esc(TEX_STRING("skip"));
		else print_esc(TEX_STRING("muskip"));
		break;

	//417
	case set_aux:
		if (chr_code == vmode) print_esc(TEX_STRING("prevdepth"));
		else print_esc(TEX_STRING("spacefactor"));
		break;
	case set_page_int:
		if (chr_code == 0) print_esc(TEX_STRING("deadcycles"));
		else print_esc(TEX_STRING("insertpenalties"));
		break;
	case set_box_dimen:
		if (chr_code == width_offset) print_esc(TEX_STRING("wd"));
		else if (chr_code == height_offset) print_esc(TEX_STRING("ht"));
		else print_esc(TEX_STRING("dp"));
		break;
	case last_item:
		switch (chr_code) {
		case int_val: print_esc(TEX_STRING("lastpenalty")); break;
		case dimen_val: print_esc(TEX_STRING("lastkern")); break;
		case glue_val: print_esc(TEX_STRING("lastskip")); break;
		case input_line_no_code: print_esc(TEX_STRING("inputlineno")); break;
		default: print_esc(TEX_STRING("badness")); break;
		}
		break;

		//469
	case convert:
		switch (chr_code) {
		case number_code: print_esc(TEX_STRING("number")); break;
		case roman_numeral_code: print_esc(TEX_STRING("romannumeral")); break;
		case string_code: print_esc(TEX_STRING("string")); break;
		case meaning_code: print_esc(TEX_STRING("meaning")); break;
		case font_name_code: print_esc(TEX_STRING("fontname")); break;
		default: print_esc(TEX_STRING("jobname")); break;
		}
		break;

		//488
	case if_test:
		switch (chr_code) {
		case if_cat_code: print_esc(TEX_STRING("ifcat")); break;
		case if_int_code: print_esc(TEX_STRING("ifnum")); break;
		case if_dim_code: print_esc(TEX_STRING("ifdim")); break;
		case if_odd_code: print_esc(TEX_STRING("ifodd")); break;
		case if_vmode_code: print_esc(TEX_STRING("ifvmode")); break;
		case if_hmode_code: print_esc(TEX_STRING("ifhmode")); break;
		case if_mmode_code: print_esc(TEX_STRING("ifmmode")); break;
		case if_inner_code: print_esc(TEX_STRING("ifinner")); break;
		case if_void_code: print_esc(TEX_STRING("ifvoid")); break;
		case if_hbox_code: print_esc(TEX_STRING("ifhbox")); break;
		case if_vbox_code: print_esc(TEX_STRING("ifvbox")); break;
		case ifx_code: print_esc(TEX_STRING("ifx")); break;
		case if_eof_code: print_esc(TEX_STRING("ifeof")); break;
		case if_true_code: print_esc(TEX_STRING("iftrue")); break;
		case if_false_code: print_esc(TEX_STRING("iffalse")); break;
		case if_case_code: print_esc(TEX_STRING("ifcase")); break;
		default: print_esc(TEX_STRING("if")); break;
		}
		break;

		//492
	case fi_or_else:
		if (chr_code == fi_code) print_esc(TEX_STRING("fi"));
		else if (chr_code == or_code) print_esc(TEX_STRING("or"));
		else print_esc(TEX_STRING("else"));
		break;

		//781
	case tab_mark:
		if (chr_code == span_code) print_esc(TEX_STRING("span"));
		else
			chr_cmd(TEX_STRING("alignment tab character "));
		break;
	case car_ret:
		if (chr_code == cr_code) print_esc(TEX_STRING("cr"));
		else print_esc(TEX_STRING("crcr"));
		break;

		//984
	case set_page_dimen:
		switch (chr_code) {
		case 0:print_esc(TEX_STRING("pagegoal")); break;
		case 1:print_esc(TEX_STRING("pagetotal")); break;
		case 2:print_esc(TEX_STRING("pagestretch")); break;
		case 3:print_esc(TEX_STRING("pagefilstretch")); break;
		case 4:print_esc(TEX_STRING("pagefillstretch")); break;
		case 5:print_esc(TEX_STRING("pagefilllstretch")); break;
		case 6:print_esc(TEX_STRING("pageshrink")); break;
		default:print_esc(TEX_STRING("pagedepth")); break;
		}
		break;

		//1053
	case stop:
		if (chr_code == 1) print_esc(TEX_STRING("dump"));
		else print_esc(TEX_STRING("end"));
		break;

		//1059
	case hskip:
		switch (chr_code) {
		case skip_code:print_esc(TEX_STRING("hskip")); break;
		case fil_code:print_esc(TEX_STRING("hfil")); break;
		case fill_code:print_esc(TEX_STRING("hfill")); break;
		case ss_code:print_esc(TEX_STRING("hss")); break;
		default:print_esc(TEX_STRING("hfilneg")); break;
		}
		break;
	case vskip:
		switch (chr_code) {
		case skip_code:print_esc(TEX_STRING("vskip")); break;
		case fil_code:print_esc(TEX_STRING("vfil")); break;
		case fill_code:print_esc(TEX_STRING("vfill")); break;
		case ss_code:print_esc(TEX_STRING("vss")); break;
		default:print_esc(TEX_STRING("vfilneg")); break;
		}
		break;
	case mskip:
		print_esc(TEX_STRING("mskip"));
		break;
	case kern:
		print_esc(TEX_STRING("kern"));
		break;
	case mkern:
		print_esc(TEX_STRING("mkern"));
		break;
		//1072
	case hmove:
		if (chr_code == 1) print_esc(TEX_STRING("moveleft"));
		else print_esc(TEX_STRING("moveright"));
		break;
	case vmove:
		if (chr_code == 1) print_esc(TEX_STRING("raise"));
		else print_esc(TEX_STRING("lower"));
		break;
	case make_box:
		switch (chr_code) {
		case box_code:print_esc(TEX_STRING("box")); break;
		case copy_code:print_esc(TEX_STRING("copy")); break;
		case last_box_code:print_esc(TEX_STRING("lastbox")); break;
		case vsplit_code:print_esc(TEX_STRING("vsplit")); break;
		case vtop_code:print_esc(TEX_STRING("vtop")); break;
		case vtop_code+vmode:print_esc(TEX_STRING("vbox")); break;
		default:print_esc(TEX_STRING("hbox")); break;
		}
		break;
	case leader_ship:
		if (chr_code == a_leaders) print_esc(TEX_STRING("leaders"));
		else if (chr_code == c_leaders) print_esc(TEX_STRING("cleaders"));
		else if (chr_code == x_leaders) print_esc(TEX_STRING("xleaders"));
		else print_esc(TEX_STRING("shipout"));
		break;

		//1089
	case start_par:
		if (chr_code == 0) print_esc(TEX_STRING("noindent"));
		else print_esc(TEX_STRING("indent"));
		break;

		//1108
	case remove_item:
		if (chr_code == glue_node) print_esc(TEX_STRING("unskip"));
		else if (chr_code == kern_node) print_esc(TEX_STRING("unkern"));
		else print_esc(TEX_STRING("unpenalty"));
		break;
	case un_hbox:
		if (chr_code == copy_code) print_esc(TEX_STRING("unhcopy"));
		else print_esc(TEX_STRING("unhbox"));
		break;
	case un_vbox:
		if (chr_code == copy_code) print_esc(TEX_STRING("unvcopy"));
		else print_esc(TEX_STRING("unvbox"));
		break;

		//1115
	case discretionary:
		if (chr_code == 1)print_esc(TEX_STRING("-"));
		else print_esc(TEX_STRING("discretionary"));
		break;

		//1143
	case eq_no:
		if (chr_code == 1) print_esc(TEX_STRING("leqno"));
		else print_esc(TEX_STRING("eqno"));
		break;

		//1157
	case math_comp:
		switch (chr_code) {
		case ord_noad: print_esc(TEX_STRING("mathord")); break;
		case op_noad: print_esc(TEX_STRING("mathop")); break;
		case bin_noad: print_esc(TEX_STRING("mathbin")); break;
		case rel_noad: print_esc(TEX_STRING("mathrel")); break;
		case open_noad: print_esc(TEX_STRING("mathopen")); break;
		case close_noad: print_esc(TEX_STRING("mathclose")); break;
		case punct_noad: print_esc(TEX_STRING("mathpunct")); break;
		case inner_noad: print_esc(TEX_STRING("mathinner")); break;
		case under_noad: print_esc(TEX_STRING("underline")); break;
		default: print_esc(TEX_STRING("overline")); break;
		}
		break;
	case limit_switch:
		if (chr_code == limits) print_esc(TEX_STRING("limits"));
		else if (chr_code == no_limits) print_esc(TEX_STRING("nolimits"));
		else print_esc(TEX_STRING("displaylimits"));
		break;

		//1170
	case math_style:
		print_style(chr_code);
		break;

		//1179
	case above:
		switch (chr_code) {
		case over_code: print_esc(TEX_STRING("over")); break;
		case atop_code: print_esc(TEX_STRING("atop")); break;
		case delimited_code+above_code: print_esc(TEX_STRING("abovewithdelims")); break;
		case delimited_code+over_code: print_esc(TEX_STRING("overwithdelims")); break;
		case delimited_code+atop_code: print_esc(TEX_STRING("atopwithdelims")); break;
		default: print_esc(TEX_STRING("above")); break;
		}
		break;

		//1189
	case left_right:
		if (chr_code == left_noad) print_esc(TEX_STRING("left"));
		else print_esc(TEX_STRING("right"));
		break;

		//1209
	case prefix:
		if (chr_code == 1) print_esc(TEX_STRING("long"));
		else if (chr_code == 2) print_esc(TEX_STRING("outer"));
		else print_esc(TEX_STRING("global"));
		break;
	case def: 
		if (chr_code == 0) print_esc(TEX_STRING("def"));
		else if (chr_code == 1) print_esc(TEX_STRING("gdef"));
		else if (chr_code == 2) print_esc(TEX_STRING("edef"));
		else print_esc(TEX_STRING("xdef"));
		break;

		//1220
	case let:
		if (chr_code != normal) print_esc(TEX_STRING("futurelet"));
		else print_esc(TEX_STRING("let"));
		break;


		//1223
	case shorthand_def:
		switch (chr_code) {
		case char_def_code: print_esc(TEX_STRING("chardef")); break;
		case math_char_def_code: print_esc(TEX_STRING("mathchardef")); break;
		case count_def_code: print_esc(TEX_STRING("countdef")); break;
		case dimen_def_code: print_esc(TEX_STRING("dimendef")); break;
		case skip_def_code: print_esc(TEX_STRING("skipdef")); break;
		case mu_skip_def_code: print_esc(TEX_STRING("muskipdef")); break;
		default: print_esc(TEX_STRING("toksdef")); break;
		}
		break;
	case char_given:
		print_esc(TEX_STRING("char")); print_hex(chr_code);
		break;
	case math_given:
		print_esc(TEX_STRING("mathchar")); print_hex(chr_code);
		break;

		//1231
	case def_code:
		if (chr_code == cat_code_base) print_esc(TEX_STRING("catcode"));
		else if (chr_code == math_code_base) print_esc(TEX_STRING("mathcode"));
		else if (chr_code == lc_code_base) print_esc(TEX_STRING("lccode"));
		else if (chr_code == uc_code_base) print_esc(TEX_STRING("uccode"));
		else if (chr_code == sf_code_base) print_esc(TEX_STRING("sfcode"));
		else  print_esc(TEX_STRING("delcode"));
		break;
	case def_family:
		print_size(chr_code - math_font_base);
		break;

		//1251
	case hyph_data:
		if (chr_code == 1) print_esc(TEX_STRING("patterns"));
		else print_esc(TEX_STRING("hyphenation"));
		break;

		//1255
	case assign_font_int:
		if (chr_code == 0) print_esc(TEX_STRING("hyphenchar"));
		else print_esc(TEX_STRING("skewchar"));
		break;

		//1261
	case set_font:
		print(TEX_STRING("select font "));
		slow_print(font_name[chr_code]);
		if (font_size[chr_code] != font_dsize[chr_code]) {
			print(TEX_STRING(" at ")); print_scaled(font_size[chr_code]);
			print(TEX_STRING("pt"));
		}
		break;

		//1263
	case set_interaction:
		switch (chr_code) {
		case batch_mode: print_esc(TEX_STRING("batchmode")); break;
		case nonstop_mode: print_esc(TEX_STRING("nonstopmode")); break;
		case scroll_mode: print_esc(TEX_STRING("scrollmode")); break;
		default: print_esc(TEX_STRING("errorstopmode")); break;
		}
		break;

		// 1273
	case in_stream:
		if (chr_code == 0) print_esc(TEX_STRING("closein"));
		else print_esc(TEX_STRING("openin"));
		break;

		//1278
	case message:
		if (chr_code == 0) print_esc(TEX_STRING("message"));
		else print_esc(TEX_STRING("errmessage"));
		break;

		//1287
	case case_shift:
		if (chr_code == lc_code_base) print_esc(TEX_STRING("lowercase"));
		else print_esc(TEX_STRING("uppercase"));
		break;

		//1292
	case xray:
		switch (chr_code) {
		case show_box_code: print_esc(TEX_STRING("showbox")); break;
		case show_the_code: print_esc(TEX_STRING("showthe")); break;
		case show_lists: print_esc(TEX_STRING("showlists")); break;
		default: print_esc(TEX_STRING("show")); break;
		}
		break;

		//1295
	case undefined_cs: print(TEX_STRING("undefined")); break;
	case call: print(TEX_STRING("macro")); break;
	case long_call: print_esc(TEX_STRING("long macro")); break;
	case outer_call: print_esc(TEX_STRING("outer macro")); break;
	case long_outer_call: 
		print_esc(TEX_STRING("long"));
		print_esc(TEX_STRING("outer macro"));
		break;
	case end_template: print_esc(TEX_STRING("outer endtemplate")); break;

		//1346
	case extension:
		switch (chr_code) {
		case open_node: print_esc(TEX_STRING("openout")); break;
		case write_node: print_esc(TEX_STRING("write")); break;
		case close_node: print_esc(TEX_STRING("closeout")); break;
		case special_node: print_esc(TEX_STRING("special")); break;
		case immediate_code: print_esc(TEX_STRING("immediate")); break;
		case set_language_code: print_esc(TEX_STRING("setlanguage")); break;
		default: print(TEX_STRING("[unknown extension!]")); break;
		}
		break;



#pragma endregion

	default:
		print(TEX_STRING("[unknown command code!]"));
		break;
	}
}

// 341
void get_next()
{
	int k;
	halfword t;
	unsigned int cat;
	ASCII_code c, cc;
	unsigned char d;

restart:
	cur_cs = 0;
	if (state != token_list)
		#pragma region <Input from external file, goto restart if no input found 343>
	{
	_switch:
		if (loc <= limit) {
			cur_chr = buffer[loc]; incr(loc);
		reswitch:
			cur_cmd = (eight_bits)cat_code(cur_chr);
			#pragma region <Change state if necessary and goto switch if the current character shoudl be ignored, or goto reswtich if the current character changes to another 344>
			switch (state + cur_cmd) {
			#pragma region <cases where character is ignored 345>
			case any_state_plus(ignore):
			case skip_blanks + spacer:
			case new_line + spacer:
			#pragma endregion
				goto _switch;
				break;
			case any_state_plus(escape):
				#pragma region <Scan a control sequence and set state to skip_blanks or mid line 354>
				if (loc > limit)
					cur_cs = null_cs;
				else {
				start_cs:
					k = loc; cur_chr = buffer[k]; cat = cat_code(cur_chr); incr(k);
					if (cat == letter)
						state = skip_blanks;
					else if (cat == spacer)
						state = skip_blanks;
					else
						state = mid_line;
					if (cat == letter && k <= limit) 
						#pragma region <Scan ahead in the buffer until finding a nonletter; .. 356>
					{
						do {
							cur_chr = buffer[k]; cat = cat_code(cur_chr); incr(k);
						} while (!(cat != letter || k > limit));

						#pragma region <If an expanded code is present, reduce it and goto start_cs 355>
						if (buffer[k] == cur_chr)
							if (cat == sup_mark) 
								if (k < limit) {
									c = buffer[k + 1];
									if (c < 0200) {
										d = 2;
										if (is_hex(c)) 
											if (k + 2 <= limit) {
												cc = buffer[k + 2];
												if (is_hex(cc))
													incr(d);
											}
										
										if (d > 2) {
											hex_to_cur_chr;
											buffer[k - 1] = (unsigned char)cur_chr;
										}
										else if (c < 0100)
											buffer[k - 1] = c + 0100;
										else
											buffer[k - 1] = c - 0100;

										limit = limit - d; first = first - d;
										while (k <= limit) {
											buffer[k] = buffer[k + d]; incr(k);
										}
										goto start_cs;
									}
								}
#pragma endregion

						if (cat != letter)
							decr(k);
						if (k > loc + 1) {
							cur_cs = id_lookup(loc, k - loc); loc = k; goto found;
						}
					}
#pragma endregion
					else 
						#pragma region <If an expanded code is present, reduce it and goto start_cs 355>
					{

						if (buffer[k] == cur_chr)
							if (cat == sup_mark)
								if (k < limit) {
									c = buffer[k + 1];
									if (c < 0200) {
										d = 2;
										if (is_hex(c))
											if (k + 2 <= limit) {
												cc = buffer[k + 2];
												if (is_hex(cc))
													incr(d);
											}

										if (d > 2) {
											hex_to_cur_chr;
											buffer[k - 1] = (unsigned char)cur_chr;
										}
										else if (c < 0100)
											buffer[k - 1] = c + 0100;
										else
											buffer[k - 1] = c - 0100;

										limit = limit - d; first = first - d;
										while (k <= limit) {
											buffer[k] = buffer[k + d]; incr(k);
										}
										goto start_cs;
									}
								}

					}
#pragma endregion

					cur_cs = single_base + buffer[loc]; incr(loc);
				}
			found:
				cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				if (cur_cmd >= outer_call)
					check_outer_validity();
#pragma endregion
				break;
			case any_state_plus(active_char):
				#pragma region <Process an active-character control sequence and set state to mid line 353>
				cur_cs = cur_chr + active_base; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				state = mid_line;
				if (cur_cmd >= outer_call) check_outer_validity();

#pragma endregion
				break;
			case any_state_plus(sup_mark):
#pragma region <If this sup_mark starts an expanded character like ^^A or ^^df then goto reswitch, otherwwise set state to mid line 352>
				if(cur_chr == buffer[loc])
					if (loc < limit) {
						c = buffer[loc + 1]; 
						if (c < 0200) {
							loc += 2;
							if(is_hex(c))
								if (loc <= limit) {
									cc = buffer[loc];
									if (is_hex(cc)) {
										incr(loc); hex_to_cur_chr;
										goto reswitch;
									}									
								}
							if (c < 0100) cur_chr = c + 0100;
							else cur_chr = c - 0100;
							goto reswitch;
						}
					}
				state = mid_line;
#pragma endregion

				break;
			case any_state_plus(invalid_char):
				#pragma region <Decry the invalid character and goto restart 346>
				print_err(TEX_STRING("Text line contains an invalid character"));
				help2(TEX_STRING("A funny symbol that I can't read has just been input."),
					TEX_STRING("Continue, and I'll forget that it ever happened."));
				deletions_allowed = false; error(); deletions_allowed = true;
				goto restart;

#pragma endregion
				break;

			#pragma region <Handle situations involving spaces, braces, changes of state 347>
			case mid_line+spacer:
				//<Enter skip_blanks state, emit a space 349>
				state = skip_blanks; cur_chr = TEX_STRING(" ");
				break;
			case mid_line + car_ret:
				//<Finish line, emit a spcae 348>
				loc = limit + 1; cur_cmd = spacer; cur_chr = TEX_STRING(" ");
				break;
			case skip_blanks+car_ret:
			case any_state_plus(comment):
				//<Finish line, goto switch 350>
				loc = limit + 1;
				goto _switch;
				break;
			case new_line+car_ret:
				//<Finish line, emit a \par 351>
				loc = limit + 1; cur_cs = par_loc; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				if (cur_cmd >= outer_call)
					check_outer_validity();
				break;
			case mid_line+left_brace:
				incr(align_state);
				break;
			case skip_blanks+left_brace:
			case new_line+left_brace:
				state = mid_line; incr(align_state);
				break;
			case mid_line+right_brace:
				decr(align_state);
				break;
			case skip_blanks+right_brace:
			case new_line+right_brace:
				state = mid_line; decr(align_state);
				break;
			case add_delims_to(skip_blanks):
			case add_delims_to(new_line):
				state = mid_line;
				break;

#pragma endregion

			}
#pragma endregion
		}
		else {
			state = new_line;
			#pragma region <Move to next line of file or goto restart if there is no next linek or return if a read line has finished 360>
			if (name > 17)
				#pragma region <Read next line of file into buffer, or goto restart if the file has ended 362>
			{
				incr(line); first = start;
				if (!force_eof) {
					if (input_ln(cur_file, true))
						firm_up_the_line();
					else force_eof = true;
				}
				if (force_eof) {
					print_char(TEX_STRING(")")); decr(open_parens); update_terminal();
					force_eof = false; end_file_reading();
					check_outer_validity(); goto restart;
				}
				if (end_line_char_inactive) decr(limit);
				else buffer[limit] = end_line_char;
				first = limit + 1; loc = start;
			}
#pragma endregion
			else {
				if (!terminal_input) {
					cur_cmd = 0; cur_chr = 0; return;
				}
				if (input_ptr > 0) {
					end_file_reading(); goto restart;
				}
				if (selector < log_only) open_log_file();
				if (interaction > nonstop_mode) {
					if (end_line_char_inactive) incr(limit);
					if (limit == start)
						print_nl(TEX_STRING("(Please type a command or say `\end')"));
					print_ln(); first = start; prompt_input(TEX_STRING("*"));
					limit = last;
					if (end_line_char_inactive) decr(limit);
					else buffer[limit] = end_line_char;
					first = limit + 1; loc = start;
				}
				else fatal_error(TEX_STRING("*** (job aborted, no legal \end found)"));
			}

#pragma endregion
			check_interrupt;
			goto _switch;
		}
	}
		#pragma endregion
	else
		#pragma region <Input from token list, goto restart if end of list or if a parameter needs to be expanded 357>
	{
		
		if (loc != null) {
			t = info(loc); loc = link(loc);
			if (t >= cs_token_flag) {
				cur_cs = t - cs_token_flag; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				if (cur_cmd >= outer_call)
					if (cur_cmd == dont_expand)
						#pragma region <Get the next token, suppressing expansion 358>
					{						
						cur_cs = info(loc) - cs_token_flag; loc = null;
						cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
						if (cur_cmd > max_command) {
							cur_cmd = relax; cur_chr = no_expand_flag;
						}
					}
						#pragma endregion
					else check_outer_validity();
			}
			else {
				cur_cmd = t / 0400; cur_chr = t % 0400;
				switch (cur_cmd) {
				case left_brace: incr(align_state); break;
				case right_brace: decr(align_state); break;
				case out_param:
					#pragma region <Insert macro parameter and goto restart 359>
					begin_token_list(param_stack[param_start + cur_chr - 1], parameter);
					goto restart;
					#pragma endregion
					break;
				default:
					//do_nothing
					break;
				}
			}
		}
		else {
			end_token_list();
			goto restart;
		}
	}
		#pragma endregion
	
	#pragma region <If an alignment entry has just ended take appropriate action 342>
	if(cur_cmd <= car_ret)
		if(cur_cmd >= tab_mark)
			if (align_state == 0) 
				#pragma region <Insert the <v_j> template and goto restart 789>
			{
				
				if (scanner_status == aligning || cur_align == null)
					fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
				cur_cmd = (eight_bits)extra_info(cur_align); extra_info(cur_align) = cur_chr;
				if (cur_cmd == omit) begin_token_list(omit_template, v_template);
				else begin_token_list(v_part(cur_align), v_template);
				align_state = 1000000;
				goto restart;
			}
#pragma endregion

#pragma endregion

}


// 365
void get_token()
{
	no_new_control_sequence = false;
	get_next();
	no_new_control_sequence = true;
	if (cur_cs == 0)
		cur_tok = (cur_cmd * 0400) + cur_chr;
	else
		cur_tok = cs_token_flag + cur_cs;
}

// 95
void confusion(str_number s)
{
	normalize_selector();
	if (history < error_message_issued)
	{
		print_err(TEX_STRING("This can't happen (")); print(s); 
		print_char(TEX_STRING(")"));
		help1(TEX_STRING("I'm broken. Please show this to someone who can fix can fix"));
	}
	else {
		print_err(TEX_STRING("I can't go on meeting you like this"));
		help2(TEX_STRING("One of your faux pas seems to have wounded me deeply..."),
			TEX_STRING("in fact, I'm barely conscious. Please fix it and try again."));
	}
	succumb;
}

// 123
void flush_list(pointer p)
{
	pointer q, r;
	if (p != null) {
		r = p;
		do {
			q = r; r = link(r);
			//stat
			decr(dyn_used);
			//tats

		} while (r != null);
		link(q) = avail; avail = p;
	}
}

// 130
void free_node(pointer p, halfword s)
{
	pointer q;
	node_size(p) = s;
	link(p) = empty_flag;
	q = llink(rover);
	llink(p) = q; rlink(p) = rover;
	llink(rover) = p; rlink(q) = p;
	//stat
	var_used -= s;
	//tats

}

// 154
pointer new_skip_param(small_number n)
{
	pointer p;
	temp_ptr = new_spec(/*<Current mem equiv... 224*/glue_par(n));
	p = new_glue(temp_ptr); glue_ref_count(temp_ptr) = null; subtype(p) = n + 1;
	return p;
}


// 200
void delete_token_ref(pointer p)
{
	if (token_ref_count(p) == null)
		flush_list(p);
	else decr(token_ref_count(p));
}

// 201
void delete_glue_ref(pointer p)
{
	fast_delete_glue_ref(p);
}

// 202
void flush_node_list(pointer p)
{
	pointer q;
	while (p != null) {
		q = link(p);
		if (is_char_node(p))
			free_avail(p);
		else {
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case unset_node:
				flush_node_list(list_ptr(p));
				free_node(p, box_node_size);
				goto done;
				break;

			case rule_node:
				free_node(p, rule_node_size);
				goto done;
				break;

			case ins_node:
				flush_node_list(ins_ptr(p)); delete_glue_ref(split_top_ptr(p));
				free_node(p, ins_node_size);
				goto done;
				break;
			case whatsit_node:
				#pragma region <Wipe out the whatsit node p and goto done 1358>
				switch (subtype(p)) {
				case open_node:
					free_node(p, open_node_size);
					break;
				case write_node:
				case special_node:
					delete_token_ref(write_tokens(p));
					free_node(p, write_node_size);
					goto done;
					break;
				case close_node:
				case language_node:
					free_node(p, small_node_size);
					break;
				default:
					confusion(TEX_STRING("ext3"));
					break;
				}
				goto done;
				#pragma endregion
				break;
			case glue_node:
				fast_delete_glue_ref(glue_ptr(p));
				if (leader_ptr(p) != null)
					flush_node_list(leader_ptr(p));
				break;
			case kern_node:
			case math_node:
			case penalty_node:
				break;
			case ligature_node:
				flush_node_list(lig_ptr(p));
				break;
			case mark_node:
				delete_token_ref(mark_ptr(p));
				break;
			case disc_node:
				flush_node_list(pre_break(p)); flush_node_list(post_break(p));
				break;
			case adjust_node:
				flush_node_list(adjust_ptr(p));
				break;
			#pragma region <Cases of flush_node_list that arise in mlists only 698>
			case style_node:
				free_node(p, style_node_size);
				goto done;
				break;
			case choice_node:
				flush_node_list(display_mlist(p)); flush_node_list(text_mlist(p));
				flush_node_list(script_mlist(p)); flush_node_list(script_script_mlist(p));
				free_node(p, style_node_size);
				goto done;
				break;

			case ord_noad:
			case op_noad:
			case bin_noad:
			case rel_noad:
			case open_noad:
			case close_noad:
			case punct_noad:
			case inner_noad:
			case radical_noad:
			case over_noad:
			case under_noad:
			case vcenter_noad:
			case accent_noad:
				if (math_type(nucleus(p)) >= sub_box) flush_node_list(info(nucleus(p)));
				if (math_type(supscr(p)) >= sub_box) flush_node_list(info(supscr(p)));
				if (math_type(subscr(p)) >= sub_box) flush_node_list(info(subscr(p)));
				if (type(p) == radical_noad) free_node(p, radical_noad_size);
				else if (type(p) == accent_noad) free_node(p, accent_noad_size);
				else free_node(p, noad_size);
				goto done;
				break;
			case left_noad:
			case right_noad:
				free_node(p, noad_size);
				goto done;
				break;
			case fraction_noad:
				flush_node_list(info(numerator(p))); flush_node_list(info(denominator(p)));
				free_node(p, fraction_noad_size);
				goto done;
				break;
			#pragma endregion

			default:
				confusion(TEX_STRING("flushing"));
				break;
			}
			free_node(p, small_node_size);
		done:
			;
		}

		p = q;
	}
}

// 120
pointer get_avail()
{
	pointer p;
	p = avail;
	if (p != null) avail = link(avail);
	else if (mem_end < mem_max) {
		incr(mem_end); p = mem_end;
	}
	else {
		decr(hi_mem_min); p = hi_mem_min;
		if (hi_mem_min <= lo_mem_max) {
			runaway();
			overflow(TEX_STRING("main memory size"), mem_max + 1 - mem_min);
		}
	}
	link(p) = null;
	//stat
	incr(dyn_used);
	//tats

	return p;
}

// 121
void free_avail(pointer s)
{
	link(s) = avail; 
	avail = s;
	/*stat*/
	decr(dyn_used);
	/*tats*/ 
}


// 98
void pause_for_instructions()
{
	if (OK_to_interrupt) {
		interaction = error_stop_mode;
		if (selector == log_only || selector == no_print)
			incr(selector);
		print_err(TEX_STRING("Interruption"));
		help3(TEX_STRING("You rang?"),
			TEX_STRING("Try to insert some instructions for me (e.g.,`I\showlists'),"),
			TEX_STRING("unless you just want to quit by typing `X'."));
		deletions_allowed = false;
		error();
		deletions_allowed = true;
		interrupt = 0;
	}
}


// 144
pointer new_ligature(quarterword f, quarterword c, pointer q)
{
	pointer p;
	p = get_node(small_node_size); type(p) = ligature_node; font(lig_char(p)) = f;
	character(lig_char(p)) = c; lig_ptr(p) = q; subtype(p) = 0;
	return p;
}

pointer new_lig_item(quarterword c)
{
	pointer p;
	p = get_node(small_node_size); character(p) = c; lig_ptr(p) = null;
	return p;
}

// 145
pointer new_disc()
{
	pointer p;
	p = get_node(small_node_size); type(p) = disc_node; replace_count(p) = 0; pre_break(p) = null;
	post_break(p) = null;
	return p;
}

pointer new_rule()
{
	pointer p;

	p = get_node(rule_node_size);
	type(p) = rule_node; subtype(p) = 0;
	width(p) = null_flag; depth(p) = null_flag; height(p) = null_flag;
	return p;
}

// 263
void sprint_cs(pointer p)
{
	if (p < hash_base) {
		if (p < single_base)
			print(p - active_base);
		else if (p < null_cs)
			print_esc(p - single_base);
		else {
			print_esc(TEX_STRING("csname"));
			print_esc(TEX_STRING("endcsname"));
		}
	}
	else
		print_esc(text(p));
}


// 306
void runaway()
{
	pointer p;
	if (scanner_status > skipping) {
		print_nl(TEX_STRING("Runaway "));
		switch (scanner_status) {
		case defining:
			print(TEX_STRING("definition"));
			p = def_ref;
			break;
		case matching:
			print(TEX_STRING("argument"));
			p = temp_head;
			break;
		case aligning:
			print(TEX_STRING("preamble"));
			p = hold_head;
			break;
		case absorbing:
			print(TEX_STRING("text"));
			p = def_ref;
			break;
		}
		print_char(TEX_STRING("?"));
		print_ln();
		show_token_list(link(p), null, error_line - 10);
	}
}

// 336
void check_outer_validity()
{
	pointer p, q;

	if (scanner_status != normal) {
		deletions_allowed = false;
		#pragma region <Back up an outer control sequence so that it can be reread 337>
		if (cur_cs != 0) {
			if (state == token_list || name < 1 || name >17) {
				p = get_avail(); info(p) = cs_token_flag + cur_cs; back_list(p);
			}
			cur_cmd = spacer; cur_chr = TEX_STRING(" ");
		}
		#pragma endregion

		if (scanner_status > skipping) 
			#pragma region <Tell the user what has run away and try to recover 338>
		{
			runaway();
			if (cur_cs == 0) print_err(TEX_STRING("File ended"));
			else {
				cur_cs = 0; print_err(TEX_STRING("Forbidden control sequence found"));
			}
			print(TEX_STRING(" while scanning "));
			#pragma region <Print either definition or use or preamble or text, and insert tokens that should lead to recovery 339>
			p = get_avail();
			switch (scanner_status) {
			case defining: 
				print(TEX_STRING("definition"));
				info(p) = right_brace_token + TEX_STRING("}");
				break;
			case matching:
				print(TEX_STRING("use"));
				info(p) = par_token; long_state = outer_call;
				break;
			case aligning:
				print(TEX_STRING("preamble"));
				info(p) = right_brace_token + TEX_STRING("}");
				q = p; p = get_avail();
				link(p) = q; info(p) = cs_token_flag + frozen_cr; align_state = -1000000;
				break;
			case absorbing:
				print(TEX_STRING("text")); 
				info(p) = right_brace_token + TEX_STRING("}");
				break;
			}
			ins_list(p);
			#pragma endregion

			print(TEX_STRING(" of ")); sprint_cs(warning_index);
			help4(TEX_STRING("I suspect you have forgotten a `}', causing me"),
				TEX_STRING("to read past where you wanted me to stop."),
				TEX_STRING("I'll try to recover; but if the error is serious,"),
				TEX_STRING("you'd better type `E' or `X' now and fix your file."));
			error();
		}
			#pragma endregion
		else {
			print_err(TEX_STRING("Incomplete ")); print_cmd_chr(if_test, cur_if);
			print(TEX_STRING("; all text was ignored after line ")); print_int(skip_line);
			help3(TEX_STRING("A forbidden control sequence occurred in skipped text."),
				TEX_STRING("This kind of error happens when you say `\if...' and forget"),
				TEX_STRING("the matching `\fi'. I've inserted a `\fi'; this might work."));
			if (cur_cs != 0)
				cur_cs = 0;
			else
				help_line[2] = TEX_STRING("The file ended while I was skipping conditional text.");
			cur_tok = cs_token_flag + frozen_fi; ins_error();
		}
		deletions_allowed = true;
	}
}

// 325
void back_input()
{
	pointer p;
	while (state == token_list && loc == null && token_type != v_template)
		end_token_list();
	p = get_avail(); info(p) = cur_tok;
	if (cur_tok < right_brace_limit)
		if (cur_tok < left_brace_limit)
			decr(align_state);
		else
			incr(align_state);
	push_input;
	state = token_list;
	start = p; token_type = backed_up; loc = p;
}

// 107
scaled xn_over_d(scaled x, int n, int d)
{
	bool positive;
	nonnegative_integer t, u, v;
	if (x >= 0)
		positive = true;
	else {
		negate(x); positive = false;
	}
	t = (x % 0100000)*n;
	u = (x / 0100000)*n + (t / 0100000);
	v = (u%d) * 0100000 + (t % 0100000);
	if (u / d >= 0100000)
		arith_error = true;
	else
		u = 0100000 * (u / d) + (v / d);
	if (positive) {
		_remainder = v % d;
		return u;
	}
	else {
		_remainder = -(v % d);
		return -u;
	}
}

// 125
pointer get_node(int s)
{
	pointer p;
	pointer q;
	int r;
	int t;
restart:
	p = rover;
	do {
		#pragma region <Try to allocate within node p and its physical successors and goto found if possible 127>
		q = p + node_size(p);
		while (is_empty(q)) {
			t = rlink(q);
			if (q == rover) rover = t;
			llink(t) = llink(q); rlink(llink(q)) = t;
			q = q + node_size(q);
		}
		r = q - s;
		if (r > p + 1) 
			#pragma region <Allocate from the top of node p and goto found 128>
		{
			node_size(p) = r - p;
			rover = p;
			goto found;
		}
			#pragma endregion

		if (r == p)
			if (rlink(p) != p) 
				#pragma region <Allocate entire node p and goto found 129>
			{
				rover = rlink(p); t = llink(p); llink(rover) = t; rlink(t) = rover;
				goto found;
			}
				#pragma endregion
		node_size(p) = q - p;
		#pragma endregion
		p = rlink(p);
	} while (!(p == rover));

	if (s == 010000000000) {
		return max_halfword;
	}

	if (lo_mem_max + 2 < hi_mem_min)
		if (lo_mem_max + 2 <= mem_bot + max_halfword) 
			#pragma region <Grow more variable-size memory and goto restart 126>
		{
			if (hi_mem_min - lo_mem_max >= 1998)
				t = lo_mem_max + 1000;
			else
				t = lo_mem_max + 1 + (hi_mem_min - lo_mem_max) / 2;
			p = llink(rover); q = lo_mem_max; rlink(p) = q; llink(rover) = q;
			if (t > mem_bot + max_halfword)
				t = mem_bot + max_halfword;
			rlink(q) = rover; llink(q) = p; link(q) = empty_flag; node_size(q) = t - lo_mem_max;
			lo_mem_max = t; link(lo_mem_max) = null; info(lo_mem_max) = null; rover = q;
			goto restart;
		}
			#pragma endregion

	overflow(TEX_STRING("main memory size"), mem_max + 1 - mem_min);
found:
	link(r) = null;
	//stat
	var_used = var_used + s;
	//tats

	return r;
}

// 151
pointer new_spec(pointer p)
{
	pointer q;
	q = get_node(glue_spec_size);
	mem[q] = mem[p]; glue_ref_count(q) = null;
	width(q) = width(p); stretch(q) = stretch(p); shrink(q) = shrink(p); 
	return q;
}



// 152
pointer new_param_glue(small_number n)
{
	pointer p;
	pointer q;
	p = get_node(small_node_size); type(p) = glue_node;
	subtype(p) = n + 1; leader_ptr(p) = null;
	q = 
		#pragma region <Current mem quivalent of glue parameter n 224>
		glue_par(n);
		#pragma endregion

	glue_ptr(p) = q;
	incr(glue_ref_count(q));
	return p;

}

// 153
pointer new_glue(pointer q)
{
	pointer p;
	p = get_node(small_node_size); type(p) = glue_node;
	subtype(p) = normal;
	leader_ptr(p) = null; glue_ptr(p) = q; incr(glue_ref_count(q));
	return p;
}

// 158
pointer new_penalty(int m)
{
	pointer p;
	p = get_node(small_node_size); type(p) = penalty_node;
	subtype(p) = 0;
	penalty(p) = m;
	return p;
}

// 327
void back_error()
{
	OK_to_interrupt = false;
	back_input();
	OK_to_interrupt = true;
	error();
}

void ins_error()
{
	OK_to_interrupt = false;
	back_input();
	token_type = inserted;
	OK_to_interrupt = true;
	error();
}

// 328

void begin_file_reading()
{
	if (in_open == max_in_open)
		overflow(TEX_STRING("text input levels"), max_in_open);
	if (first == buf_size)
		overflow(TEX_STRING("buffer size"), buf_size);
	incr(in_open); push_input; index = (enum_token_type)in_open; line_stack[index] = line;
	start = first; state = mid_line;
	name = 0;
}

// 182
void show_node_list(int p)
{
	int n;
	double g;
	if (cur_length > depth_threshold) {
		if (p > null)
			print(TEX_STRING(" []"));
		return;
	}
	n = 0;
	while (p > mem_min) {
		print_ln(); print_current_string();
		if (p > mem_end) {
			print(TEX_STRING("Bad link, display aborted."));
			return;
		}
		incr(n);
		if (n > breadth_max) {
			print(TEX_STRING("etc."));
			return;
		}
		#pragma region <Display node p 183>
		if (is_char_node(p))
			print_font_and_char(p);
		else
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case unset_node:
				#pragma region <Display box p 184>
				if (type(p) == hlist_node) print_esc(TEX_STRING("h"));
				else if (type(p) == vlist_node) print_esc(TEX_STRING("v"));
				else print_esc(TEX_STRING("unset"));
				print(TEX_STRING("box("));
				print_scaled(height(p));
				print_char(TEX_STRING("+"));
				print_scaled(depth(p));
				print(TEX_STRING(")x"));
				print_scaled(width(p));
				if (type(p) == unset_node) 
					#pragma region <Display special fields of the unset node p 185>
				{
					if (span_count(p) != min_quarterword) {
						print(TEX_STRING(" ("));
						print_int(qo(span_count(p))+1);
						print(TEX_STRING(" columns)"));
					}
					if (glue_stretch(p) != 0) {
						print(TEX_STRING(", stretch ")); print_glue(glue_stretch(p), glue_order(p), 0);
					}
					if (glue_shrink(p) != 0) {
						print(TEX_STRING(", shrink ")); print_glue(glue_shrink(p), glue_sign(p), 0);
					}
				}
					#pragma endregion
				else {
					#pragma region <Display the value of glue_set(p) 186>
					g = _float(glue_set(p));
					if (g != 0.0f && glue_sign(p) != normal) {
						print(TEX_STRING(", glue set "));
						if (glue_sign(p) == shrinking) print(TEX_STRING("- "));
						if (abs(mem[p + glue_offset].union_t.an_int) < 04000000)
							print(TEX_STRING("?.?"));
						else if (abs(g) > 20000.0f) {
							if (g > 0.0f) print_char(TEX_STRING(">"));
							else print(TEX_STRING("< -"));
							print_glue(20000 * unity, glue_order(p), 0);
						}
						else print_glue((scaled)round(unity*g), glue_order(p), 0);
					}
					#pragma endregion
					if (shift_amount(p) != 0) {
						print(TEX_STRING(", shifted ")); print_scaled(shift_amount(p));
					}
				}
				node_list_display(list_ptr(p));
				#pragma endregion
				break;
			case rule_node:
				#pragma region <Display rule p 187>
				print_esc(TEX_STRING("rule("));
				print_rule_dimen(height(p));
				print_char(TEX_STRING("+"));
				print_rule_dimen(depth(p));
				print(TEX_STRING(")x"));
				print_rule_dimen(width(p));
				#pragma endregion
				break;
			case ins_node:
				#pragma region <Display insertions p 188>
				print_esc(TEX_STRING("insert"));
				print_int(qo(subtype(p)));
				print(TEX_STRING(", natural size "));
				print_scaled(height(p));
				print(TEX_STRING("; split("));
				print_spec(split_top_ptr(p), 0);
				print_char(TEX_STRING(","));
				print_scaled(depth(p));
				print(TEX_STRING("); float cost "));
				print_int(float_cost(p));
				node_list_display(ins_ptr(p));
				#pragma endregion
				break;
			case whatsit_node:
				#pragma region <Display the whatsit node p 1356>
				switch (subtype(p)) {
				case open_node:
					print_write_whatsit(TEX_STRING("openout"), p);
					print_char(TEX_STRING("="));
					print_file_name(open_name(p), open_area(p), open_ext(p));
					break;
				case write_node:
					print_write_whatsit(TEX_STRING("write"), p); print_mark(write_tokens(p));
					break;
				case close_node:
					print_write_whatsit(TEX_STRING("closeout"), p);
					break;
				case special_node:
					print_esc(TEX_STRING("special")); print_mark(write_tokens(p));
					break;
				case language_node:
					print_esc(TEX_STRING("setlanguage")); print_int(what_lang(p));
					print(TEX_STRING(" (hyphenmin "));
					print_int(what_lhm(p)); print_char(TEX_STRING(","));
					print_int(what_rhm(p)); print_char(TEX_STRING(")"));
					break;
				default:
					print(TEX_STRING("whatsit?"));
					break;
				}
				#pragma endregion
				break;
			case glue_node:
				#pragma region <Display glue p 189>
				if (subtype(p) >= a_leaders) 
					#pragma region <Display leaders p 190>
				{
					print_esc(TEX_STRING(""));
					if (subtype(p) == c_leaders) print_char(TEX_STRING("c"));
					else if (subtype(p) == x_leaders) print_char(TEX_STRING("x"));
					print(TEX_STRING("leaders "));
					print_spec(glue_ptr(p), 0); node_list_display(leader_ptr(p));
				}
					#pragma endregion
				else {
					print_esc(TEX_STRING("glue"));
					if (subtype(p) != normal) {
						print_char(TEX_STRING("("));
						if (subtype(p) < cond_math_glue) print_skip_param(subtype(p) - 1);
						else if (subtype(p) == cond_math_glue) print_esc(TEX_STRING("nonscript"));
						else print_esc(TEX_STRING("mskip"));
						print_char(TEX_STRING(")"));
					}
					if (subtype(p) != cond_math_glue) {
						print_char(TEX_STRING(" "));
						if (subtype(p) < cond_math_glue) print_spec(glue_ptr(p), 0);
						else print_spec(glue_ptr(p), TEX_STRING("mu"));
					}
				}
				#pragma endregion
				break;
			case kern_node:
				#pragma region <Display kern p 191>
				if (subtype(p) != mu_glue) {
					print_esc(TEX_STRING("kern"));
					if (subtype(p) != normal) print_char(TEX_STRING(" "));
					print_scaled(width(p));
					if (subtype(p) == acc_kern) print(TEX_STRING(" (for accent)"));
				}
				else {
					print_esc(TEX_STRING("mkern")); print_scaled(width(p));
					print(TEX_STRING("mu"));
				}
				#pragma endregion
				break;
			case math_node:
				#pragma region <Display math node p 192>
				print_esc(TEX_STRING("math"));
				if (subtype(p) == before) print(TEX_STRING("on"));
				else print(TEX_STRING("off"));
				if (width(p) != 0) {
					print(TEX_STRING(", surrounded ")); print_scaled(width(p));
				}
				#pragma endregion
				break;
			case ligature_node:
				#pragma region <Display ligature p 193>
				print_font_and_char(lig_char(p)); print(TEX_STRING(" (ligature "));
				if (subtype(p) > 1) print_char(TEX_STRING("|"));
				font_in_short_display = font(lig_char(p)); short_display(lig_ptr(p));
				if (myodd(subtype(p))) print_char(TEX_STRING("|"));
				print_char(TEX_STRING(")"));
				#pragma endregion
				break;
			case penalty_node:
				#pragma region <Display penalty p 194>
				print_esc(TEX_STRING("penalty ")); print_int(penalty(p));
				#pragma endregion
				break;
			case disc_node:
				#pragma region <Display discretionary p 195>
				print_esc(TEX_STRING("discretionary"));
				if (replace_count(p) > 0) {
					print(TEX_STRING(" replacing ")); print_int(replace_count(p));
				}
				node_list_display(pre_break(p));
				append_char(TEX_STRING("|")); show_node_list(post_break(p)); flush_char;
				#pragma endregion
				break;
			case mark_node:
				#pragma region <Display mark p 196>
				print_esc(TEX_STRING("mark")); print_mark(mark_ptr(p));
				#pragma endregion
				break;
			case adjust_node:
				#pragma region <Display adjustment p 197>
				print_esc(TEX_STRING("vadjust")); node_list_display(adjust_ptr(p));
				#pragma endregion
				break;

			#pragma region <Cases of show_node_list that arise in mlists only 690>
			case style_node: print_style(subtype(p)); break;
			case choice_node:
				#pragma region <Display choice node p 695>
				print_esc(TEX_STRING("mathchoice")); append_char(TEX_STRING("D")); show_node_list(display_mlist(p)); flush_char;
				append_char(TEX_STRING("T")); show_node_list(text_mlist(p)); flush_char; append_char(TEX_STRING("S"));
				show_node_list(script_mlist(p)); flush_char; append_char(TEX_STRING("s")); show_node_list(script_script_mlist(p));
				flush_char;
				#pragma endregion
				break;

			case ord_noad:
			case op_noad:
			case bin_noad:
			case rel_noad:
			case open_noad:
			case close_noad:
			case punct_noad:
			case inner_noad:
			case radical_noad:
			case over_noad:
			case under_noad:
			case vcenter_noad:
			case accent_noad:
			case left_noad:
			case right_noad:
				#pragma region <Display normal noad p 696>
				switch (type(p)) {
				case ord_noad: print_esc(TEX_STRING("mathord")); break;
				case op_noad: print_esc(TEX_STRING("mathop")); break;
				case bin_noad: print_esc(TEX_STRING("mathbin")); break;
				case rel_noad: print_esc(TEX_STRING("mathrel")); break;
				case open_noad: print_esc(TEX_STRING("mathopen")); break;
				case close_noad: print_esc(TEX_STRING("mathclose")); break;
				case punct_noad: print_esc(TEX_STRING("mathpunct")); break;
				case inner_noad: print_esc(TEX_STRING("mathinner")); break;
				case over_noad: print_esc(TEX_STRING("overline")); break;
				case under_noad: print_esc(TEX_STRING("underline")); break;
				case vcenter_noad: print_esc(TEX_STRING("vcenter")); break;
				case radical_noad: print_esc(TEX_STRING("radical")); print_delimiter(left_delimiter(p)); break;
				case accent_noad: print_esc(TEX_STRING("accent")); print_fam_and_char(accent_chr(p)); break;
				case left_noad: print_esc(TEX_STRING("left")); print_delimiter(delimiter(p)); break;
				case right_noad: print_esc(TEX_STRING("right")); print_delimiter(delimiter(p)); break;
				}
				if (subtype(p) != normal)
					if (subtype(p) == limits) print_esc(TEX_STRING("limits"));
					else print_esc(TEX_STRING("nolimits"));
				if (type(p) < left_noad) print_subsidiary_data(nucleus(p), TEX_STRING("."));
				print_subsidiary_data(supscr(p), TEX_STRING("^")); print_subsidiary_data(subscr(p), TEX_STRING("_"));

				#pragma endregion
				break;

			case fraction_noad:
				#pragma region <Display fraction noad p 697>
				print_esc(TEX_STRING("fraction, thickness "));
				if (thickness(p) == default_code) print(TEX_STRING("= default"));
				else print_scaled(thickness(p));
				if (small_fam(left_delimiter(p)) != 0 || small_char(left_delimiter(p)) != min_quarterword ||
					large_fam(left_delimiter(p)) != 0 || large_char(left_delimiter(p)) != min_quarterword) {
					print(TEX_STRING(", left-delimiter ")); print_delimiter(left_delimiter(p));
				}
				if (small_fam(right_delimiter(p)) != 0 || small_char(right_delimiter(p)) != min_quarterword ||
					large_fam(right_delimiter(p)) != 0 || large_char(right_delimiter(p)) != min_quarterword) {
					print(TEX_STRING(", right-delimiter ")); print_delimiter(right_delimiter(p));
				}
				print_subsidiary_data(numerator(p), TEX_STRING("\")); print_subsidiary_data(denominator(p), TEX_STRING("/"));
				#pragma endregion
				break;

			#pragma endregion

			default:
				print(TEX_STRING("Unknown node type!"));
				break;

			}
		#pragma endregion

		p = link(p);
	}
}

//198
void show_box(pointer p)
{
	#pragma region <Assign the values depth_threshold = show_box_depth and breadth_max = show_box_breadth 236>
	depth_threshold = show_box_depth; breadth_max = show_box_breadth;
	#pragma endregion
	if (breadth_max <= 0)
		breadth_max = 5;
	if (pool_ptr + depth_threshold >= pool_size)
		depth_threshold = pool_size - pool_ptr - 1;
	show_node_list(p);
	print_ln();
}

// 174
void short_display(int p)
{
	int n;
	while (p > mem_min) {
		if (is_char_node(p)) {
			if (p <= mem_end) {
				if (font(p) != font_in_short_display) {
					if (font(p) < font_base || font(p) > font_max) print_char(TEX_STRING("*"));
					else 
						#pragma region <Print the font identifier for font(p) 267>
					{
						print_esc(font_id_text(font(p)));

					}
						#pragma endregion
					print_char(TEX_STRING(" ")); font_in_short_display = font(p);
				}
				print_ASCII(qo(character(p)));
			}
		}
		else
			#pragma region	<Print a short indication of the contents of node p 175>
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case ins_node:
			case whatsit_node:
			case mark_node:
			case adjust_node:
			case unset_node:
				print(TEX_STRING("[]"));
				break;
			case rule_node: print_char(TEX_STRING("|")); break;
			case glue_node: if (glue_ptr(p) != zero_glue) print_char(TEX_STRING(" ")); break;
			case math_node: print_char(TEX_STRING("$")); break;
			case ligature_node: short_display(lig_ptr(p)); break;
			case disc_node:
				short_display(pre_break(p)); short_display(post_break(p));
				n = replace_count(p);
				while (n > 0) {
					if (link(p) != null) p = link(p);
					decr(n);
				}
				break;

			default:
				//do_nothing
				break;
			}
			#pragma endregion
		p = link(p);
	}
}


// 311
void show_context()
{
	unsigned int old_setting;
	int nn;
	bool bottom_line;
	#pragma region <Local variables for formatting calculations 315>
	int i;
	int j;
	int l;
	int m;
	int n;
	int p;
	int q;
	#pragma endregion

	base_ptr = input_ptr; input_stack[base_ptr] = cur_input;
	nn = -1; bottom_line = false;
	while (1) {
		cur_input = input_stack[base_ptr];
		if (state != token_list)
			if (name > 17 || base_ptr == 0)
				bottom_line = true;
		if (base_ptr == input_ptr || bottom_line || nn < error_context_lines)
			#pragma region <Display the current context 312>
		{
			if (base_ptr == input_ptr || state != token_list || token_type != backed_up || loc != null) {
				tally = 0;
				old_setting = selector;
				if (state != token_list) {
					#pragma region <Print location of current line 313>
					if (name <= 17)
						if (terminal_input)
							if (base_ptr == 0)
								print_nl(TEX_STRING("<*>"));
							else
								print_nl(TEX_STRING("<insert> "));
						else {
							print_nl(TEX_STRING("<read "));
							if (name == 17) print_char(TEX_STRING("*"));
							else print_int(name - 1);
							print_char(TEX_STRING(">"));
						}
					else {
						print_nl(TEX_STRING("l.")); print_int(line);
					}
					print_char(TEX_STRING(" "));
					#pragma endregion

					#pragma region <Pseudoprint the line 318>
					begin_pseudoprint;
					if (buffer[limit] == end_line_char)
						j = limit;
					else
						j = limit + 1;
					if(j>0)
						for (i = start; i <= j - 1; i++) {
							if (i == loc)
								set_trick_count;
							print(buffer[i]);
						}
					#pragma endregion
				}
				else {
					#pragma region <Print type of token list 314>
					switch (token_type) {
					case parameter:
						print_nl(TEX_STRING("<argument> "));
						break;
					case u_template:
					case v_template:
						print_nl(TEX_STRING("<template> "));
						break;
					case backed_up:
						if (loc == null) print_nl(TEX_STRING("<recently read> "));
						else print_nl(TEX_STRING("<to be read again> "));
						break;
					case inserted:
						print_nl(TEX_STRING("<inserted text> "));
						break;
					case macro:
						print_ln();
						print_cs(name);
						break;
					case output_text:
						print_nl(TEX_STRING("<output> "));
						break;
					case every_par_text:
						print_nl(TEX_STRING("<everypar> "));
						break;
					case every_math_text:
						print_nl(TEX_STRING("<everymath> "));
						break;
					case every_display_text:
						print_nl(TEX_STRING("<everydisplay> "));
						break;
					case every_hbox_text:
						print_nl(TEX_STRING("<everyhbox> "));
						break;
					case every_vbox_text:
						print_nl(TEX_STRING("<everyvbox> "));
						break;
					case every_job_text:
						print_nl(TEX_STRING("<everyjob> "));
						break;
					case every_cr_text:
						print_nl(TEX_STRING("<everycr> "));
						break;
					case mark_text:
						print_nl(TEX_STRING("<mark> "));
						break;
					case write_text:
						print_nl(TEX_STRING("<write> "));
						break;
					default:
						print_nl(TEX_STRING("?"));
						break;
					}
					#pragma endregion
					#pragma region <Pseudoprint the token list 319>
					begin_pseudoprint;
					if (token_type < macro) show_token_list(start, loc, 100000);
					else show_token_list(link(start), loc, 100000);
					#pragma endregion
				}
				selector = old_setting;
				#pragma region <Print two lines using the tricky pseudoprinted information 317>
				if (trick_count == 1000000)
					set_trick_count;
				if (tally < trick_count)
					m = tally - first_count;
				else m = trick_count - first_count;
				if (l + first_count <= half_error_line) {
					p = 0; n = l + first_count;
				}
				else {
					print(TEX_STRING("...")); p = l + first_count - half_error_line + 3; n = half_error_line;
				}
				for (q = p; q <= first_count - 1; q++) print_char(trick_buf[q % error_line]);
				print_ln();
				for (q = 1; q <= n; q++) print_char(TEX_STRING(" "));
				if (m + n <= error_line)
					p = first_count + m;
				else
					p = first_count + (error_line - n - 3);
				for (q = first_count; q <= p - 1; q++) print_char(trick_buf[q % error_line]);
				if (m + n > error_line) print(TEX_STRING("..."));
				#pragma endregion
				incr(nn);

			}
		}
			#pragma endregion
		else if (nn == error_context_lines) {
			print_nl(TEX_STRING("...")); incr(nn);
		}
		if (bottom_line)
			goto done;
		decr(base_ptr);
	}
done:
	cur_input = input_stack[input_ptr];
}

// 433
void scan_eight_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 255) {
		print_err(TEX_STRING("Bad register code"));
		help2(TEX_STRING("A register number must be between 0 and 255."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

// 435
void scan_four_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 15) {
		print_err(TEX_STRING("Bad number"));
		help2(TEX_STRING("Since I expected to read a number between 0 and 15,"),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

// 436
void scan_fifteen_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 077777) {
		print_err(TEX_STRING("Bad mathchar"));
		help2(TEX_STRING("A mathchar number must be between 0 and 32767."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

//31
bool input_ln(FILE *fp, bool bypass_eoln)
{
	int last_nonblank;

	last = first;

	last_nonblank = first;
	int c;
	c = fgetc(fp);
	if (c == EOF)
		return false;
	else
		ungetc(c, fp);
	while ((c = fgetc(fp)) != '\n' && c != EOF) {
		if (last >= max_buf_stack) {
			max_buf_stack = last + 1;
			if (max_buf_stack == buf_size) 
				#pragma region <Report overflow of the input buffer, and abort 35>
			{
				if (format_ident == 0) {
					puts("Buffer size exceeded!");
					do_final_end();
				}
				else {
					cur_input.loc_field = first;
					cur_input.limit_field = last - 1;
					overflow(TEX_STRING("buffer size"), buf_size);
				}
			}
				#pragma endregion
		}
		buffer[last] = xord[c]; incr(last);		
		if (buffer[last - 1] != TEX_STRING(" "))
			last_nonblank = last;
	}
	last = last_nonblank;
	return true;
}



// 275
void eq_destroy(memory_word w)
{
	pointer q;
	switch (eq_type_field(w))
	{
	case call:
	case long_call:
	case outer_call:
	case long_outer_call:
		delete_token_ref(equiv_field(w));
		break;
	case glue_ref:
		delete_glue_ref(equiv_field(w));
		break;
	case shape_ref:
		q = equiv_field(w);
		if (q != null)
			free_node(q, info(q) + info(q) + 1);
		break;
	case box_ref:
		flush_node_list(equiv_field(w));
		break;
	default:
		break;
	}
}

// 276
void eq_save(pointer p, quarterword l)
{
	check_full_save_stack;
	if (l == level_zero)
		save_type(save_ptr) = restore_zero;
	else {
		save_stack[save_ptr] = eqtb[p]; incr(save_ptr); save_type(save_ptr) = restore_old_value;
	}
	save_level(save_ptr) = l; save_index(save_ptr) = p; incr(save_ptr);
}

// 277
void eq_define(pointer p, quarterword t, halfword e)
{
	if (eq_level(p) == cur_level)
		eq_destroy(eqtb[p]);
	else if (cur_level > level_one)
		eq_save(p, eq_level(p));
	eq_level(p) = cur_level; eq_type(p) = t; equiv(p) = e;
}

// 278
void eq_word_define(pointer p, int w)
{
	if (xeq_level[p] != cur_level) {
		eq_save(p, xeq_level[p]);
		xeq_level[p] = cur_level;
	}
	eqtb[p].union_t.an_int = w;
}

// 279
void geq_define(pointer p, quarterword t, halfword e)
{
	eq_destroy(eqtb[p]); eq_level(p) = level_one; eq_type(p) = t; equiv(p) = e;
}

void geq_word_define(pointer p, int w)
{
	eqtb[p].union_t.an_int = w;
	xeq_level[p] = level_one;
}

// 211
void print_mode(int m)
{
	if (m > 0)
		switch (m / (max_command + 1)) {
		case 0:print(TEX_STRING("vertical")); break;
		case 1:print(TEX_STRING("horizontal")); break;
		case 2:print(TEX_STRING("display math")); break;
		}
	else if (m == 0)
		print(TEX_STRING("no"));
	else
		switch ((-m) / (max_command + 1)) {
		case 0:print(TEX_STRING("internal vertical")); break;
		case 1:print(TEX_STRING("restricted horizontal")); break;
		case 2:print(TEX_STRING("math")); break;
		}
	print(TEX_STRING(" mode"));
}

// 299
void show_cur_cmd_chr()
{
	begin_diagnostic();
	print_nl(TEX_STRING("{"));
	if (mode != shown_mode) {
		print_mode(mode); print(TEX_STRING(": ")); shown_mode = mode;
	}
	print_cmd_chr(cur_cmd, cur_chr); print_char(TEX_STRING("}"));
	end_diagnostic(false);
}


// 37
bool init_terminal()
{
	while (1) {
		fputs("**", term_out);
		if (!input_ln(term_in, true)) {
			fputc('\n', term_out);
			fputs("! End of file on terminal... why?", term_out);
			return false;
		}
		loc = first;
		while (loc < last && buffer[loc] == ' ')
			incr(loc);
		if (loc < last)
			return true;
		fputs("Please type the name of your input file.\n", term_out);
	}
}

// 363
void firm_up_the_line()
{
	int k;

	limit = last;
	if(pausing > 0)
		if (interaction > nonstop_mode) {
			wake_up_terminal(); print_ln();
			if (start < limit)
				for (k = start; k <= limit - 1; k++) print(buffer[k]);
			first = limit; prompt_input(TEX_STRING("=>"));
			if (last > first) {
				for (k = first; k <= last - 1; k++)
					buffer[k + start - first] = buffer[k];
				limit = start + last - first;
			}
		}
}

// 523
void pack_buffered_name(small_number n, int a, int b)
{
	int k;
	ASCII_code c;
	int j;

	if (n + b - a + 1 + format_ext_length > file_name_size)
		b = a + file_name_size - n - 1 - format_ext_length;
	k = 0;
	for (j = 1; j <= n; j++) append_to_name(xord[TEX_format_default[j]]);
	for (j = a; j <= b; j++) append_to_name(buffer[j]);
	for (j = format_default_length - format_ext_length + 1; j <= format_default_length; j++)
		append_to_name(xord[TEX_format_default[j]]);
	if (k <= file_name_size) name_length = k;
	else name_length = file_name_size;

	// skip fill with spaces, don't think it's needed
	//for (k = name_length + 1; k <= file_name_size; k++) name_of_file[k] = ' ';

	// addition for C, add zero terminator
	name_of_file[name_length+1] = 0;
}

// 524
bool open_fmt_file()
{
	unsigned int j;

	j = loc;
	if (buffer[loc] == TEX_STRING("&")) {
		incr(loc); j = loc; buffer[last] = TEX_STRING(" ");
		while (buffer[j] != TEX_STRING(" ")) incr(j);
		pack_buffered_name(0, loc, j - 1);
		if (w_open_in(&fmt_file)) goto found;
		pack_buffered_name(format_area_length, loc, j - 1);
		if (w_open_in(&fmt_file)) goto found;
		wake_up_terminal(); wterm_ln_s("Sorry, I can't find that format; will try PLAIN.");
		update_terminal();
	}
	pack_buffered_name(format_default_length - format_ext_length, 1, 0);
	if (!w_open_in(&fmt_file)) {
		wake_up_terminal();
		wterm_ln_s("I can't find the PLAIN format file!");
		return false;
	}
found:
	loc = j;
	return true;
}

// 408
void mu_error()
{
	print_err(TEX_STRING("Incompatible glue units"));
	help1(TEX_STRING("I'm going to assume that 1mu=1pt when they're mixed."));
	error();
}


// 463
pointer scan_rule_spec()
{
	pointer q;

	q = new_rule();
	if (cur_cmd == vrule)
		width(q) = default_rule;
	else {
		height(q) = default_rule;
		depth(q) = 0;
	}
reswitch:
	if (scan_keyword(TEX_STRING("width"))) {
		scan_normal_dimen;
		width(q) = cur_val;
		goto reswitch;
	}
	if (scan_keyword(TEX_STRING("height"))) {
		scan_normal_dimen;
		height(q) = cur_val;
		goto reswitch;
	}
	if (scan_keyword(TEX_STRING("depth"))) {
		scan_normal_dimen;
		depth(q) = cur_val;
		goto reswitch;
	}
	return q;
}

// 578
void find_font_dimen(bool writing)
{
	internal_font_number f;
	int n;
	scan_int();
	n = cur_val;
	scan_font_ident();
	f = cur_val;
	if (n <= 0)
		cur_val = fmem_ptr;
	else {
		if (writing && (n <= space_shrink_code) && n >= space_code && font_glue[f] != null) {
			delete_glue_ref(font_glue[f]); font_glue[f] = null;
		}
		if (n > font_params[f])
			if (f < font_ptr)
				cur_val = fmem_ptr;
			else
				#pragma region <Increase the number of parameters in the last font 580>
			{
				do {
					if (fmem_ptr == font_mem_size)
						overflow(TEX_STRING("font memory"), font_mem_size);
					font_info[fmem_ptr].sc = 0; incr(fmem_ptr); incr(font_params[f]);
				} while (!(n == font_params[f]));
				cur_val = fmem_ptr - 1;
			}
				#pragma endregion
		else
			cur_val = n + param_base[f];
	}
	#pragma region <Issue an error message if cur_val = fmem_ptr 579>
	if (cur_val == fmem_ptr) {
		print_err(TEX_STRING("Font "));
		print_esc(font_id_text(f));
		print(TEX_STRING(" has only "));
		print_int(font_params[f]); print(TEX_STRING(" fontdimen parameters"));
		help2(TEX_STRING("To increase the number of font parameters, you must"),
			TEX_STRING("use \fontdimen immediately after the \font is loaded."));
		error();
	}
	#pragma endregion
}


// 413
void scan_something_internal(small_number level, bool negative)
{
	halfword m;
	unsigned int p;

	m = cur_chr;
	switch (cur_cmd) {
	case def_code:
		#pragma region <Fetch a character code from some table 414>
		scan_char_num();
		if (m == math_code_base) scanned_result(ho(math_code(cur_val)), int_val);
		else if (m < math_code_base) scanned_result(equiv(m + cur_val), int_val);
		else scanned_result(eqtb[m + cur_val].union_t.an_int, int_val);
		#pragma endregion
		break;
	case toks_register:
	case assign_toks:
	case def_family:
	case set_font:
	case def_font:
		#pragma region <Fetch token list or font identiifer provided that level == tok_val 415>
		if (level != tok_val) {
			print_err(TEX_STRING("Missing number, treated as zero"));
			help3(TEX_STRING("A number should have been here; I inserted `0'."),
				TEX_STRING("(If you can't figure out why I needed to see a number,"),
				TEX_STRING("look up `weird error' in the index to The TeXbook.)"));
			back_error();
			scanned_result(0, dimen_val);
		}
		else if (cur_cmd <= assign_toks) {
			if (cur_cmd < assign_toks) {
				scan_eight_bit_int(); m = toks_base + cur_val;
			}
			scanned_result(equiv(m), tok_val);
		}
		else {
			back_input(); scan_font_ident(); scanned_result(font_id_base + cur_val, ident_val);
		}
		#pragma endregion
		break;
	case assign_int:
		scanned_result(eqtb[m].union_t.an_int, int_val);
		break;
	case assign_dimen:
		scanned_result(eqtb[m].sc, dimen_val);
		break;
	case assign_glue:
		scanned_result(equiv(m), glue_val);
		break;
	case assign_mu_glue:
		scanned_result(equiv(m), mu_val);
		break;
	case set_aux:
		#pragma region <Fetch the space factor or the prev_depth 418>
		if (abs(mode) != m) {
			print_err(TEX_STRING("Improper "));
			print_cmd_chr(set_aux, m);
			help4(TEX_STRING("You can refer to \spacefactor only in horizontal mode;"),
				TEX_STRING("you can refer to \prevdepth only in vertical mode; and"),
				TEX_STRING("neither of these is meaningful inside \write. So"),
				TEX_STRING("I'm forgetting what you said and using zero instead."));
			error();
			if (level != tok_val)
				scanned_result(0, dimen_val);
			else
				scanned_result(0, int_val);
		}
		else if (m == vmode)
			scanned_result(prev_depth, dimen_val);
		else
			scanned_result(space_factor, int_val);
		#pragma endregion
		break;
	case set_prev_graf:
		#pragma region <Fetch the prev_graf 422>
		if (mode == 0)
			scanned_result(0, int_val);
		else {
			nest[nest_ptr] = cur_list; p = nest_ptr;
			while (abs(nest[p].mode_field) != vmode)
				decr(p);
			scanned_result(nest[p].pg_field, int_val);
		}
		#pragma endregion
		break;
	case set_page_int:
		#pragma region <Fetch the dead_cycles or the insert_penalties 419>
		if (m == 0)
			cur_val = dead_cycles;
		else
			cur_val = insert_penalties;
		cur_val_level = int_val;
		#pragma endregion
		break;
	case set_page_dimen:
		#pragma region <Fetch something on the page_so_far 421>
		if (page_contents == empty && !output_active) {
			if (m == 0)
				cur_val = max_dimen;
			else
				cur_val = 0;
		}
		else
			cur_val = page_so_far[m];
		cur_val_level = dimen_val;
		#pragma endregion
		break;
	case set_shape:
		#pragma region <Fetch the par shape size 423>
		if (par_shape_ptr == null)
			cur_val = 0;
		else
			cur_val = info(par_shape_ptr);
		cur_val_level = int_val;
		#pragma endregion
		break;
	case set_box_dimen:
		#pragma region <Fetch a box dimension 420>
		scan_eight_bit_int();
		if (box(cur_val) == null)
			cur_val = 0;
		else
			cur_val = mem[box(cur_val) + m].sc;
		cur_val_level = dimen_val;
		#pragma endregion
		break;
	case char_given:
	case math_given:
		scanned_result(cur_chr, int_val);
		break;
	case assign_font_dimen:
		#pragma region <Fetch a font dimension 425>
		find_font_dimen(false); font_info[fmem_ptr].sc = 0;
		scanned_result(font_info[cur_val].sc, dimen_val);
		#pragma endregion
		break;
	case assign_font_int:
		#pragma region <Fetch a font integer 426>
		scan_font_ident();
		if (m == 0)
			scanned_result(hyphen_char[cur_val], int_val);
		else
			scanned_result(skew_char[cur_val], int_val);
		#pragma endregion
		break;
	case _register:
		#pragma region <Fetch a register 427>
		scan_eight_bit_int();
		switch (m) {
		case int_val:
			cur_val = count(cur_val);
			break;
		case dimen_val:
			cur_val = dimen(cur_val);
			break;
		case glue_val:
			cur_val = skip(cur_val);
			break;
		case mu_val:
			cur_val = mu_skip(cur_val);
			break;
		}
		cur_val_level = m;
		#pragma endregion
		break;
	case last_item:
		#pragma region <Fetch an item in the current node if appropriate 424>
		if (cur_chr > glue_val) {
			if (cur_chr == input_line_no_code)
				cur_val = line;
			else
				cur_val = last_badness;
			cur_val_level = int_val;
		}
		else {
			if (cur_chr == glue_val)
				cur_val = zero_glue;
			else
				cur_val = 0;
			cur_val_level = cur_chr;

			if (!is_char_node(tail) && (mode != 0))
				switch (cur_chr) {
				case int_val:
					if (type(tail) == penalty_node)
						cur_val = penalty(tail);
					break;
				case dimen_val:
					if (type(tail) == kern_node)
						cur_val = width(tail);
					break;
				case glue_val:
					if (type(tail) == glue_node) {
						cur_val = glue_ptr(tail);
						if (subtype(tail) == mu_glue)
							cur_val_level = mu_val;
					}
					break;
				}

			else if (mode == vmode && tail == head)
				switch (cur_chr) {
				case int_val:
					cur_val = last_penalty;
					break;
				case dimen_val:
					cur_val = last_kern;
					break;
				case glue_val:
					if (last_glue != max_halfword)
						cur_val = last_glue;
					break;
				}
		}
		#pragma endregion
		break;
	default:
		#pragma region <Complain that the cant do this; give zero result 428>
	{
		print_err(TEX_STRING("You can't use `"));
		print_cmd_chr(cur_cmd, cur_chr);
		print(TEX_STRING("' after "));
		print_esc(TEX_STRING("the"));
		help1(TEX_STRING("I'm forgetting what you said and using zero instead."));
		error();
		if (level != tok_val)
			scanned_result(0, dimen_val);
		else
			scanned_result(0, int_val);
	}
		#pragma endregion
		break;
	}
	while (cur_val_level > level) 
		#pragma region <Convert cur_val to a lower level 429>
	{
		if (cur_val_level == glue_val)
			cur_val = width(cur_val);
		else if (cur_val_level == mu_val)
			mu_error();
		decr(cur_val_level);
	}
		#pragma endregion

	#pragma region <Fix the reference count if any and negate cur_val if negative 430>
	if (negative) {
		if (cur_val_level >= glue_val) {
			cur_val = new_spec(cur_val);
			#pragma region<Negate all three glue components of cur_val 431>
			negate(width(cur_val));
			negate(stretch(cur_val));
			negate(shrink(cur_val));
			#pragma endregion
		}
		else {
			negate(cur_val);
		}
	}
	else if (cur_val_level >= glue_val && cur_val_level <= mu_val)
		add_glue_ref(cur_val);
	#pragma endregion
}

// 529
void pack_job_name(str_number s)
{
	cur_area = TEX_STRING("");
	cur_ext = s;
	cur_name = job_name;
	pack_cur_name;
}

// 515
void begin_name()
{
	area_delimiter = 0;
	ext_delimiter = 0;
}

// 516
bool more_name(ASCII_code c)
{
	if (c == TEX_STRING(" ")) return false;
	else {
		str_room(1); append_char(c);
		if (c == TEX_STRING(">") ||
			c == TEX_STRING(":")) {
			area_delimiter = cur_length;
			ext_delimiter = 0;
		}
		else if (c == TEX_STRING(".") && ext_delimiter == 0)
			ext_delimiter = cur_length;
		return true;

	}
}

// 517
void end_name()
{
	if (str_ptr + 3 > max_strings) overflow(TEX_STRING("number of strings"), max_strings - init_str_ptr);
	if (area_delimiter == 0)
		cur_area = TEX_STRING("");
	else {
		cur_area = str_ptr; str_start[str_ptr + 1] = str_start[str_ptr] + area_delimiter; incr(str_ptr);
	}
	if (ext_delimiter == 0) {
		cur_ext = TEX_STRING(""); cur_name = make_string();
	}
	else {
		cur_name = str_ptr;
		str_start[str_ptr + 1] = str_start[str_ptr] + ext_delimiter - area_delimiter - 1; incr(str_ptr);
		cur_ext = make_string();
	}
}

// 518
void print_file_name(int n, int a, int e)
{
	slow_print(a);
	slow_print(n);
	slow_print(e);
}

// 519
void pack_file_name(str_number n, str_number a, str_number e)
{
	int k;
	ASCII_code c;
	pool_pointer j;

	k = 0;
	for (j = str_start[a]; j <= str_start[a + 1] - 1; j++)
		append_to_name(so(str_pool[j]));
	for (j = str_start[n]; j <= str_start[n + 1] - 1; j++)
		append_to_name(so(str_pool[j]));
	for (j = str_start[e]; j <= str_start[e + 1] - 1; j++)
		append_to_name(so(str_pool[j]));
	if (k <= file_name_size) name_length = k; else name_length = file_name_size;

	// skip fill with zeros, don't think it's needed
	//for (k = name_length + 1; k <= file_name_size; k++) name_of_file[k] = ' ';

	// addition for C, add zero terminator
	name_of_file[name_length+1] = 0;

}

// 530
void prompt_file_name(str_number s, str_number e)
{
	int k;
	if (interaction == scroll_mode)
		wake_up_terminal();

	if (s == TEX_STRING("input file name"))
		print_err(TEX_STRING("I can't find file `"));
	else print_err(TEX_STRING("I can't write on file `"));
	print_file_name(cur_name, cur_area, cur_ext); print(TEX_STRING("'."));
	if (e = TEX_STRING(".tex")) show_context();
	print_nl(TEX_STRING("Please type another ")); print(s);
	if (interaction < scroll_mode)
		fatal_error(TEX_STRING("*** (job aborted, file error in nonstop mode)"));
	clear_terminal();
	prompt_input(TEX_STRING(": "));
	#pragma region <Scan file name in the buffer 531>
	{
		begin_name();
		k = first;
		while (buffer[k] == TEX_STRING(" ") && k < last) incr(k);
		while (1) {
			if (k == last)
				goto done;
			if (!more_name(buffer[k])) goto done;
			incr(k);
		}
done:
		end_name();
	}
	#pragma endregion
	if (cur_ext == TEX_STRING("")) cur_ext = e;
	pack_cur_name;
}

// 607
void movement(scaled w, eight_bits o)
{
	small_number mstate;
	pointer p, q;
	int k;
	q = get_node(movement_node_size);
	width(q) = w;
	location(q) = dvi_offset + dvi_ptr;
	if (o == dvi_const::down1) {
		link(q) = down_ptr; down_ptr = q;
	}
	else {
		link(q) = right_ptr; right_ptr = q;
	}

	#pragma region <Look at the other stack entries until decidign what sort of DVI.. 611>
	p = link(q); mstate = none_seen;
	while (p != null) {
		if (width(p) == w)
			#pragma region <Consider a node with matching width.. 612>
			switch(mstate+info(p)){
			case none_seen+yz_OK:
			case none_seen+y_OK:
			case z_seen+yz_OK:
			case z_seen+y_OK:
				if (location(p) < dvi_gone) goto not_found;
				else
					#pragma region <Change buffered instruction to y or w and goto found 613>
				{
					k = location(p) - dvi_offset;
					if (k < 0) k += dvi_buf_size;
					dvi_buf[k] += dvi_const::y1 - dvi_const::down1;
					info(p) = y_here; goto found;
				}
					#pragma endregion
				break;
			case none_seen+z_OK:
			case y_seen+yz_OK:
			case y_seen+z_OK:
				if (location(p) < dvi_gone) goto not_found;
				else
				#pragma region <Change buffered instruction to z or x and goto found 614>
				{
					k = location(p) - dvi_offset;
					if (k < 0) k += dvi_buf_size;
					dvi_buf[k] += dvi_const::z1 - dvi_const::down1;
					info(p) = z_here; goto found;
				}
				#pragma endregion
				break;
			case none_seen+y_here:
			case none_seen+z_here:
			case y_seen+z_here:
			case z_seen+y_here:
				goto found;
				break;
			default:
				//do_nothing
				break;
			}
		#pragma endregion
		else switch (mstate + info(p)) {
		case none_seen + y_here: mstate = y_seen; break;
		case none_seen + z_here: mstate = z_seen; break;
		case y_seen+z_here:
		case z_seen+y_here:
			goto not_found;
			break;
		default:
			//do_nothing
			break;
		}
		p = link(p);

	}
	not_found:
	#pragma endregion

	#pragma region <Generate a down or right command for w and return 610>
	info(q) = yz_OK;
	if (abs(w) >= 040000000) {
		dvi_out(o + 3);
		dvi_four(w); goto _exit;
	}
	if (abs(w) >= 0100000) {
		dvi_out(o + 2);
		if (w < 0) w += 0100000000;
		dvi_out(w / 0200000); w = w % 0200000; goto my2;
	}
	if (abs(w) >= 0200) {
		dvi_out(o + 1);
		if (w < 0) w += 0200000;
		goto my2;
	}
	dvi_out(o);
	if (w < 0) w += 0400;
	goto my1;
my2:
	dvi_out(w / 0400);
my1:
	dvi_out(w % 0400);
	goto _exit;
	#pragma endregion
found:
	#pragma region <Generate a y0 or z0 command in order to reuse a previosu appearance of w 609>
	 info(q) = info(p);
	 if (info(q) == y_here) {
		 dvi_out(o + dvi_const::y0 - dvi_const::down1);
		 while (link(q) != p) {
			 q = link(q);
			 switch (info(q)) {
			 case yz_OK: info(q) = z_OK; break;
			 case y_OK: info(q) = d_fixed; break;
			 default:
				 //do_nothing
				 break;
			 }
		 }
	 }
	 else {
		 dvi_out(o + dvi_const::z0 - dvi_const::down1);
		 while (link(q) != p) {
			 q = link(q);
			 switch (info(q)) {
			 case yz_OK: info(q) = y_OK;
			 case z_OK: info(q) = d_fixed;
			 default:
				 //do_nothing
				 break;
			 }
		 }
	 }
	#pragma endregion

_exit:
	;
}

// 686
pointer new_noad()
{
	pointer p;
	p = get_node(noad_size); type(p) = ord_noad; subtype(p) = normal;
	mem[nucleus(p)].union_t.hh = empty_field; mem[subscr(p)].union_t.hh = empty_field;
	mem[supscr(p)].union_t.hh = empty_field;
	return p;
}


/// 691
void print_fam_and_char(pointer p)
{
	print_esc(TEX_STRING("fam")); print_int(fam(p)); print_char(TEX_STRING(" ")); print_ASCII(qo(character(p)));
}

void print_delimiter(pointer p)
{
	int a;
	a = small_fam(p) * 256 + qo(small_char(p));
	a = a * 0x1000 + large_fam(p) * 256 + qo(large_char(p));
	if (a < 0) print_int(a);
	else print_hex(a);
}

// 692
void print_subsidiary_data(pointer p, ASCII_code c)
{
	if (cur_length >= depth_threshold) {
		if (math_type(p) != empty) print(TEX_STRING(" []"));
	}
	else {
		append_char(c);
		temp_ptr = p;
		switch (math_type(p)) {
		case math_char:
			print_ln(); print_current_string(); print_fam_and_char(p);
			break;
		case sub_box: show_info(); break;
		case sub_mlist:
			if (info(p) == null) {
				print_ln(); print_current_string(); print(TEX_STRING("{}"));
			}
			else show_info();
			break;
		default:
			//do_nothing
			break;
		}
		flush_char;
	}
}

//693
void show_info()
{
	show_node_list(info(temp_ptr));
}

// 704
pointer fraction_rule(scaled t)
{
	pointer p;
	p = new_rule(); height(p) = t; depth(p) = 0;
	return p;
}

// 705
pointer overbar(pointer b, scaled k, scaled t)
{
	pointer p, q;
	p = new_kern(k); link(p) = b; q = fraction_rule(t); link(q) = p; p = new_kern(t); link(p) = q;
	return vpack(p, 0, additional);
}


// 706
pointer var_delimiter(pointer d, small_number s, scaled v)
{
	pointer b;
	internal_font_number f, g;
	quarterword c, x, y;
	int m, n;
	scaled u;
	scaled w;
	four_quarters q;
	eight_bits hd;
	four_quarters r;
	small_number z;
	bool large_attempt;

	f = null_font; w = 0; large_attempt = false; z = small_fam(d); x = small_char(d);
	while (1) {
		#pragma region <Look at the variants of (z,x); set f and c whenever a better character is found; goto found.. 707>
		if (z != 0 || x != min_quarterword) {
			z += s + 16;
			do {
				z -= 16; g = fam_fnt(z);

				if (g != null_font)

					#pragma region <Look at the list of characters starting with x in font g; set f and c.. 708>
				{
					y = x;
					if (qo(y) >= font_bc[g] && qo(y) <= font_ec[g]) {
					mycontinue:
						q = char_info(g, y);
						if (char_exists(q)) {
							if (char_tag(q) == ext_tag) {
								f = g; c = y; goto found;
							}
							hd = height_depth(q); u = char_height(g, hd) + char_depth(g, hd);
							if (u > w) {
								f = g; c = y; w = u;
								if (u >= v) goto found;
							}
							if (char_tag(q) == list_tag) {
								y = rem_byte(q); goto mycontinue;
							}
						}
					}
				}
					#pragma endregion

			} while (!(z < 16));
		}
		#pragma endregion
		if (large_attempt) goto found;
		large_attempt = true; z = large_fam(d); x = large_char(d);

	}
found:
	if (f != null_font)
		#pragma region <Make variable b point to a box for (f,c) 710>
		if (char_tag(q) == ext_tag)

			#pragma region <Construct an extensible character in a new box b, using recipe rem_byte(q) and font f 713>
		{
			b = new_null_box(); type(b) = vlist_node; r = font_info[exten_base[f] + rem_byte(q)].union_t.qqqq;

			#pragma region <Compute the minimum suitable height, w, and the corresponding number of extension steps, n; .. 714>
			c = ext_rep(r); u = height_plus_depth(f, c); w = 0; q = char_info(f, c);
			width(b) = char_width(f, q) + char_italic(f, q);
			c = ext_bot(r); if (c != min_quarterword) w += height_plus_depth(f, c);
			c = ext_mid(r); if (c != min_quarterword) w += height_plus_depth(f, c);
			c = ext_top(r); if (c != min_quarterword) w += height_plus_depth(f, c);
			n = 0;
			if(u>0)
				while (w < v) {
					w += u; incr(n);
					if (ext_mid(r) != min_quarterword) w += u;
				}
			#pragma endregion
			c = ext_bot(r);
			if (c != min_quarterword) stack_into_box(b, f, c);
			c = ext_rep(r);
			for (m = 1; m <= n; m++) stack_into_box(b, f, c);
			c = ext_mid(r);
			if (c != min_quarterword) {
				stack_into_box(b, f, c); c = ext_rep(r);
				for (m = 1; m <= n; m++) stack_into_box(b, f, c);
			}
			c = ext_top(r);
			if (c != min_quarterword) stack_into_box(b, f, c);
			depth(b) = w - height(b);
		}
			#pragma endregion
		else b = char_box(f, c);

		#pragma endregion
	else {
		b = new_null_box(); width(b) = null_delimiter_space;
	}
	shift_amount(b) = half(height(b) - depth(b)) - axis_height(s); return b;
}



// 709
pointer char_box(internal_font_number f, quarterword c)
{
	four_quarters q;
	eight_bits hd;
	pointer b, p;

	q = char_info(f, c); hd = height_depth(q); b = new_null_box();
	width(b) = char_width(f, q) + char_italic(f, q); height(b) = char_height(f, hd);
	depth(b) = char_depth(f, hd); p = get_avail(); character(p) = c; font(p) = f; list_ptr(b) = p;
	return b;
}


// 711
void stack_into_box(pointer b, internal_font_number f, quarterword c)
{
	pointer p;
	p = char_box(f, c); link(p) = list_ptr(b); list_ptr(b) = p; height(b) = height(p);
}

//712
scaled height_plus_depth(internal_font_number f, quarterword c)
{
	four_quarters q;
	eight_bits hd;
	q = char_info(f, c); hd = height_depth(q);
	return char_height(f, hd) + char_depth(f, hd);
}


// 715
pointer rebox(pointer b, scaled w)
{
	pointer p;
	internal_font_number f;
	scaled v;

	if (width(b) != w && list_ptr(b) != null) {
		if (type(b) == vlist_node) b = hpack(b, 0, additional);
		p = list_ptr(b);
		if (is_char_node(p) && link(p) == null) {
			f = font(p); v = char_width(f, char_info(f, character(p)));
			if (v != width(b)) link(p) = new_kern(width(b) - v);
		}
		free_node(b, box_node_size); b = new_glue(ss_glue); link(b) = p;
		while (link(p) != null) p = link(p);
		link(p) = new_glue(ss_glue); return hpack(b, w, exactly);
	}
	else {
		width(b) = w; return b;
	}
}

// 716
pointer math_glue(pointer g, scaled m)
{
	pointer p;
	int n;
	scaled f;

	n = x_over_n(m, 0200000); f = _remainder;
	if (f < 0) {
		decr(n); f += 0200000;
	}
	p = get_node(glue_spec_size); width(p) = mu_mult(width(g));

	stretch_order(p) = stretch_order(g);
	if (stretch_order(p) == normal) stretch(p) = mu_mult(stretch(g));
	else stretch(p) = stretch(g);

	shrink_order(p) = shrink_order(g);
	if (shrink_order(p) == normal) shrink(p) = mu_mult(shrink(g));
	else shrink(p) = shrink(g);

	return p;
}

// 717
void math_kern(pointer p, scaled m)
{
	int n;
	scaled f;

	if (subtype(p) == mu_glue) {
		n = x_over_n(m, 0200000); f = _remainder;
		if (f < 0) {
			decr(n); f += 0200000;
		}
		width(p) = mu_mult(width(p)); subtype(p) = _explicit;
	}
}

// 718
void flush_math()
{
	flush_node_list(link(head)); flush_node_list(incompleat_noad); link(head) = null; tail = head;
	incompleat_noad = null;
}

// 720
pointer clean_box(pointer p, small_number s)
{
	pointer q;
	small_number save_style;
	pointer x;
	pointer r;

	switch (math_type(p)) {
	case math_char:
		cur_mlist = new_noad(); mem[nucleus(cur_mlist)] = mem[p];
		break;
	case sub_box:
		q = info(p); goto found;
		break;
	case sub_mlist:
		cur_mlist = info(p);
		break;
	default:
		q = new_null_box(); goto found;
		break;
	}
	save_style = cur_style; cur_style = s; mlist_penalties = false;
	mlist_to_hlist(); q = link(temp_head);
	cur_style = save_style;

	#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703>
	if (cur_style < script_style) cur_size = text_size;
	else cur_size = 16 * ((cur_style - text_style) / 2);
	cur_mu = x_over_n(math_quad(cur_size), 18);
	#pragma endregion
found:
	if (is_char_node(q) || q == null) x = hpack(q, 0, additional);
	else if (link(q) == null && type(q) <= vlist_node && shift_amount(q) == 0) x = q;
	else x = hpack(q, 0, additional);

	#pragma region <Simplify a trivial box 721>
		 q = list_ptr(x);
		 if (is_char_node(q)) {
			 r = link(q);
			 if(r!=null)
				 if(link(r) == null)
					 if(!is_char_node(r))
						 if (type(r) == kern_node) {
							 free_node(r, small_node_size); link(q) = null;
						 }
		 }
	#pragma endregion
	return x;
}


// 722
void fetch(pointer a)
{
	cur_c = character(a); cur_f = fam_fnt(fam(a) + cur_size);
	if (cur_f == null_font)

	#pragma region <Complain about an undefined family and set cur_i null 723>
	{
		print_err(TEX_STRING("")); print_size(cur_size); print_char(TEX_STRING(" ")); print_int(fam(a));
		print(TEX_STRING(" is undefined (character ")); print_ASCII(qo(cur_c)); print_char(TEX_STRING(")"));
		help4(TEX_STRING("Somewhere in the math formula just ended, you used the"),
			TEX_STRING("stated character from an undefined font family. For example,"),
			TEX_STRING("plain TeX doesn't allow \it or \sl in subscripts. Proceed,"),
			TEX_STRING("and I'll try to forget that I needed that character."));
		error();
		cur_i = null_character;
		math_type(a) = empty;
	}
	#pragma endregion
	else {
		if (qo(cur_c) >= font_bc[cur_f] && qo(cur_c) <= font_ec[cur_f])
			cur_i = char_info(cur_f, cur_c);
		else cur_i = null_character;
		if (!char_exists(cur_i)) {
			char_warning(cur_f, qo(cur_c)); math_type(a) = empty;
		}
	}
}


//726
void mlist_to_hlist()
{
	pointer mlist;
	bool penalties;
	small_number style;
	small_number save_style;
	pointer q;
	pointer r;
	small_number r_type;
	small_number t;
	pointer p, x, y, z;
	int pen;
	small_number s;
	scaled max_h, max_d;
	scaled delta;

	mlist = cur_mlist; penalties = mlist_penalties; style = cur_style;
	q = mlist; r = null; r_type = op_noad; max_h = 0; max_d = 0;
	#pragma region <Set up values of cur_size and cur_mu, based on cur_style 703>
	if (cur_style < script_style) cur_size = text_size;
	else cur_size = 16 * ((cur_style - text_style) / 2);
	cur_mu = x_over_n(math_quad(cur_size), 18);
	#pragma endregion
	while (q != null)
		#pragma region <Process node-or_noad q as much as possible in preparation for the second pass mlist_to_hlist.. 727>
	{
		#pragma region <Do first-pass processing based on type(q); goto done_with_noad if a noad has been .. 728>
	reswitch:
			delta = 0;
			switch (type(q)) {
			case bin_noad:
				switch (r_type) {
				case bin_noad:
				case op_noad:
				case rel_noad:
				case open_noad:
				case punct_noad:
				case left_noad:
					type(q) = ord_noad;
					goto reswitch;
					break;
				default:
					//do_nothing
					break;
				}
				break;

			case rel_noad:
			case close_noad:
			case punct_noad:
			case right_noad:
				#pragma region <Convert a final bin_noad to an ord_noad 729>
				if (r_type == bin_noad) type(r) = ord_noad;
				#pragma endregion
				if (type(q) == right_noad) goto done_with_noad;
				break;

			#pragma region <Cases for noads that can follow a bin_noad 733>
			case left_noad:
				goto done_with_noad;
				break;
			case fraction_noad:
				make_fraction(q); goto check_dimensions;
				break;
			case op_noad:
				delta = make_op(q);
				if (subtype(q) == limits) goto check_dimensions;
				break;
			case ord_noad: make_ord(q); break;
			case open_noad: case inner_noad: /*do_nothing*/ break;
			case radical_noad: make_radical(q); break;
			case over_noad: make_over(q); break;
			case under_noad: make_under(q); break;
			case accent_noad: make_math_accent(q); break;
			case vcenter_noad: make_vcenter(q); break;
			#pragma endregion

			#pragma region <Cases for nodes that can appear in an mlist, after which we goto done_with_node 730>
			case style_node:
				cur_style = subtype(q);
				#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703
				if (cur_style < script_style) cur_size = text_size;
				else cur_size = 16 * ((cur_style - text_style) / 2);
				cur_mu = x_over_n(math_quad(cur_size), 18);
				#pragma endregion
				goto done_with_node;
				break;
			case choice_node:
				#pragma region <Change this node to a style node followed by the correct choice, then goto done_with_node 731>
				switch (cur_style / 2) {
				case 0: choose_mlist(display_mlist); break;
				case 1: choose_mlist(text_mlist); break;
				case 2: choose_mlist(script_mlist); break;
				case 3: choose_mlist(script_script_mlist); break;
				}
				flush_node_list(display_mlist(q)); flush_node_list(text_mlist(q)); flush_node_list(script_mlist(q));
				flush_node_list(script_script_mlist(q));
				type(q) = style_node; subtype(q) = cur_style; width(q) = 0; depth(q) = 0;
				if (p != null) {
					z = link(q); link(q) = p;
					while (link(p) != null) p = link(p);
					link(p) = z;
				}
				goto done_with_node;
				#pragma endregion
				break;

			case ins_node:
			case mark_node:
			case adjust_node:
			case whatsit_node:
			case penalty_node:
			case disc_node:
				goto done_with_node;
				break;

			case rule_node:
				if (height(q) > max_h) max_h = height(q);
				if (depth(q) > max_d) max_d = depth(q);
				goto done_with_node;
				break;

			case glue_node:
				#pragma region <Convert math glue to ordinary glue 732>
				if (subtype(q) == mu_glue) {
					x = glue_ptr(q); y = math_glue(x, cur_mu); delete_glue_ref(x); glue_ptr(q) = y;
					subtype(q) = normal;
				}
				else if (cur_size != text_size && subtype(q) == cond_math_glue) {
					p = link(q);
					if(p!=null)
						if (type(p) == glue_node || type(p) == kern_node) {
							link(q) = link(p); link(p) = null; flush_node_list(p);
						}
				}
				#pragma endregion
				goto done_with_node;
				break;

			case kern_node:
				math_kern(q, cur_mu); goto done_with_node;
				break;
			#pragma endregion

			default: confusion(TEX_STRING("mlist1")); break;
			}
			#pragma region <Convert nucleus(q) to an hlist and attach the sub/superscripts 754>
			switch (math_type(nucleus(q))) {
			case math_char:
			case math_text_char:
				#pragma region <Create a character node p for nucleus(q), possibly followed by a kern node .. 755>
			{
				fetch(nucleus(q));
				if (char_exists(cur_i)) {
					delta = char_italic(cur_f, cur_i); p = new_character(cur_f, qo(cur_c));
					if (math_type(nucleus(q)) == math_text_char && space(cur_f) != 0) delta = 0;
					if (math_type(subscr(q)) == empty && delta != 0) {
						link(p) = new_kern(delta); delta = 0;
					}
				}
				else p = null;
			}
				#pragma endregion
				break;
			case empty:
				p = null;
				break;
			case sub_box:
				p = info(nucleus(q));
				break;
			case sub_mlist:
				cur_mlist = info(nucleus(q)); save_style = cur_style; mlist_penalties = false;
				mlist_to_hlist();
				cur_style = save_style;
				#pragma region <Set up the values of cur_size and cur_mu, base on cur_style 703>
				if (cur_style < script_style) cur_size = text_size;
				else cur_size = 16 * ((cur_style - text_style) / 2);
				cur_mu = x_over_n(math_quad(cur_size), 18);
				#pragma endregion
				p = hpack(link(temp_head), 0, additional);
				break;
			default:
				confusion(TEX_STRING("mlist2"));
				break;
			}
			new_hlist(q) = p;
			if (math_type(subscr(q)) == empty && math_type(supscr(q)) == empty) goto check_dimensions;
			make_scripts(q, delta);
			#pragma endregion

		#pragma endregion
	check_dimensions:
		z = hpack(new_hlist(q), 0, additional);
		if (height(z) > max_h) max_h = height(z);
		if (depth(z) > max_d) max_d = depth(z);
		free_node(z, box_node_size);
	done_with_noad:
		r = q; r_type = type(r);
	done_with_node:
		q = link(q);
	}
		#pragma endregion

	#pragma region <convert a final bin_noad to an ord_noad 729>
	if (r_type == bin_noad) type(r) = ord_noad;
	#pragma endregion

	#pragma region <Make a second pass over the mlist, removing all noads and inserting the proper spacing and penalties 760>
	p = temp_head; link(p) = null; q = mlist; r_type = 0; cur_style = style;
	#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703>
	if (cur_style < script_style) cur_size = text_size;
	else cur_size = 16 * ((cur_style - text_style) / 2);
	cur_mu = x_over_n(math_quad(cur_size), 18);
	#pragma endregion
	while (q != null) {
		#pragma region <If node q is a style node, change the style and goto delete_q; .. 761>
		t = ord_noad; s = noad_size; pen = inf_penalty;
		switch (type(q)) {
		case op_noad:
		case open_noad:
		case close_noad:
		case punct_noad:
		case inner_noad:
			t = type(q);
			break;
		case bin_noad:
			t = bin_noad;
			pen = bin_op_penalty;
			break;
		case rel_noad:
			t = rel_noad; pen = rel_penalty;
			break;
		case ord_noad:
		case vcenter_noad:
		case over_noad:
		case under_noad:
			//do_nothing
			break;
		case radical_noad:
			s = radical_noad_size;
			break;
		case accent_noad:
			s = accent_noad_size;
			break;
		case fraction_noad:
			t = inner_noad;
			s = fraction_noad_size;
			break;
		case left_noad:
		case right_noad:
			t = make_left_right(q, style, max_d, max_h);
			break;
		case style_node:
			#pragma region <Change the current style adn goto delete_q 763>
			cur_style = subtype(q); s = style_node_size;
			#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703>
			if (cur_style < script_style) cur_size = text_size;
			else cur_size = 16 * ((cur_style - text_style) / 2);
			cur_mu = x_over_n(math_quad(cur_size), 18);
			#pragma endregion
			goto delete_q;
			#pragma endregion
			break;
		case whatsit_node:
		case penalty_node:
		case rule_node:
		case disc_node:
		case adjust_node:
		case ins_node:
		case mark_node:
		case glue_node:
		case kern_node:
			link(p) = q; p = q; q = link(q); link(p) = null; goto done;
			break;
		default:
			confusion(TEX_STRING("mlist3"));
			break;
		}
		#pragma endregion

		#pragma region <Append inter-element spacing based on r_type and t 766>
		if (r_type > 0) {
			switch (so(str_pool[r_type * 8 + t + magic_offset])) {
			case TEX_STRING("0"): x = 0; break;
			case TEX_STRING("1"): if (cur_style < script_style) x = thin_mu_skip_code; else x = 0; break;
			case TEX_STRING("2"): x = thin_mu_skip_code; break;
			case TEX_STRING("3"): if (cur_style < script_style) x = med_mu_skip_code; else x = 0; break;
			case TEX_STRING("4"): if (cur_style < script_style) x = thick_mu_skip_code; else x = 0; break;
			default:
				confusion(TEX_STRING("mlist4"));
				break;
			}
			if (x != 0) {
				y = math_glue(glue_par(x), cur_mu); z = new_glue(y); glue_ref_count(y) = null;
				link(p) = z; p = z;
				subtype(z) = x + 1;
			}
		}
		#pragma endregion

		#pragma region <Append any new_hlist entries for q, and any appropriate penalties 767>
		if (new_hlist(q) != null) {
			link(p) = new_hlist(q);
			do {
				p = link(p);
			} while (!(link(p) == null));
		}
		if(penalties)
			if(link(q)!=null)
				if (pen < inf_penalty) {
					r_type = type(link(q));
					if(r_type != penalty_node)
						if (r_type != rel_noad) {
							z = new_penalty(pen); link(p) = z; p = z;
						}
				}
		#pragma endregion
		r_type = t;
	delete_q:
		r = q; q = link(q); free_node(r, s);
	done:;
	}

	#pragma endregion

}


// 734
void make_over(pointer q)
{
	info(nucleus(q)) = overbar(clean_box(nucleus(q), cramped_style(cur_style)), 3 * default_rule_thickness, default_rule_thickness);
	math_type(nucleus(q)) = sub_box;
}

// 735
void make_under(pointer q)
{
	pointer p, x, y;
	scaled delta;

	x = clean_box(nucleus(q), cur_style); p = new_kern(3 * default_rule_thickness); link(x) = p;
	link(p) = fraction_rule(default_rule_thickness); y = vpack(x, 0, additional);
	delta = height(y) + depth(y) + default_rule_thickness; height(y) = height(x);
	depth(y) = delta - height(y); info(nucleus(q)) = y; math_type(nucleus(q)) = sub_box;
}

// 736
void make_vcenter(pointer q)
{
	pointer v;
	scaled delta;

	v = info(nucleus(q));
	if (type(v) != vlist_node) confusion(TEX_STRING("vcenter"));
	delta = height(v) + depth(v); height(v) = axis_height(cur_size) + half(delta);
	depth(v) = delta - height(v);
}


// 737
void make_radical(pointer q)
{
	pointer x, y;
	scaled delta, clr;

	x = clean_box(nucleus(q), cramped_style(cur_style));
	if (cur_style < text_style)
		clr = default_rule_thickness + (abs(math_x_height(cur_size)) / 4);
	else {
		clr = default_rule_thickness; clr += abs(clr) / 4;
	}
	y = var_delimiter(left_delimiter(q), cur_size, height(x) + depth(x) + clr + default_rule_thickness);
	delta = depth(y) - (height(x) + depth(x) + clr);
	if (delta > 0) clr += half(delta);
	shift_amount(y) = -(height(x) + clr); link(y) = overbar(x, clr, height(y));
	info(nucleus(q)) = hpack(y, 0, additional); math_type(nucleus(q)) = sub_box;
}


// 738
void make_math_accent(pointer q)
{
	pointer p, x, y;
	int a;
	quarterword c;
	internal_font_number f;
	four_quarters i;
	scaled s;
	scaled h;
	scaled delta;
	scaled w;

	fetch(accent_chr(q));
	if (char_exists(cur_i)) {
		i = cur_i; c = cur_c; f = cur_f;

		#pragma region <Compute the amount of skew 741>
		s = 0;
		if (math_type(nucleus(q)) == math_char) {
			fetch(nucleus(q));
			if (char_tag(cur_i) == lig_tag) {
				a = lig_kern_start(cur_f, cur_i); cur_i = font_info[a].union_t.qqqq;
				if (skip_byte(cur_i) > stop_flag) {
					a = lig_kern_restart(cur_f, cur_i); cur_i = font_info[a].union_t.qqqq;
				}
				while(1) {
					if (qo(next_char(cur_i)) == skew_char[cur_f]) {
						if (op_byte(cur_i) >= kern_flag)
							if (skip_byte(cur_i) <= stop_flag) s = char_kern(cur_f, cur_i);
						goto done1;
					}
					if (skip_byte(cur_i) >= stop_flag) goto done1;
					a += qo(skip_byte(cur_i)) + 1; cur_i = font_info[a].union_t.qqqq;
				}
			}
		}
	done1:

		#pragma endregion
	
		x = clean_box(nucleus(q), cramped_style(cur_style)); w = width(x); h = height(x);

		#pragma region <Switch to a larger accent if available and appropriate 740>
		while (1) {
			if (char_tag(i) != list_tag) goto done;
			y = rem_byte(i); i = char_info(f, y);
			if (!char_exists(i)) goto done;
			if (char_width(f, i) > w) goto done;

			// overflow check
			if (y > 255) {
				printf("Overflow assignment\n");
				exit(1);
			}
			c = (quarterword)y;
			//---------
		}
	done:

		#pragma endregion

		if (h < x_height(f)) delta = h; else delta = x_height(f);
		if(math_type(supscr(q)) != empty || math_type(subscr(q))!= empty)
			if (math_type(nucleus(q)) == math_char)
				#pragma region <Swap the subscript and superscript into box x 742>
			{
				flush_node_list(x); x = new_noad(); mem[nucleus(x)] = mem[nucleus(q)];
				mem[supscr(x)] = mem[supscr(q)]; mem[subscr(x)] = mem[subscr(q)];
				mem[supscr(q)].union_t.hh = empty_field; mem[subscr(q)].union_t.hh = empty_field;
				math_type(nucleus(q)) = sub_mlist; info(nucleus(q)) = x; x = clean_box(nucleus(q), cur_style);
				delta += height(x) - h; h = height(x);
			}
				#pragma endregion
		y = char_box(f, c); shift_amount(y) = s + half(w - width(y)); width(y) = 0; p = new_kern(-delta);
		link(p) = x; link(y) = p; y = vpack(y, 0, additional); width(y) = width(x);
		if (height(y) < h)
			#pragma region <Make the height of box y equal to h 739>
		{
			p = new_kern(h - height(y)); link(p) = list_ptr(y); list_ptr(y) = p; height(y) = h;
		}
			#pragma endregion
		info(nucleus(q)) = y; math_type(nucleus(q)) = sub_box;


	}
}

// 743
void make_fraction(pointer q)
{
	pointer p, v, x, y, z;
	scaled delta, delta1, delta2, shift_up, shift_down, clr;

	if (thickness(q) == default_code) thickness(q) = default_rule_thickness;

	#pragma region <Create equal-width boxes x and z for the numerator and denominator, and compute.. 744>
	x = clean_box(numerator(q), num_style(cur_style));
	z = clean_box(denominator(q), denom_style(cur_style));
	if (width(x) < width(z)) x = rebox(x, width(z));
	else z = rebox(z, width(x));
	if (cur_style < text_style) {
		shift_up = num1(cur_size); shift_down = denom1(cur_size);
	}
	else {
		shift_down = denom2(cur_size);
		if (thickness(q) != 0) shift_up = num2(cur_size);
		else shift_up = num3(cur_size);
	}
#pragma endregion

	if (thickness(q) == 0)
		#pragma region <Adjust shift_up and shift_down for the case of no fraction line 745>
	{
		if (cur_style < text_style) clr = 7 * default_rule_thickness;
		else clr = 3 * default_rule_thickness;
		delta = half(clr - ((shift_up - depth(x)) - (height(z) - shift_down)));
		if (delta > 0) {
			shift_up += delta; shift_down += delta;
		}
	}
#pragma endregion
	else
		#pragma region <Adjust shift_up and shift_down for the case of a fraction line 746>
	{
		if (cur_style < text_style) clr = 3 * thickness(q);
		else clr = thickness(q);
		delta = half(thickness(q)); delta1 = clr - ((shift_up - depth(x)) - (axis_height(cur_size) + delta));
		delta2 = clr - ((axis_height(cur_size) - delta) - (height(z) - shift_down));
		if (delta1 > 0) shift_up += delta1;
		if (delta2 > 0) shift_down += delta2;
	}
#pragma endregion

	#pragma region <Construct a vlist box for the fraction, according to shift_up and shift_down 747>
	v = new_null_box(); type(v) = vlist_node; height(v) = shift_up + height(x);
	depth(v) = depth(z) + shift_down; width(v) = width(x);
	if (thickness(q) == 0) {
		p = new_kern((shift_up - depth(x)) - (height(z) - shift_down)); link(p) = z;
	}
	else {
		y = fraction_rule(thickness(q));
		p = new_kern((axis_height(cur_size) - delta) - (height(z) - shift_down));
		link(y) = p; link(p) = z;
		p = new_kern((shift_up - depth(x)) - (axis_height(cur_size) + delta)); link(p) = y;
	}
	link(x) = p; list_ptr(v) = x;
#pragma endregion

	#pragma region <Put the fraction into a box with its delimiters, and make new_hlsit(q) point to it 748>
	if (cur_style < text_style) delta = delim1(cur_size);
	else delta = delim2(cur_size);
	x = var_delimiter(left_delimiter(q), cur_size, delta); link(x) = v;
	z = var_delimiter(right_delimiter(q), cur_size, delta); link(v) = z;
	new_hlist(q) = hpack(x, 0, additional);
#pragma endregion


}



// 749

scaled make_op(pointer q)
{
	scaled delta;
	pointer p, v, x, y, z;
	quarterword c;
	four_quarters i;
	scaled shift_up, shift_down;


	if (subtype(q) == normal && cur_style < text_style) subtype(q) = limits;
	if (math_type(nucleus(q)) == math_char) {
		fetch(nucleus(q));
		if (cur_style < text_style && char_tag(cur_i) == list_tag) {
			c = rem_byte(cur_i); i = char_info(cur_f, c);
			if (char_exists(i)) {
				cur_c = c; cur_i = i; character(nucleus(q)) = c;
			}
		}
		delta = char_italic(cur_f, cur_i); x = clean_box(nucleus(q), cur_style);
		if (math_type(subscr(q)) != empty && subtype(q) != limits) width(x) -= delta;
		shift_amount(x) = half(height(x) - depth(x)) - axis_height(cur_size);
		math_type(nucleus(q)) = sub_box; info(nucleus(q)) = x;
	}
	else delta = 0;
	if (subtype(q) == limits)
		#pragma region <Construct a box with limits above adn below it, skewed by delta 750>
	{
		x = clean_box(supscr(q), sup_style(cur_style)); y = clean_box(nucleus(q), cur_style);
		z = clean_box(subscr(q), sub_style(cur_style)); v = new_null_box(); type(v) = vlist_node;
		width(v) = width(y);
		if (width(x) > width(v)) width(v) = width(x);
		if (width(z) > width(v)) width(v) = width(z);
		x = rebox(x, width(v)); y = rebox(y, width(v)); z = rebox(z, width(v));
		shift_amount(x) = half(delta); shift_amount(z) = -shift_amount(x); height(v) = height(y);
		depth(v) = depth(y);
		#pragma region <Attach the limits to y and adjust height(v), depth(v) to account for their presence 751>
		if (math_type(supscr(q)) == empty) {
			free_node(x, box_node_size); list_ptr(v) = y;
		}
		else {
			shift_up = big_op_spacing3 - depth(x);
			if (shift_up < big_op_spacing1) shift_up = big_op_spacing1;
			p = new_kern(shift_up); link(p) = y; link(x) = p;
			p = new_kern(big_op_spacing5); link(p) = x; list_ptr(v) = p;
			height(v) += big_op_spacing5 + height(x) + depth(x) + shift_up;
		}
		if (math_type(subscr(q)) == empty) free_node(z, box_node_size);
		else {
			shift_down = big_op_spacing4 - height(z);
			if (shift_down < big_op_spacing2) shift_down = big_op_spacing2;
			p = new_kern(shift_down); link(y) = p; link(p) = z;
			p = new_kern(big_op_spacing5); link(z) = p;
			depth(v) += big_op_spacing5 + height(z) + depth(z) + shift_down;
		}
#pragma endregion
		new_hlist(q) = v;
	}
#pragma endregion
	return delta;
}

// 752
void make_ord(pointer q)
{
	int a;
	pointer p, r;

restart:
	if(math_type(subscr(q)) == empty)
		if(math_type(supscr(q)) == empty)
			if (math_type(nucleus(q)) == math_char) {
				p = link(q);
				if(p!=null)
					if(type(p) >= ord_noad && type(p) <= punct_noad)
						if(math_type(nucleus(p)) == math_char)
							if (fam(nucleus(p)) == fam(nucleus(q))) {
								math_type(nucleus(q)) = math_text_char; fetch(nucleus(q));
								if (char_tag(cur_i) == lig_tag) {
									a = lig_kern_start(cur_f, cur_i); cur_c = character(nucleus(p));
									cur_i = font_info[a].union_t.qqqq;
									if (skip_byte(cur_i) > stop_flag) {
										a = lig_kern_restart(cur_f, cur_i); cur_i = font_info[a].union_t.qqqq;
									}
									while (1) {
										#pragma region <If instruction cur_i is a kern with cur_c, attach the kern after q; or.. 753>
										if(next_char(cur_i) == cur_c)
											if(skip_byte(cur_i)<=stop_flag)
												if (op_byte(cur_i) >= kern_flag) {
													p = new_kern(char_kern(cur_f, cur_i)); link(p) = link(q); link(q) = p; return;
												}
												else {
													check_interrupt;
													switch (op_byte(cur_i)) {
													case qi(1):
													case qi(5):
														character(nucleus(q)) = rem_byte(cur_i);
														break;
													case qi(2):
													case qi(6):
														character(nucleus(p)) = rem_byte(cur_i);
														break;
													case qi(3):
													case qi(7):
													case qi(11):
														r = new_noad();
														character(nucleus(r)) = rem_byte(cur_i); fam(nucleus(r)) = fam(nucleus(q));
														link(q) = r; link(r) = p;
														if (op_byte(cur_i) < qi(11)) math_type(nucleus(r)) = math_char;
														else math_type(nucleus(r)) = math_text_char;
														break;
													default:
														link(q) = link(p); character(nucleus(q)) = rem_byte(cur_i);
														mem[subscr(q)] = mem[subscr(p)]; mem[supscr(q)] = mem[supscr(p)];
														free_node(p, noad_size);
														break;
													}
													if (op_byte(cur_i) > qi(3)) return;
													math_type(nucleus(q)) = math_char; goto restart;
												}
										#pragma endregion
										if (skip_byte(cur_i) >= stop_flag) return;
										a += qo(skip_byte(cur_i)) + 1; cur_i = font_info[a].union_t.qqqq;
									}
								}
							}
			}
}


// 756
void make_scripts(pointer q, scaled delta)
{
	pointer p, x, y, z;
	scaled shift_up, shift_down, clr;
	small_number t;

	p = new_hlist(q);
	if (is_char_node(p)) {
		shift_up = 0; shift_down = 0;
	}
	else {
		z = hpack(p, 0, additional);
		if (cur_style < script_style) t = script_size; else t = script_script_size;
		shift_up = height(z) - sup_drop(t); shift_down = depth(z) + sub_drop(t); free_node(z, box_node_size);
	}
	if (math_type(supscr(q)) == empty)
		#pragma region <Construct a subscript box x when there is no superscript 757>
	{
		x = clean_box(subscr(q), sub_style(cur_style)); width(x) += script_space;
		if (shift_down < sub1(cur_size)) shift_down = sub1(cur_size);
		clr = height(x) - (abs(math_x_height(cur_size)*4) / 5);
		if (shift_down < clr) shift_down = clr;
		shift_amount(x) = shift_down;
	}
		#pragma endregion
	else {
		#pragma region <Construct a superscript box x 758>
		{
			x = clean_box(supscr(q), sup_style(cur_style)); width(x) += script_space;
			if (myodd(cur_style)) clr = sup3(cur_size);
			else if (cur_style < text_style) clr = sup1(cur_size);
			else clr = sup2(cur_size);
			if (shift_up < clr) shift_up = clr;
			clr = depth(x) + (abs(math_x_height(cur_size)) / 4);
			if (shift_up < clr) shift_up = clr;
		}
		#pragma endregion
		if (math_type(subscr(q)) == empty) shift_amount(x) = -shift_up;
		else
			#pragma region <Construct a sub/superscript combination box x, with the superscript offset by delta 759>
		{
			y = clean_box(subscr(q), sub_style(cur_style)); width(y) += script_space;
			if (shift_down < sub2(cur_size)) shift_down = sub2(cur_size);
			clr = 4 * default_rule_thickness - ((shift_up - depth(x)) - (height(y) - shift_down));
			if (clr > 0) {
				shift_down += clr;
				clr = (abs(math_x_height(cur_size) * 4) / 5) - (shift_up - depth(x));
				if (clr > 0) {
					shift_up += clr; shift_down -= clr;
				}
			}
			shift_amount(x) = delta;
			p = new_kern((shift_up - depth(x)) - (height(y) - shift_down)); link(x) = p; link(p) = y;
			x = vpack(x, 0, additional); shift_amount(x) = shift_down;
		}
			#pragma endregion

	}
	if (new_hlist(q) == null) new_hlist(q) = x;
	else {
		p = new_hlist(q);
		while (link(p) != null) p = link(p);
		link(p) = x;
	}
}


// 762
small_number make_left_right(pointer q, small_number style, scaled max_d, scaled max_h)
{
	scaled delta, delta1, delta2;

	if (style < script_style) cur_size = text_size;
	else cur_size = 16 * ((style - text_style) / 2);
	delta2 = max_d + axis_height(cur_size); delta1 = max_h + max_d - delta2;
	if (delta2 > delta1) delta1 = delta2;
	delta = (delta1 / 500) * delimiter_factor; delta2 = delta1 + delta1 - delimiter_shortfall;
	if (delta < delta2) delta = delta2;
	new_hlist(q) = var_delimiter(delimiter(q), cur_size, delta);
	return type(q) - (left_noad - open_noad);
}


// 772
void push_alignment()
{
	pointer p;
	p = get_node(align_stack_node_size); link(p) = align_ptr; info(p) = cur_align;
	llink(p) = preamble; rlink(p) = cur_span; mem[p + 2].union_t.an_int = cur_loop; mem[p + 3].union_t.an_int = align_state;
	info(p + 4) = cur_head; link(p + 4) = cur_tail; align_ptr = p; cur_head = get_avail();
}

void pop_alignment()
{
	pointer p;
	free_avail(cur_head); p = align_ptr; cur_tail = link(p + 4); cur_head = info(p + 4);
	align_state = mem[p + 3].union_t.an_int; cur_loop = mem[p + 2].union_t.an_int; cur_span = rlink(p);
	preamble = llink(p);
	cur_align = info(p); align_ptr = link(p); free_node(p, align_stack_node_size);
}

// 785
void align_peek()
{
restart:
	align_state = 1000000;
	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_cmd == no_align) {
		scan_left_brace(); new_save_level(no_align_group);
		if (mode == -vmode) normal_paragraph();
	}
	else if (cur_cmd == right_brace) fin_align();
	else if (cur_cmd == car_ret && cur_chr == cr_cr_code) goto restart;
	else {
		init_row();
		init_col();
	}
}

// 786
void init_row()
{
	push_nest(); mode = mode_type((-hmode - vmode) - mode);
	if (mode == -hmode) space_factor = 0;
	else prev_depth = 0;
	tail_append(new_glue(glue_ptr(preamble))); subtype(tail) = tab_skip_code + 1;
	cur_align = link(preamble); cur_tail = cur_head; init_span(cur_align);
}

// 787
void init_span(pointer p)
{
	push_nest();
	if (mode == -hmode) space_factor = 1000;
	else {
		prev_depth = ignore_depth; normal_paragraph();
	}
	cur_span = p;
}
//788
void init_col()
{
	extra_info(cur_align) = cur_cmd;
	if (cur_cmd == omit) align_state = 0;
	else {
		back_input(); begin_token_list(u_part(cur_align), u_template);
	}
}

// 577
void scan_font_ident()
{
	internal_font_number f;
	halfword m;

	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_cmd == def_font)
		f = cur_font;
	else if (cur_cmd == set_font)
		f = cur_chr;
	else if (cur_cmd == def_family) {
		m = cur_chr;
		scan_four_bit_int();
		f = equiv(m + cur_val);
	}
	else {
		print_err(TEX_STRING("Missing font identifier"));
		help2(TEX_STRING("I was looking for a control sequence whose"),
			TEX_STRING("current meaning has been defined by \font."));
		back_error();
		f = null_font;
	}
	cur_val = f;
}

// 1136
void push_math(group_code c)
{
	push_nest(); mode = (mode_type)-mmode; incompleat_noad = null; new_save_level(c);
}

// 1174
void build_choices()
{
	pointer p;
	unsave(); p = fin_mlist(null);
	switch (saved(-1)) {
	case 0: display_mlist(tail) = p; break;
	case 1: text_mlist(tail) = p; break;
	case 2: script_mlist(tail) = p; break;
	case 3: script_script_mlist(tail) = p; decr(save_ptr); goto _exit; break;

	}
	incr(saved(-1)); push_math(math_choice_group); scan_left_brace();
_exit:
	;
}

// 800
void fin_align()
{
	pointer p, q, r, s, u, v;
	scaled t, w;
	scaled o;
	halfword n;
	scaled rule_save;
	memory_word aux_save;

	if (cur_group != align_group) confusion(TEX_STRING("align1"));
	unsave();
	if (cur_group != align_group) confusion(TEX_STRING("align0"));
	unsave();
	if (nest[nest_ptr - 1].mode_field == mmode) o = display_indent;
	else o = 0;

	#pragma region <Go through the preamble list, determining the column widths and changing the alignrecords to dummy unset boxes 801>
	q = link(preamble);
	do {
		flush_list(u_part(q)); flush_list(v_part(q)); p = link(link(q));

		if (width(q) == null_flag)
			#pragma region <Nullify width(q) and the tabskip glue following this column 802>
		{
			width(q) = 0; r = link(q); s = glue_ptr(r);
			if (s != zero_glue) {
				add_glue_ref(zero_glue); delete_glue_ref(s); glue_ptr(r) = zero_glue;
			}
		}
			#pragma endregion

		if (info(q) != end_span) 
			#pragma region <Merge the widths in the span nodes of q with those of p, destroying the span nodes of q 803>
		{
			t = width(q) + width(glue_ptr(link(q))); r = info(q); s = end_span; info(s) = p;
			n = min_quarterword + 1;
			do {
				width(r) = width(r) - t; u = info(r);
				while (link(r) > n) {
					s = info(s); n = link(info(s)) + 1;
				}
				if (link(r) < n) {
					info(r) = info(s); info(s) = r; decr(link(r)); s = r;
				}
				else {
					if (width(r) > width(info(s))) width(info(s)) = width(r);
					free_node(r, span_node_size);
				}
				r = u;
			} while (!(r==end_span));
		}
			#pragma endregion

		type(q) = unset_node; span_count(q) = min_quarterword; height(q) = 0; depth(q) = 0;
		glue_order(q) = normal; glue_sign(q) = normal; glue_stretch(q) = 0; glue_shrink(q) = 0; q = p;
	} while (!(q == null));
	#pragma endregion

	#pragma region <Package the preamble list, to determine the actual tabskip glue amounts and let p point to this prototype box 804>
	save_ptr -= 2; pack_begin_line = -mode_line;
	if (mode == -vmode) {
		rule_save = overfull_rule; overfull_rule = 0;
		p = hpack(preamble, saved(1), saved(0)); overfull_rule = rule_save;
	}
	else {
		q = link(preamble);
		do {
			height(q) = width(q); width(q) = 0; q = link(link(q));
		} while (!(q == null));
		p = vpack(preamble, saved(1), saved(0)); q = link(preamble);
		do {
			width(q) = height(q); height(q) = 0; q = link(link(q));
		} while (!(q == null));
	}
	pack_begin_line = 0;
	#pragma endregion

	#pragma region <Set the glue in all the unset boxes of the current list 805>
	q = link(head); s = head;
	while (q != null) {
		if(!is_char_node(q))
			if (type(q) == unset_node)
				#pragma region <Set the unset box q and the unset boxes in it 807>
			{
				if (mode == -vmode) {
					type(q) = hlist_node; width(q) = width(p);
				}
				else {
					type(q) = vlist_node; height(q) = height(p);
				}
				glue_order(q) = glue_order(p); glue_sign(q) = glue_sign(p); glue_set(q) = glue_set(p);
				shift_amount(q) = o; r = link(list_ptr(q)); s = link(list_ptr(p));
				do {
					#pragma region <Set the glue in node r and change it from an unset node 808>
					n = span_count(r); t = width(s); w = t; u = hold_head;
					while (n > min_quarterword) {
						decr(n);
						#pragma region <Append tabskip glue and an empty box to list u, and update s and t as the prototype.. 809>
						s = link(s); v = glue_ptr(s); link(u) = new_glue(v); u = link(u); subtype(u) = tab_skip_code + 1;
						t += width(v);
						if (glue_sign(p) == stretching) {
							if (stretch_order(v) == glue_order(p)) t += (scaled)round(_float(glue_set(p))*stretch(v));
						}
						else if (glue_sign(p) == shrinking) {
							if(shrink_order(v) == glue_order(p)) t -= (scaled)round(_float(glue_set(p))*shrink(v));
						}
						s = link(s); link(u) = new_null_box(); u = link(u); t += width(s);
						if (mode == -vmode) width(u) = width(s);
						else {
							type(u) = vlist_node; height(u) = width(s);
						}
						#pragma endregion
					}
					if (mode == -vmode)
						#pragma region <Make the unset node r into an hlist_node of width w, setting the glue .. 810>
					{
						height(r) = height(q); depth(r) = depth(q);
						if (t == width(r)) {
							glue_sign(r) = normal; glue_order(r) = normal;
							set_glue_ratio_zero(glue_set(r));
						}
						else if (t > width(r)) {
							glue_sign(r) = stretching;
							if (glue_stretch(r) == 0) set_glue_ratio_zero(glue_set(r));
							else glue_set(r) = unfloat(float(t - width(r)) / glue_stretch(r));
						}
						else {
							glue_order(r) = glue_sign(r); glue_sign(r) = shrinking;
							if (glue_shrink(r) == 0) set_glue_ratio_zero(glue_set(r));
							else if (glue_order(r) == normal && width(r) - t > glue_shrink(r))
								set_glue_ratio_one(glue_set(r));
							else glue_set(r) = unfloat(float(width(r) - t) / glue_shrink(r));
						}
						width(r) = w; type(r) = hlist_node;
					}
						#pragma endregion
					else
						#pragma region <Make the unset node r into a vlist_node of height w, setting the glue.. 811>
					{
						width(r) = width(q);
						if (t == height(r)) {
							glue_sign(r) = normal; glue_order(r) = normal; set_glue_ratio_zero(glue_set(r));
						}
						else if (t > height(r)) {
							glue_sign(r) = stretching;
							if (glue_stretch(r) == 0) set_glue_ratio_zero(glue_set(r));
							else glue_set(r) = unfloat(float(t - height(r)) / glue_stretch(r));
						}
						else {
							glue_order(r) = glue_sign(r); glue_sign(r) = shrinking;
							if (glue_shrink(r) == 0) set_glue_ratio_zero(glue_set(r));
							else if (glue_order(r) == normal && (height(r) - t > glue_shrink(r)))
								set_glue_ratio_one(glue_set(r));
							else glue_set(r) = unfloat(float(height(r) - t) / glue_shrink(r));
						}
						height(r) = w; type(r) = vlist_node;
					}
						#pragma endregion
					shift_amount(r) = 0;
					if (u != hold_head) {
						link(u) = link(r); link(r) = link(hold_head); r = u;
					}

					#pragma endregion
					r = link(link(r)); s = link(link(s));
				} while (!(r == null));
			}
				#pragma endregion
			else if (type(q) == rule_node)
				#pragma region <Make the running dimensions in rule q extend to teh boundaries of teh alignment 806>
			{
				if (is_running(width(q))) width(q) = width(p);
				if (is_running(height(q))) height(q) = height(p);
				if (is_running(depth(q))) depth(q) = depth(p);
				if (o != 0) {
					r = link(q); link(q) = null; q = hpack(q, 0, additional); shift_amount(q) = o; link(q) = r;
					link(s) = q;
				}
			}
#pragma endregion
		s = q; q = link(q);
	}
	#pragma endregion

	flush_node_list(p); pop_alignment();
	#pragma region <Insert the current list into its environment 812>
	aux_save = aux; p = link(head); q = tail; pop_nest();
	if (mode == mmode)
		#pragma region <Finish an alignment in a display 1206>
	{
		do_assignments();
		if (cur_cmd != math_shift)
			#pragma region <pontificate about improper alignment in display 1207>
		{
			print_err(TEX_STRING("Missing $$ inserted"));
			help2(TEX_STRING("Displays can use special alignments (like \eqalignno)"),
				TEX_STRING("only if nothing but the alignment itself is between $$'s."));
			back_error();
		}
			#pragma endregion
		else
			#pragma region <Check that another $ follows 1197>
		{
			get_x_token();
			if (cur_cmd != math_shift) {
				print_err(TEX_STRING("Display math should end with $$"));
				help2(TEX_STRING("The `$' that I just saw supposedly matches a previous `$$'."),
					TEX_STRING("So I shall assume that you typed `$$' both times."));
				back_error();
			}
		}
			#pragma endregion
		pop_nest(); tail_append(new_penalty(pre_display_penalty));
		tail_append(new_param_glue(above_display_skip_code)); link(tail) = p;
		if (p != null) tail = q;
		tail_append(new_penalty(post_display_penalty)); tail_append(new_param_glue(below_display_skip_code));
		prev_depth = aux_save.sc; resume_after_display();
	}
		#pragma endregion
	else {
		aux = aux_save; link(tail) = p;
		if (p != null) tail = q;
		if (mode == vmode) build_page();
	}
	#pragma endregion
}

// 1184
pointer fin_mlist(pointer p)
{
	pointer q;
	if (incompleat_noad != null) 
		#pragma region <Compleat the incompleat noad 1185>
	{
		math_type(denominator(incompleat_noad)) = sub_mlist;
		info(denominator(incompleat_noad)) = link(head);
		if (p == null) q = incompleat_noad;
		else {
			q = info(numerator(incompleat_noad));
			if (type(q) != left_noad) confusion(TEX_STRING("right"));
			info(numerator(incompleat_noad)) = link(q);
			link(q) = incompleat_noad;
			link(incompleat_noad) = p;
		}
	}
		#pragma endregion
	else {
		link(tail) = p; q = link(head);
	}
	pop_nest();
	return q;
}

// 259
pointer id_lookup(int j, int l)
{
	int h, d;
	pointer p, k;

	#pragma region	<Compute the hash code h 261>
	h = buffer[j];
	for (k = j + 1; k <= j + l - 1; k++) {
		h = h + h + buffer[k];
		while (h >= hash_prime)
			h = h - hash_prime;
	}
	#pragma endregion

	p = h + hash_base;
	while (1) {
		if (text(p) > 0) {
			if (length(text(p)) == l) {
				if (str_eq_buf(text(p), j))
					goto found;
			}
		}
		if (next(p) == 0) {
			if (no_new_control_sequence)
				p = undefined_control_sequence;
			else 
				#pragma region   <Insert a new control sequence after p, then make p point to it 260>
			{
				if (text(p) > 0) {
					do {
						if (hash_is_full)
							overflow(TEX_STRING("hash size"), hash_size);
						decr(hash_used);
					} while (text(hash_used) != 0);
					next(p) = hash_used;
					p = hash_used;
				}
				str_room(l); d = cur_length;
				while (pool_ptr > str_start[str_ptr]) {
					decr(pool_ptr); str_pool[pool_ptr + l] = str_pool[pool_ptr];
				}
				for (k = j; k <= j + l - 1; k++) append_char(buffer[k]);
				text(p) = make_string(); pool_ptr = pool_ptr + d;
				//stat
				incr(cs_count);
				//tats
			}
				#pragma endregion
			goto found;
		}
		p = next(p);
	}
found:
	return p;
}

// 274
void new_save_level(group_code c)
{
	check_full_save_stack;
	save_type(save_ptr) = level_boundary; save_level(save_ptr) = (quarterword)cur_group;
	save_index(save_ptr) = cur_boundary;
	if (cur_level == max_quarterword)
		overflow(TEX_STRING("grouping levels"), max_quarterword - min_quarterword);
	cur_boundary = save_ptr; incr(cur_level); incr(save_ptr); cur_group = c;
}

// 281
void unsave()
{
	pointer p;
	quarterword l;
	halfword t;
	if (cur_level > level_one) {
		decr(cur_level);
		#pragma region <Clear off top level form save_stack 282>
		while (1) {
			decr(save_ptr);
			if (save_type(save_ptr) == level_boundary) goto done;
			p = save_index(save_ptr);
			if (save_type(save_ptr) == insert_token)
				#pragma region <Insert token p into TeXs input 326>
			{
				t = cur_tok; cur_tok = p; back_input(); cur_tok = t;
			}
				#pragma endregion
			else {
				if (save_type(save_ptr) == restore_old_value) {
					l = save_level(save_ptr); decr(save_ptr);
				}
				else save_stack[save_ptr] = eqtb[undefined_control_sequence];

				#pragma region <Store save_stack[save_ptr] in eqtb[p], unless eqtb[p] holds a global value 283>
				if(p < int_base)
					if (eq_level(p) == level_one) {
						eq_destroy(save_stack[save_ptr]);
						//stat
						if (tracing_restores > 0) restore_trace(p, TEX_STRING("retaining"));
						//tats
					}
					else {
						eq_destroy(eqtb[p]);
						eqtb[p] = save_stack[save_ptr];
						//stat
						if (tracing_restores > 0) restore_trace(p, TEX_STRING("restoring"));
						//tats
					}
				else if (xeq_level[p] != level_one) {
					eqtb[p] = save_stack[save_ptr]; xeq_level[p] = l;
					//stat
					if (tracing_restores > 0) restore_trace(p, TEX_STRING("restoring"));
					//tats
				}
				else {
					//stat
					if (tracing_restores > 0) restore_trace(p, TEX_STRING("retaining"));
					//tats
				}
#pragma endregion
			}
		}
	done:
		cur_group = (group_code)save_level(save_ptr); cur_boundary = save_index(save_ptr);
		#pragma endregion
	}
	else confusion(TEX_STRING("curlevel"));
}


// 237
void print_param(int n)
{
	switch (n) {
	case pretolerance_code: print_esc(TEX_STRING("pretolerance")); break;
	case tolerance_code: print_esc(TEX_STRING("tolerance")); break;
	case line_penalty_code: print_esc(TEX_STRING("linepenalty")); break;
	case hyphen_penalty_code: print_esc(TEX_STRING("hyphenpenalty")); break;
	case ex_hyphen_penalty_code: print_esc(TEX_STRING("exhyphenpenalty")); break;
	case club_penalty_code: print_esc(TEX_STRING("clubpenalty")); break;
	case widow_penalty_code: print_esc(TEX_STRING("widowpenalty")); break;
	case display_widow_penalty_code: print_esc(TEX_STRING("displaywidowpenalty")); break;
	case broken_penalty_code: print_esc(TEX_STRING("brokenpenalty")); break;
	case bin_op_penalty_code: print_esc(TEX_STRING("binoppenalty")); break;
	case rel_penalty_code: print_esc(TEX_STRING("relpenalty")); break;
	case pre_display_penalty_code: print_esc(TEX_STRING("predisplaypenalty")); break;
	case post_display_penalty_code: print_esc(TEX_STRING("postdisplaypenalty")); break;
	case inter_line_penalty_code: print_esc(TEX_STRING("interlinepenalty")); break;
	case double_hyphen_demerits_code: print_esc(TEX_STRING("doublehyphendemerits")); break;
	case final_hyphen_demerits_code: print_esc(TEX_STRING("finalhyphendemerits")); break;
	case adj_demerits_code: print_esc(TEX_STRING("adjdemerits")); break;
	case mag_code: print_esc(TEX_STRING("mag")); break;
	case delimiter_factor_code: print_esc(TEX_STRING("delimiterfactor")); break;
	case looseness_code: print_esc(TEX_STRING("looseness")); break;
	case time_code: print_esc(TEX_STRING("time")); break;
	case day_code: print_esc(TEX_STRING("day")); break;
	case month_code: print_esc(TEX_STRING("month")); break;
	case year_code: print_esc(TEX_STRING("year")); break;
	case show_box_breadth_code: print_esc(TEX_STRING("showboxbreadth")); break;
	case show_box_depth_code: print_esc(TEX_STRING("showboxdepth")); break;
	case hbadness_code: print_esc(TEX_STRING("hbadness")); break;
	case vbadness_code: print_esc(TEX_STRING("vbadness")); break;
	case pausing_code: print_esc(TEX_STRING("pausing")); break;
	case tracing_online_code: print_esc(TEX_STRING("tracingonline")); break;
	case tracing_macros_code: print_esc(TEX_STRING("tracingmacros")); break;
	case tracing_stats_code: print_esc(TEX_STRING("tracingstats")); break;
	case tracing_paragraphs_code: print_esc(TEX_STRING("tracingparagraphs")); break;
	case tracing_pages_code: print_esc(TEX_STRING("tracingpages")); break;
	case tracing_output_code: print_esc(TEX_STRING("tracingoutput")); break;
	case tracing_lost_chars_code: print_esc(TEX_STRING("tracinglostchars")); break;
	case tracing_commands_code: print_esc(TEX_STRING("tracingcommands")); break;
	case tracing_restores_code: print_esc(TEX_STRING("tracingrestores")); break;
	case uc_hyph_code: print_esc(TEX_STRING("uchyph")); break;
	case output_penalty_code: print_esc(TEX_STRING("outputpenalty")); break;
	case max_dead_cycles_code: print_esc(TEX_STRING("maxdeadcycles")); break;
	case hang_after_code: print_esc(TEX_STRING("hangafter")); break;
	case floating_penalty_code: print_esc(TEX_STRING("floatingpenalty")); break;
	case global_defs_code: print_esc(TEX_STRING("globaldefs")); break;
	case cur_fam_code: print_esc(TEX_STRING("fam")); break;
	case escape_char_code: print_esc(TEX_STRING("escapechar")); break;
	case default_hyphen_char_code: print_esc(TEX_STRING("defaulthyphenchar")); break;
	case default_skew_char_code: print_esc(TEX_STRING("defaultskewchar")); break;
	case end_line_char_code: print_esc(TEX_STRING("endlinechar")); break;
	case new_line_char_code: print_esc(TEX_STRING("newlinechar")); break;
	case language_code: print_esc(TEX_STRING("language")); break;
	case left_hyphen_min_code: print_esc(TEX_STRING("lefthyphenmin")); break;
	case right_hyphen_min_code: print_esc(TEX_STRING("righthyphenmin")); break;
	case holding_inserts_code: print_esc(TEX_STRING("holdinginserts")); break;
	case error_context_lines_code: print_esc(TEX_STRING("errorcontextlines")); break;
	default:
		print(TEX_STRING("[unknown integer parameter!]"));
		break;
	}
}

// 247
void print_length_param(int n)
{
	switch (n) {
	case par_indent_code: print_esc(TEX_STRING("parindent")); break;
	case math_surround_code: print_esc(TEX_STRING("mathsurround")); break;
	case line_skip_limit_code: print_esc(TEX_STRING("lineskiplimit")); break;
	case hsize_code: print_esc(TEX_STRING("hsize")); break;
	case vsize_code: print_esc(TEX_STRING("vsize")); break;
	case max_depth_code: print_esc(TEX_STRING("maxdepth")); break;
	case split_max_depth_code: print_esc(TEX_STRING("splitmaxdepth")); break;
	case box_max_depth_code: print_esc(TEX_STRING("boxmaxdepth")); break;
	case hfuzz_code: print_esc(TEX_STRING("hfuzz")); break;
	case vfuzz_code: print_esc(TEX_STRING("vfuzz")); break;
	case delimiter_shortfall_code: print_esc(TEX_STRING("delimitershortfall")); break;
	case null_delimiter_space_code: print_esc(TEX_STRING("nulldelimiterspace")); break;
	case script_space_code: print_esc(TEX_STRING("scriptspace")); break;
	case pre_display_size_code: print_esc(TEX_STRING("predisplaysize")); break;
	case display_width_code: print_esc(TEX_STRING("displaywidth")); break;
	case display_indent_code: print_esc(TEX_STRING("displayindent")); break;
	case overfull_rule_code: print_esc(TEX_STRING("overfullrule")); break;
	case hang_indent_code: print_esc(TEX_STRING("hangindent")); break;
	case h_offset_code: print_esc(TEX_STRING("hoffset")); break;
	case v_offset_code: print_esc(TEX_STRING("voffset")); break;
	case emergency_stretch_code: print_esc(TEX_STRING("emergencystretch")); break;
	default:
		print(TEX_STRING("[unknown dimen parameter!]"));
		break;
	}
}


//252
//stat
void show_eqtb(pointer n)
{
	if (n < active_base) print_char(TEX_STRING("?"));
	else if (n < glue_base)
		#pragma region <Show equivalent n, in region 1 or 2 223>
	{
		sprint_cs(n); print_char(TEX_STRING("="));
		print_cmd_chr(eq_type(n), equiv(n));
		if (eq_type(n) >= call) {
			print_char(TEX_STRING(":")); show_token_list(link(equiv(n)), null, 32);
		}
	}
		#pragma endregion
	else if(n<local_base)
		#pragma region <Show equivalent n, in region 3 229>
		if (n < skip_base) {
			print_skip_param(n - glue_base); print_char(TEX_STRING("="));
			if (n < glue_base + thin_mu_skip_code) print_spec(equiv(n), TEX_STRING("pt"));
			else print_spec(equiv(n), TEX_STRING("mu"));
		}
		else if (n < mu_skip_base) {
			print_esc(TEX_STRING("skip"));
			print_int(n - skip_base);
			print_char(TEX_STRING("=")); 
			print_spec(equiv(n), TEX_STRING("pt"));
		}
		else {
			print_esc(TEX_STRING("muskip")); print_int(n - mu_skip_base);
			print_char(TEX_STRING("="));
			print_spec(equiv(n), TEX_STRING("mu"));
		}
		#pragma endregion
	else if(n<int_base)
		#pragma region <Show equivalent n, in region 4 233>
		if (n == par_shape_loc) {
			print_esc(TEX_STRING("parshape"));
			print_char(TEX_STRING("="));
			if (par_shape_ptr == null) print_char(TEX_STRING("0"));
			else print_int(info(par_shape_ptr));
		}
		else if (n < toks_base) {
			print_cmd_chr(assign_toks, n); print_char(TEX_STRING("="));
			if (equiv(n) != null) show_token_list(link(equiv(n)), null, 32);
		}
		else if (n < box_base) {
			print_esc(TEX_STRING("toks")); print_int(n - toks_base);
			print_char(TEX_STRING("="));
			if (equiv(n) != null) show_token_list(link(equiv(n)), null, 32);
		}
		else if (n < cur_font_loc) {
			print_esc(TEX_STRING("box")); print_int(n - box_base);
			print_char(TEX_STRING("="));
			if (equiv(n) == null) print(TEX_STRING("void"));
			else {
				depth_threshold = 0; breadth_max = 1; show_node_list(equiv(n));
			}
		}
		else if(n<cat_code_base) 
			#pragma region <Show the font identifier in eqtb[n] 234>
		{
			if (n == cur_font_loc) print(TEX_STRING("current font"));
			else if (n < math_font_base + 16) {
				print_esc(TEX_STRING("textfont")); print_int(n - math_font_base);
			}
			else if (n < math_font_base + 32) {
				print_esc(TEX_STRING("scriptfont")); print_int(n - math_font_base - 16);
			}
			else {
				print_esc(TEX_STRING("scriptscriptfont")); print_int(n - math_font_base - 32);
			}
			print_char(TEX_STRING("="));
			print_esc(hash[font_id_base + equiv(n)].rh);
		}
			#pragma endregion
		else 
			#pragma region <Show the halfword code in eqtb[n] 235>
			if (n < math_code_base) {
				if (n < lc_code_base) {
					print_esc(TEX_STRING("catcode")); print_int(n - cat_code_base);
				}
				else if (n < uc_code_base) {
					print_esc(TEX_STRING("lccode")); print_int(n - lc_code_base);
				}
				else if (n < sf_code_base) {
					print_esc(TEX_STRING("uccode")); print_int(n - uc_code_base);
				}
				else {
					print_esc(TEX_STRING("sfcode")); print_int(n - sf_code_base);
				}
				print_char(TEX_STRING("=")); print_int(equiv(n));
			}
			else {
				print_esc(TEX_STRING("mathcode")); print_int(n - math_code_base);
				print_char(TEX_STRING("="));
				print_int(ho(equiv(n)));
			}
			#pragma endregion
		#pragma endregion
	else if(n<dimen_base)
		#pragma region <Show equivalent n, in region 5 242>
	{
		if (n < count_base) print_param(n - int_base);
		else if (n < del_code_base) {
			print_esc(TEX_STRING("count")); print_int(n - count_base);
		}
		else {
			print_esc(TEX_STRING("delcode")); print_int(n - del_code_base);
		}
		print_char(TEX_STRING("=")); print_int(eqtb[n].union_t.an_int);
	}
		#pragma endregion
	else if(n<=eqtb_size)
		#pragma region <Show equivalent n, in region 6 251>
	{
		if (n < scaled_base) print_length_param(n - dimen_base);
		else {
			print_esc(TEX_STRING("dimen")); print_int(n - scaled_base);
		}
		print_char(TEX_STRING("=")); print_scaled(eqtb[n].sc);
		print(TEX_STRING("pt"));
	}
#pragma endregion
	else print_char(TEX_STRING("?"));
}

//tats



//stat
void restore_trace(pointer p, str_number s)
{
	begin_diagnostic();
	print_char(TEX_STRING("{"));
	print(s);
	print_char(TEX_STRING(" ")); show_eqtb(p);
	print_char(TEX_STRING("}"));
	end_diagnostic(false);
}
//tats


//1064
void off_save()
{
	pointer p;
	if (cur_group == bottom_level)
		#pragma region <Drop current token and complain that it was unmatched 1066>
	{
		print_err(TEX_STRING("Extra ")); print_cmd_chr(cur_cmd, cur_chr);
		help1(TEX_STRING("Things are pretty mixed up, but I think the worst is over."));
		error();
	}
		#pragma endregion
	else {
		back_input(); p = get_avail(); link(temp_head) = p; print_err(TEX_STRING("Missing "));
		#pragma region <Prepare to insert a token that matches cur_group, and print what it is 1065>
		switch (cur_group) {
		case semi_simple_group:
			info(p) = cs_token_flag + frozen_end_group;
			print_esc(TEX_STRING("endgroup"));
			break;
		case math_shift_group:
			info(p) = math_shift_token + TEX_STRING("$");
			print_char(TEX_STRING("$"));
			break;
		case math_left_group:
			info(p) = cs_token_flag + frozen_right; link(p) = get_avail();
			p = link(p);
			info(p) = other_token + TEX_STRING(".");
			print_esc(TEX_STRING("right."));
			break;
		default:
			info(p) = right_brace_token + TEX_STRING("}");
			print_char(TEX_STRING("}"));
			break;
		}
		#pragma endregion

		print(TEX_STRING(" inserted")); ins_list(link(temp_head));
		help5(TEX_STRING("I've inserted something that you may have forgotten."),
			TEX_STRING("(See the <inserted text> above.)"),
			TEX_STRING("With luck, this will get me unwedged. But if you"),
			TEX_STRING("really didn't forget anything, try typing `2' now; then"),
			TEX_STRING("my insertion and my current dilemma will both disappear."));
		error();
	}
}

// 1068
void handle_right_brace()
{
	pointer p, q;
	scaled d;
	int f;
	switch (cur_group) {
	case group_code::simple_group:
		unsave();
		break;
	case group_code::bottom_level:
		print_err(TEX_STRING("Too many }'s"));
		help2(TEX_STRING("You've closed more groups than you opened."),
			TEX_STRING("Such booboos are generally harmless, so keep going."));
		error();
		break;
	case group_code::semi_simple_group:
	case group_code::math_shift_group:
	case group_code::math_left_group:
		extra_right_brace();
		break;
	#pragma region <Cases of handle_right_brace where a right_brace triggers a delayed action 1085>
	case group_code::hbox_group:
		package(0);
		break;
	case group_code::adjusted_hbox_group:
		adjust_tail = adjust_head; package(0);
		break;
	case group_code::vbox_group:
		end_graf();
		package(0);
		break;
	case group_code::vtop_group:
		end_graf();
		package(vtop_code);
		break;

		//1100
	case group_code::insert_group:
		end_graf(); q = split_top_skip; add_glue_ref(q); d = split_max_depth;
		f = floating_penalty; unsave(); decr(save_ptr);
		p = vpack(link(head), 0,additional); pop_nest();
		if (saved(0) < 255) {
			tail_append(get_node(ins_node_size)); type(tail) = ins_node; subtype(tail) = qi(saved(0));
			height(tail) = height(p) + depth(p); ins_ptr(tail) = list_ptr(p); split_top_ptr(tail) = q;
			depth(tail) = d; float_cost(tail) = f;
		}
		else {
			tail_append(get_node(small_node_size)); type(tail) = adjust_node;
			subtype(tail) = 0;
			adjust_ptr(tail) = list_ptr(p); delete_glue_ref(q);
		}
		free_node(p, box_node_size);
		if (nest_ptr == 0)
			build_page();
		break;
	case group_code::output_group:
		#pragma region <Resume the page builder after an output routine ahs come to an end 1026>
		if (loc != null || token_type != output_text && token_type != backed_up) 
			#pragma region <Recover from an unbalanced output routine 1027>
		{
			print_err(TEX_STRING("Unbalanced output routine"));
			help2(TEX_STRING("Your sneaky output routine has problematic {'s and/or }'s."),
				TEX_STRING("I can't handle that very well; good luck."));
			error();
			do {
				get_token();
			} while (!(loc == null));
		}
			#pragma endregion
		end_token_list();
		end_graf(); unsave(); output_active = false; insert_penalties = 0;
		#pragma region <Ensure that box 255 is empty after output 1028>
		if (box(255) != null) {
			print_err(TEX_STRING("Output routine didn't use all of ")); 
			print_esc(TEX_STRING("box")); print_int(255);
			help3(TEX_STRING("Your \output commands should empty \box255,"),
				TEX_STRING("e.g., by saying `\shipout\box255'."),
				TEX_STRING("Proceed; I'll discard its present contents."));
			box_error(255);
		}
		#pragma endregion
		if (tail != head) {
			link(page_tail) = link(head); page_tail = tail;
		}
		if (link(page_head) != null) {
			if (link(contrib_head) == null) contrib_tail = page_tail;
			link(page_tail) = link(contrib_head); link(contrib_head) = link(page_head); link(page_head) = null;
			page_tail = page_head;
		}
		pop_nest();
		build_page();
		#pragma endregion
		break;

		//1118
	case group_code::disc_group:
		build_discretionary();
		break;

		//1132
	case group_code::align_group:
		back_input(); cur_tok = cs_token_flag + frozen_cr; print_err(TEX_STRING("Missing "));
		print_esc(TEX_STRING("cr")); 
		print(TEX_STRING(" inserted"));
		help1(TEX_STRING("I'm guessing that you meant to end an alignment here."));
		ins_error();
		break;

		// 1133
	case group_code::no_align_group:
		end_graf();
		unsave();
		align_peek();
		break;
		//1168
	case group_code::vcenter_group:
		end_graf();
		unsave();
		save_ptr -= 2;
		p = vpack(link(head), saved(1), saved(0)); pop_nest(); tail_append(new_noad()); type(tail) = vcenter_noad;
		math_type(nucleus(tail)) = sub_box; info(nucleus(tail)) = p;
		break;
		//1173
	case group_code::math_choice_group:
		build_choices();
		break;
		//1186
	case group_code::math_group:
		unsave(); decr(save_ptr);
		math_type(saved(0)) = sub_mlist; p = fin_mlist(null); info(saved(0)) = p;
		if(p!=null)
			if(link(p)==null)
				if (type(p) == ord_noad) {
					if(math_type(subscr(p))==empty)
						if (math_type(supscr(p)) == empty) {
							mem[saved(0)].union_t.hh = mem[nucleus(p)].union_t.hh; free_node(p, noad_size);
						}
				}
				else if(type(p) == accent_noad)
					if(saved(0) == nucleus(tail))
						if (type(tail) == ord_noad) 
							#pragma region <Replace the tail of the list by p 1187>
						{
							q = head;
							while (link(q) != tail) q = link(q);
							link(q) = p; free_node(tail, noad_size); tail = p;
						}
							#pragma endregion
						
		break;
	#pragma endregion
	default:
		confusion(TEX_STRING("rightbrace"));
		break;
	}
}

//131
//init

void sort_avail()
{
	pointer p, q, r;
	pointer old_rover;

	p = get_node(010000000000);
	p = rlink(rover); rlink(rover) = max_halfword; old_rover = rover;
	while (p != old_rover) 
		#pragma region <Sort p into the list starting at rover and advance p to rlink(p) 132>
	{
		if (p < rover) {
			q = p; p = rlink(q); rlink(q) = rover; rover = q;
		}
		else {
			q = rover;
			while (rlink(q) < p) q = rlink(q);
			
			r = rlink(p); rlink(p) = rlink(q); rlink(q) = p; p = r;
		}
	}
		#pragma endregion

	p = rover;
	while (rlink(p) != max_halfword) {
		llink(rlink(p)) = p; p = rlink(p);
	}
	rlink(p) = rover; llink(rover) = p;
}

//tini


// 264
//init
void primitive(str_number s, quarterword c, halfword o)
{
	pool_pointer k;
	small_number j;
	small_number l;
	if (s < 256) {
		cur_val = s + single_base;
	}
	else {
		k = str_start[s]; l = str_start[s + 1] - k;
		for (j = 0; j <= l - 1; j++)
			buffer[j] = so(str_pool[k + j]);
		cur_val = id_lookup(0, l);
		flush_string; text(cur_val) = s;
	}
	eq_level(cur_val) = level_one; eq_type(cur_val) = c; equiv(cur_val) = o;
}
//tini

// 534
void open_log_file()
{
	unsigned int old_setting;
	int k;
	int l;
	char months[37]; // 1..36
	old_setting = selector;
	if (job_name == 0) job_name = TEX_STRING("texput");
	pack_job_name(TEX_STRING(".log"));
	while (!a_open_out(&log_file)) 
		#pragma region <Try to get a different log file name 535>
	{
		
		selector = term_only; prompt_file_name(TEX_STRING("transcript file name"),
			TEX_STRING(".log"));

	}
		#pragma endregion

	log_name = a_make_name_string(log_file); selector = log_only; log_opened = true;


	#pragma region <Print the banner line, including the date and time 536>
	wlog_s(banner); slow_print(format_ident); print(TEX_STRING("  "));
	print_int(day); print_char(TEX_STRING(" "));
	strcpy(months, "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC");
	months[36] = 0;
	for (k = 3 * month - 2; k <= 3 * month; k++) wlog_c(months[k-1]);
	print_char(TEX_STRING(" "));
	print_int(year); print_char(TEX_STRING(" "));
	print_two(time / 60); print_char(TEX_STRING(":"));
	print_two(time % 60);
	#pragma endregion

	input_stack[input_ptr] = cur_input;
	print_nl(TEX_STRING("**")); l = input_stack[0].limit_field;
	if (buffer[l] == end_line_char)
		decr(l);
	for (k = 1; k <= l; k++)
		print(buffer[k]);
	print_ln();
	selector = old_setting + 2;
	
}

// 525
str_number make_name_string()
{
	int k;
	if (pool_ptr + name_length > pool_size || str_ptr == max_strings || cur_length > 0)
		return TEX_STRING("?");
	else {
		for (k = 1; k <= name_length; k++) append_char(xord[name_of_file[k]]);
		return make_string();
	}
}

str_number a_make_name_string(alpha_file f)
{
	return make_name_string();
}
str_number b_make_name_string(byte_file f)
{
	return make_name_string();
}
str_number w_make_name_string(word_file f)
{
	return make_name_string();
}


// 679
void append_to_vlist(pointer b)
{
	scaled d;
	pointer p;
	if (prev_depth > ignore_depth) {
		d = width(baseline_skip) - prev_depth - height(b);
		if (d < line_skip_limit) p = new_param_glue(line_skip_code);
		else {
			p = new_skip_param(baseline_skip_code);
			width(temp_ptr) = d;
		}
		link(tail) = p; tail = p;
	}
	link(tail) = b; tail = b; prev_depth = depth(b);
}


// 699
void print_size(int s)
{
	if (s == text_size) print_esc(TEX_STRING("textfont"));
	else if (s == script_size) print_esc(TEX_STRING("scriptfont"));
	else print_esc(TEX_STRING("scriptscriptfont"));
}

void initialize()
{
	//int i;
	int k;
	hyph_pointer z;
	// 21,24
	setup_char_arrays();
	//74
	interaction = error_stop_mode;
	
	// 77
	deletions_allowed = true;
	set_box_allowed = true;
	error_count = 0;

	// 80
	help_ptr = 0;
	use_err_help = false;

	// 97
	interrupt = 0;
	OK_to_interrupt = true;

	// 166
	//debug
	was_mem_end = mem_min;
	was_lo_max = mem_min;
	was_hi_min = mem_max;
	panicking = false;
	//gubed

	// 215
	nest_ptr = 0; max_nest_stack = 0; mode = vmode; head = contrib_head; tail = contrib_head;
	prev_depth = ignore_depth; mode_line = 0; prev_graf = 0; shown_mode = 0;

	#pragma region Start a new current page 991>
	page_contents = empty; page_tail = page_head; link(page_head) = null;
	last_glue = max_halfword; last_penalty = 0; last_kern = 0; page_depth = 0; page_max_depth = 0;
	#pragma endregion


	// 254
	for (k = int_base; k <= eqtb_size; k++)
		xeq_level[k] = level_one;

	// 257
	no_new_control_sequence = true;
	next(hash_base) = 0; text(hash_base) = 0;
	for (k = hash_base + 1; k <= undefined_control_sequence - 1; k++)
		hash[k] = hash[hash_base];

	// 272
	save_ptr = 0; cur_level = level_one; cur_group = bottom_level; cur_boundary = 0;
	max_save_stack = 0;

	// 287
	mag_set = 0;


	// 383
	top_mark = null; first_mark = null; bot_mark = null; split_first_mark = null;
	split_bot_mark = null;

	// 439
	cur_val = 0; cur_val_level = int_val; radix = 0; cur_order = normal;

	// 481
	for (k = 0; k <= 16; k++)
		read_open[k] = closed;

	// 490
	cond_ptr = null;
	if_limit = normal; cur_if = 0; if_line = 0;

	// 521
	strcpy(TEX_format_default.get_c_str(),"plain.fmt");

	// 551
	for (k = font_base; k <= font_max; k++)
		font_used[k] = false;

	// 556
	null_character.b0 = min_quarterword; null_character.b1 = min_quarterword;
	null_character.b2 = min_quarterword; null_character.b3 = min_quarterword;


	// 593
	total_pages = 0; max_v = 0; max_h = 0; max_push = 0; last_bop = -1; doing_leaders = false;
	dead_cycles = 0; cur_s = -1;

	// 596
	half_buf = dvi_buf_size / 2; dvi_limit = dvi_buf_size; dvi_ptr = 0; dvi_offset = 0;
	dvi_gone = 0;


	// 606
	down_ptr = null; right_ptr = null;

	// 648
	adjust_tail = null; last_badness = 0;

	// 662
	pack_begin_line = 0;

	// 685
	empty_field.rh = empty; empty_field.union_t.lh = null;
	null_delimiter.b0 = 0; null_delimiter.b1 = min_quarterword;
	null_delimiter.b2 = 0; null_delimiter.b3 = min_quarterword;

	// 771
	align_ptr = null; cur_align = null; cur_span = null; cur_loop = null;
	cur_head = null; cur_tail = null;

	// 928
	for (z = 0; z <= hyph_size; z++) {
		hyph_word[z] = 0; hyph_list[z] = null;
	}
	hyph_count = 0;

	// 990
	output_active = false;
	insert_penalties = 0;

	// 1033
	ligature_present = false;
	cancel_boundary = false;
	lft_hit = false;
	rt_hit = false;
	ins_disc = false;


	// 1267
	after_token = 0;

	// 1282
	long_help_seen = false;

	// 1300
	format_ident = 0;

	// 1343
	for (k = 0; k <= 17; k++)
		write_open[k] = false;


	#pragma region <initialize table entry done by INITEX only 164>
	// init

	// 164
	for (k = mem_bot + 1; k <= lo_mem_stat_max; k++) {
		mem[k].sc = 0;
	}
	k = mem_bot;
	while (k <= lo_mem_stat_max) {
		glue_ref_count(k) = null + 1;
		stretch_order(k) = normal;
		shrink_order(k) = normal;
		k = k + glue_spec_size;
	}
	stretch(fil_glue) = unity; stretch_order(fil_glue) = fil;
	stretch(fill_glue) = unity; stretch_order(fill_glue) = fill;
	stretch(ss_glue) = unity; stretch_order(ss_glue) = fil;
	shrink(ss_glue) = unity; shrink_order(ss_glue) = fil;
	stretch(fil_neg_glue) = -unity; stretch_order(fil_neg_glue) = fil;
	rover = lo_mem_stat_max + 1; link(rover) = empty_flag;
	node_size(rover) = 1000;
	llink(rover) = rover; rlink(rover) = rover;
	lo_mem_max = rover + 1000; link(lo_mem_max) = null; info(lo_mem_max) = null;
	for (k = hi_mem_stat_min; k <= mem_top; k++) mem[k] = mem[lo_mem_max];

	#pragma region	<Initialize the special list heads and constant nodes 790>
	info(omit_template) = end_template_token;
	//797
	link(end_span) = max_quarterword + 1; info(end_span) = null;

	//820
	type(last_active) = hyphenated; line_number(last_active) = max_halfword;
	subtype(last_active) = 0;

	//981
	subtype(page_ins_head) = qi(255); type(page_ins_head) = split_up;
	link(page_ins_head) = page_ins_head;

	//988
	type(page_head) = glue_node; subtype(page_head) = normal;
	#pragma endregion

	avail = null; mem_end = mem_top; hi_mem_min = hi_mem_stat_min;
	var_used = lo_mem_stat_max + 1 - mem_bot; dyn_used = hi_mem_stat_usage;

	//222
	eq_type(undefined_control_sequence) = undefined_cs;
	equiv(undefined_control_sequence) = null;
	eq_level(undefined_control_sequence) = level_zero;
	for (k = active_base; k <= undefined_control_sequence - 1; k++) eqtb[k] = eqtb[undefined_control_sequence];

	// 228
	equiv(glue_base) = zero_glue; eq_level(glue_base) = level_one; eq_type(glue_base) = glue_ref;
	for (k = glue_base + 1; k <= local_base - 1; k++) eqtb[k] = eqtb[glue_base];
	glue_ref_count(zero_glue) = glue_ref_count(zero_glue) + local_base - glue_base;

	par_shape_ptr = null; eq_type(par_shape_loc) = shape_ref; eq_level(par_shape_loc) = level_one;
	for (k = output_routine_loc; k <= toks_base + 255; k++) eqtb[k] = eqtb[undefined_control_sequence];
	box(0) = null; eq_type(box_base) = box_ref; eq_level(box_base) = level_one;
	for (k = box_base + 1; k <= box_base + 255; k++) eqtb[k] = eqtb[box_base];
	cur_font = null_font; eq_type(cur_font_loc) = data; eq_level(cur_font_loc) = level_one;
	for (k = math_font_base; k <= math_font_base + 47; k++) eqtb[k] = eqtb[cur_font_loc];
	equiv(cat_code_base) = 0; eq_type(cat_code_base) = data; eq_level(cat_code_base) = level_one;
	for (k = cat_code_base + 1; k <= int_base - 1; k++) eqtb[k] = eqtb[cat_code_base];
	for (k = 0; k <= 255; k++) {
		cat_code(k) = other_char; math_code(k) = hi(k); sf_code(k) = 1000;
	}
	cat_code(carriage_return) = car_ret; cat_code(TEX_STRING(" ")) = spacer;
	cat_code(TEX_STRING("\")) = escape;
	cat_code(TEX_STRING("%")) = comment; cat_code(invalid_code) = invalid_char;
	cat_code(null_code) = ignore;
	for (k = TEX_STRING("0");
		k <= TEX_STRING("9"); k++) math_code(k) = hi(k + var_code);
	for (k = TEX_STRING("A");
		k <= TEX_STRING("Z"); k++) {
		cat_code(k) = letter; 
		cat_code(k + TEX_STRING("a") -
			                            TEX_STRING("A")) = letter;
		math_code(k) = hi(k + var_code + 0x100);
		math_code(k + TEX_STRING("a") -
			TEX_STRING("A")) = 
			hi(k + TEX_STRING("a") -
				TEX_STRING("A") + var_code + 0x100);
		lc_code(k) = k + TEX_STRING("a") - 
			TEX_STRING("A");
		lc_code(k + TEX_STRING("a") - 
			TEX_STRING("A")) = k + 
			TEX_STRING("a") - 
			TEX_STRING("A");
		uc_code(k) = k; uc_code(k + TEX_STRING("a") - 
			TEX_STRING("A")) = k;
		sf_code(k) = 999;
	}

	// 240
	for (k = int_base; k <= del_code_base - 1; k++) eqtb[k].union_t.an_int = 0;
	mag = 1000; tolerance = 10000; hang_after = 1; max_dead_cycles = 25;
	escape_char = TEX_STRING("\");
	end_line_char = carriage_return;
	for (k = 0; k <= 255; k++) del_code(k) = -1;
	del_code(TEX_STRING(".")) = 0;

	//250
	for (k = dimen_base; k <= eqtb_size; k++) eqtb[k].sc = 0;

	//258
	hash_used = frozen_control_sequence;
	cs_count = 0;
	eq_type(frozen_dont_expand) = dont_expand;
	text(frozen_dont_expand) = TEX_STRING("notexpanded:");

	// 552
	font_ptr = null_font; fmem_ptr = 7; font_name[null_font] = TEX_STRING("nullfont");
	font_area[null_font] = TEX_STRING("");
	hyphen_char[null_font] = TEX_STRING("-"); skew_char[null_font] = -1;
	bchar_label[null_font] = non_address;
	font_bchar[null_font] = non_char; font_false_bchar[null_font] = non_char;
	font_bc[null_font] = 1;
	font_ec[null_font] = 0; font_size[null_font] = 0; font_dsize[null_font] = 0;
	char_base[null_font] = 0;
	width_base[null_font] = 0; height_base[null_font] = 0; depth_base[null_font] = 0;
	italic_base[null_font] = 0; lig_kern_base[null_font] = 0; kern_base[null_font] = 0;
	exten_base[null_font] = 0; font_glue[null_font] = null; font_params[null_font] = 7;
	param_base[null_font] = -1;
	for (k = 0; k <= 6; k++) font_info[k].sc = 0;

	//946
	for (k = -trie_op_size; k <= trie_op_size; k++) trie_op_hash[k] = 0;
	for (k = 0; k <= 255; k++) trie_used[k] = min_quarterword;
	trie_op_ptr = 0;

	// 951
	trie_not_ready = true; trie_root = 0; trie_c[0] = si(0); trie_ptr = 0;

	//1216
	text(frozen_protection) = TEX_STRING("inaccessible");

	//1301
	format_ident = TEX_STRING(" (INITEX)");

	//1369
	text(end_write) = TEX_STRING("endwrite"); eq_level(end_write) = level_one; eq_type(end_write) = outer_call;
	equiv(end_write) = null;


//tini
	#pragma endregion

}


// 694
void print_style(int c)
{
	switch (c / 2) {
	case 0: print_esc(TEX_STRING("displaystyle")); break;
	case 1: print_esc(TEX_STRING("textstyle")); break;
	case 2: print_esc(TEX_STRING("scriptstyle")); break;
	case 3: print_esc(TEX_STRING("scriptscriptstyle")); break;
	default: print(TEX_STRING("Unknown style!")); break;
	}
}

// 82
void error()
{
	ASCII_code c;
	int s1, s2, s3, s4;

	if (history < error_message_issued)
		history = error_message_issued;
	print_char(TEX_STRING("."));
	show_context();
	if (interaction == error_stop_mode) 
		#pragma region <get users advise and return 83>
		while (1) {
mycontinue:
			clear_for_error_prompt();
			prompt_input(TEX_STRING("? "));
			if (last == first)
				return;
			c = buffer[first];
			if (c >= TEX_STRING("a")) c = c + TEX_STRING("A") -	TEX_STRING("a");
			#pragma region <Interpret code c and return if done 84>
			switch (c) {
				case TEX_STRING("0"):
				case TEX_STRING("1"):
				case TEX_STRING("2"):
				case TEX_STRING("3"):
				case TEX_STRING("4"):
				case TEX_STRING("5"):
				case TEX_STRING("6"):
				case TEX_STRING("7"):
				case TEX_STRING("8"):
				case TEX_STRING("9"):
					if (deletions_allowed)
						#pragma region <Delete c - character 0 tokens and goto continue 88>
					{
						
						s1 = cur_tok; s2 = cur_cmd; s3 = cur_chr; s4 = align_state; align_state = 1000000;
						OK_to_interrupt = false;
						if (last > first + 1 && buffer[first + 1] >= TEX_STRING("0") && buffer[first + 1] <=
							TEX_STRING("9"))
							c = c * 10 + buffer[first + 1] - TEX_STRING("0") * 11;
						else
							c = c - TEX_STRING("0");
						while (c > 0) {
							get_token();
							decr(c);
						}
						cur_tok = s1; cur_cmd = s2; cur_chr = s3; align_state = s4; OK_to_interrupt = true;
						help2(TEX_STRING("I have just deleted some text, as you asked."),
							TEX_STRING("You can now delete more, or insert, or whatever."));
						show_context();
						goto mycontinue;
					}
						#pragma endregion
					break;

					//debug
				case TEX_STRING("D"):
					debug_help();
					goto mycontinue;
					break;
					//gubed

				case TEX_STRING("E"):
					if (base_ptr > 0) {
						print_nl(TEX_STRING("You want to edit file "));
						slow_print(input_stack[base_ptr].name_field);
						print(TEX_STRING(" at line ")); print_int(line);
						interaction = scroll_mode;
						jump_out();
					}
					break;
				case TEX_STRING("H"):
					#pragma region <Print help information and continue 89>
					if (use_err_help) {
						give_err_help();
						use_err_help = false;
					}
					else {
						if (help_ptr == 0)
							help2(TEX_STRING("Sorry, I don't know how to help in this situation."),
								TEX_STRING("Maybe you should try asking a human?"));
						do {
							decr(help_ptr);
							print(help_line[help_ptr]); print_ln();
						} while (help_ptr != 0);
					}
					help4(TEX_STRING("Sorry, I already gave what help I could..."),
						TEX_STRING("Maybe you should try asking a human?"),
						TEX_STRING("An error might have occurred before I noticed any problems."),
						TEX_STRING("``If all else fails, read the instructions.''"));
					goto mycontinue;
					#pragma endregion
					break;
				case TEX_STRING("I"):
					#pragma region <Introduce new material from the terminal and return 87>
					begin_file_reading();
					if (last > first + 1) {
						loc = first + 1;
						buffer[first] = TEX_STRING(" ");
					}
					else {
						prompt_input(TEX_STRING("insert>")); loc = first;
					}
					first = last; cur_input.limit_field = last - 1;
					return;
					#pragma endregion
					break;
				case TEX_STRING("Q"):
				case TEX_STRING("R"):
				case TEX_STRING("S"):
					#pragma region <Change the interaction level and return 86>
					error_count = 0;
					interaction = batch_mode + c - TEX_STRING("Q");
					print(TEX_STRING("OK, entering "));
					switch (c) {
						case TEX_STRING("Q"):
							print_esc(TEX_STRING("batchmode"));
							decr(selector);
							break;
						case TEX_STRING("R"):
							print_esc(TEX_STRING("nonstopmode"));
							break;
						case TEX_STRING("S"):
							print_esc(TEX_STRING("scrollmode"));
							break;
					}
					print(TEX_STRING("...")); print_ln();
					update_terminal();
					return;
					#pragma endregion
					break;
				case TEX_STRING("X"):
					interaction = scroll_mode;
					jump_out();
					break;
				default:
					break;
			}

			#pragma region <Print the menu of available options 85>
			{
				print(TEX_STRING("Type <return> to proceed, S to scroll future error messages,"));
				print_nl(TEX_STRING("R to run without stopping, Q to run quietly,"));
				print_nl(TEX_STRING("I to insert something, "));
				if (base_ptr > 0)
					print(TEX_STRING("E to edit your file,"));
				if (deletions_allowed)
					print_nl(TEX_STRING("1 or ... or 9 to ignore the next 1 to 9 tokens of input,"));
				print_nl(TEX_STRING("H for help, X to quit."));
			}
			#pragma endregion

			#pragma endregion
		}
		#pragma endregion

	incr(error_count);
	if (error_count == 100) {
		print_nl(TEX_STRING("(That makes 100 errors; please try again.)"));
		history = fatal_error_stop;
		jump_out();
	}
	#pragma region <Put help message on the transcript file 90>
	if (interaction > batch_mode) decr(selector);
	if (use_err_help) {
		print_ln(); give_err_help();
	}
	else
		while (help_ptr > 0) {
			decr(help_ptr); print_nl(help_line[help_ptr]);
		}
	print_ln();
	if (interaction > batch_mode) incr(selector);
	print_ln();
	#pragma endregion


}


// 91
void int_error(int n)
{
	print(TEX_STRING(" ("));
	print_int(n);
	print_char(TEX_STRING(")"));
	error();
}

// 204
pointer copy_node_list(pointer p)
{
	pointer h;
	pointer q;
	pointer r;
	unsigned char words; // 0..5

	h = get_avail(); q = h;
	while (p != null) {
		#pragma region <Make a copy of node p in node r 205>
		words = 1;
		if (is_char_node(p)) r = get_avail();
		else 
			#pragma region <Case statement to copy different types and set words to the number of initial words not yet copied 206>
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case unset_node:
				r = get_node(box_node_size); mem[r + 6] = mem[p + 6];
				mem[r + 5] = mem[p + 5];
				list_ptr(r) = copy_node_list(list_ptr(p));
				words = 5;
				break;
			case rule_node:
				r = get_node(rule_node_size); words = rule_node_size;
				break;
			case ins_node:
				r = get_node(ins_node_size); mem[r + 4] = mem[p + 4]; add_glue_ref(split_top_ptr(p));
				ins_ptr(r) = copy_node_list(ins_ptr(p));
				words = ins_node_size - 1;
				break;
			case whatsit_node:
				#pragma region <Make a partial copy of whatsit node p and make r point to it; set words.. 1357>
				switch (subtype(p)) {
				case open_node:
					r = get_node(open_node_size); words = open_node_size;
					break;
				case write_node:
				case special_node:
					r = get_node(write_node_size);
					add_token_ref(write_tokens(p));
					words = write_node_size;
					break;
				case close_node:
				case language_node:
					r = get_node(small_node_size); words = small_node_size;
					break;
				default:
					confusion(TEX_STRING("ext2"));
					break;
				}
				#pragma endregion
				break;
			case glue_node:
				r = get_node(small_node_size); add_glue_ref(glue_ptr(p)); glue_ptr(r) = glue_ptr(p);
				leader_ptr(r) = copy_node_list(leader_ptr(p));
				break;
			case kern_node:
			case math_node:
			case penalty_node:
				r = get_node(small_node_size); words = small_node_size;
				break;
			case ligature_node:
				r = get_node(small_node_size); mem[lig_char(r)] = mem[lig_char(p)];
				lig_ptr(r) = copy_node_list(lig_ptr(p));
				break;
			case disc_node:
				r = get_node(small_node_size); pre_break(r) = copy_node_list(pre_break(p));
				post_break(r) = copy_node_list(post_break(p));
				break;
			case mark_node:
				r = get_node(small_node_size); add_token_ref(mark_ptr(p));
				words = small_node_size;
				break;
			case adjust_node:
				r = get_node(small_node_size); adjust_ptr(r) = copy_node_list(adjust_ptr(p));
				break;
			default:
				confusion(TEX_STRING("copying"));
				break;
			}
			#pragma endregion

		while (words > 0) {
			decr(words); mem[r + words] = mem[p + words];
		}
		#pragma endregion
		link(q) = r; q = r; p = link(p);
	}
	link(q) = null; q = link(h); free_avail(h); 
	return q;
}

// 225
void print_skip_param(int n)
{
	switch (n) {
	case line_skip_code:
		print_esc(TEX_STRING("lineskip"));
		break;
	case baseline_skip_code:
		print_esc(TEX_STRING("baselineskip"));
		break;
	case par_skip_code:
		print_esc(TEX_STRING("parskip"));
		break;
	case above_display_skip_code:
		print_esc(TEX_STRING("abovedisplayskip"));
		break;
	case below_display_skip_code:
		print_esc(TEX_STRING("belowdisplayskip"));
		break;
	case above_display_short_skip_code:
		print_esc(TEX_STRING("abovedisplayshortskip"));
		break;
	case below_display_short_skip_code:
		print_esc(TEX_STRING("belowdisplayshortskip"));
		break;
	case left_skip_code:
		print_esc(TEX_STRING("leftskip"));
		break;
	case right_skip_code:
		print_esc(TEX_STRING("rightskip"));
		break;
	case top_skip_code:
		print_esc(TEX_STRING("topskip"));
		break;
	case split_top_skip_code:
		print_esc(TEX_STRING("splittopskip"));
		break;
	case tab_skip_code:
		print_esc(TEX_STRING("tabskip"));
		break;
	case space_skip_code:
		print_esc(TEX_STRING("spaceskip"));
		break;
	case xspace_skip_code:
		print_esc(TEX_STRING("xspaceskip"));
		break;
	case par_fill_skip_code:
		print_esc(TEX_STRING("parfillskip"));
		break;
	case thin_mu_skip_code:
		print_esc(TEX_STRING("thinmuskip"));
		break;
	case med_mu_skip_code:
		print_esc(TEX_STRING("medmuskip"));
		break;
	case thick_mu_skip_code:
		print_esc(TEX_STRING("thickmuskip"));
		break;
	default:
		print(TEX_STRING("[unknown glue parameter!]"));
		break;
	}
}

// 245
void begin_diagnostic()
{
	old_setting = selector;
	if (tracing_online <= 0 && selector == term_and_log) {
		decr(selector);
		if (history == spotless)
			history = warning_issued;
	}
}
void end_diagnostic(bool blank_line)
{
	print_nl(TEX_STRING(""));
	if (blank_line)
		print_ln();
	selector = old_setting;
}


// 262
void print_cs(int p)
{
	if (p < hash_base)
		if (p >= single_base)
			if (p == null_cs) {
				print_esc(TEX_STRING("csname"));
				print_esc(TEX_STRING("endcsname"));
				print_char(TEX_STRING(" "));
			}
			else {
				print_esc(p - single_base);
				if (cat_code(p - single_base) == letter)
					print_char(TEX_STRING(" "));
			}

		else if (p < active_base) print_esc(TEX_STRING("IMPOSSIBLE."));
		else print(p - active_base);

	else if (p >= undefined_control_sequence)
		print_esc(TEX_STRING("IMPOSSIBLE."));
	else if (text(p) < 0 || text(p) >= str_ptr) print_esc(TEX_STRING("NONEXISTENT."));
	else {
		print_esc(text(p));
		print_char(TEX_STRING(" "));
	}
}

// 288
void prepare_mag()
{
	if (mag_set > 0 && mag != mag_set) {
		print_err(TEX_STRING("Incompatible magnification ("));
		print_int(mag);
		print(TEX_STRING(");"));
		print_nl(TEX_STRING(" the previous value will be retained"));
		help2(TEX_STRING("I can handle only one magnification ratio per job. So I've"),
			TEX_STRING("reverted to the magnification you used earlier on this run."));
		int_error(mag_set); geq_word_define(int_base + mag_code, mag_set);
	}
	if (mag <= 0 || mag > 32768) {
		print_err(TEX_STRING("Illegal magnification has been changed to 1000"));
		help1(TEX_STRING("The magnification ratio must be between 1 and 32768."));
		int_error(mag);
		geq_word_define(int_base + mag_code, 1000);
	}
	mag_set = mag;
}

// 379
void insert_relax()
{
	cur_tok = cs_token_flag + cur_cs;
	back_input();
	cur_tok = cs_token_flag + frozen_relax;
	back_input();
	token_type = inserted;
}




// 464
pointer str_toks(pool_pointer b)
{
	pointer p;
	pointer q;
	halfword t;
	pool_pointer k;

	str_room(1); p = temp_head; link(p) = null; k = b;
	while (k < pool_ptr) {
		t = so(str_pool[k]);
		if (t == TEX_STRING(" "))
			t = space_token;
		else t = other_token + t;
		store_new_token(t); incr(k);
	}
	pool_ptr = b; 
	return p;
}

// 405
void scan_optional_equals()
{
	#pragma region <Get the next non blank non call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_tok != other_token + TEX_STRING("="))
		back_input();
}

// 448
void scan_dimen(bool mu, bool inf, bool shortcut)
{
	bool negative;
	int f;

	#pragma region <Local variables for dimension calculations 450>
	unsigned int num, denom;
	small_number k, kk;
	pointer p, q;
	scaled v;
	int save_cur_val;
	#pragma endregion

	f = 0; arith_error = false; cur_order = normal; negative = false;

	if (!shortcut) {
		#pragma region <Get the next non-blank non-sign token; set negative appropriately 441>
		negative = false;
		do {
			#pragma region <Get the next non-blank non-call token 406>
			do {
				get_x_token();
			} while (!(cur_cmd != spacer));
			#pragma endregion
			if (cur_tok == other_token + TEX_STRING("-")) {
				negative = !negative; cur_tok = other_token + TEX_STRING("+");
			}
		} while (!(cur_tok != other_token + TEX_STRING("+")));
		#pragma endregion
		if (cur_cmd >= min_internal && cur_cmd <= max_internal) 
			#pragma region <Fetch an internal dimension and goto attach_sign, or fetch an internal integer 449>
		{
			if (mu) {
				scan_something_internal(mu_val, false);
				#pragma region <Coerce glue to dimension 451>
				if (cur_val_level >= glue_val) {
					v = width(cur_val); delete_glue_ref(cur_val); cur_val = v;
				}
				#pragma endregion
				if (cur_val_level == mu_val) goto attach_sign;
				if (cur_val_level != int_val) mu_error();
			}
			else {
				scan_something_internal(dimen_val, false);
				if (cur_val_level == dimen_val) goto attach_sign;
			}
		}
			#pragma endregion
		else {
			back_input();
			if (cur_tok == continental_point_token)
				cur_tok = point_token;
			if (cur_tok != point_token)
				scan_int();
			else {
				radix = 10;
				cur_val = 0;
			}
			if (cur_tok == continental_point_token)
				cur_tok = point_token;
			if (radix == 10 && cur_tok == point_token) 
				#pragma region <Scan decimal fraction 452>
			{
				k = 0; p = null; get_token();
				while (1) {
					get_x_token();
					if (cur_tok > zero_token + 9 || cur_tok < zero_token) goto done1;
					if (k < 17) {
						q = get_avail(); link(q) = p; info(q) = cur_tok - zero_token; p = q; incr(k);
					}
				}
			done1:
				for (kk = k; kk >= 1; kk--) {
					if (info(p) > 255) {
						printf("overflow in 452\n");
						exit(1);
					}
					dig[kk - 1] = (unsigned char)info(p); q = p; p = link(p); free_avail(q);
				}
				f = round_decimals(k);
				if (cur_cmd != spacer) back_input();
			}
				#pragma endregion
			
		}
	}
	if (cur_val < 0) {
		negative = !negative; negate(cur_val);
	}

	#pragma region <Scan units and set cur_val to x*(cur_val+f/2^16) wehre there are x sp per unit; goto attach_sign if... 453>
	if (inf)
		#pragma region <Scan for fil units; goto attach_fraction if found 454>
		if (scan_keyword(TEX_STRING("fil"))) {
			cur_order = fil;
			while (scan_keyword(TEX_STRING("l"))) {
				if (cur_order == filll) {
					print_err(TEX_STRING("Illegal unit of measure ("));
					print(TEX_STRING("replaced by filll)"));
					help1(TEX_STRING("I dddon't go any higher than filll.")); error();
				}
				else incr(cur_order);
			}
			goto attach_fraction;
		}
		#pragma endregion

	#pragma region <Scan for units that are internal dimensions; goto attach_sign with cur_val set if found 455>
	save_cur_val = cur_val;
	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_cmd < min_internal || cur_cmd > max_internal) back_input();
	else {
		if (mu) {
			scan_something_internal(mu_val, false);
			#pragma region <Coerce glue to a dimension 451>
			if (cur_val_level >= glue_val) {
				v = width(cur_val); delete_glue_ref(cur_val); cur_val = v;
			}
			#pragma endregion
			if (cur_val_level != mu_val) mu_error();
		}
		else scan_something_internal(dimen_val, false);
		v = cur_val; goto found;
	}
	if (mu) goto not_found;
	if (scan_keyword(TEX_STRING("em")))
		v = quad(cur_font);
	else if (scan_keyword(TEX_STRING("ex")))
		v = x_height(cur_font);
	else goto not_found;

	#pragma region <Scan an optional space 443>
	get_x_token();
	if (cur_cmd != spacer)
		back_input();
	#pragma endregion
found:
		 cur_val = nx_plus_y(save_cur_val, v, xn_over_d(v, f, 0200000)); goto attach_sign;
not_found:

	#pragma endregion

	if (mu)
		#pragma region <Scan for mu units and goto attach_fraction 456>
	if (scan_keyword(TEX_STRING("mu"))) goto attach_fraction;
	else {
		print_err(TEX_STRING("Illegal unit of measure ("));
		print(TEX_STRING("mu inserted)"));
		help4(TEX_STRING("The unit of measurement in math glue must be mu."),
			TEX_STRING("To recover gracefully from this error, it's best to"),
			TEX_STRING("delete the erroneous units; e.g., type `2' to delete"),
			TEX_STRING("two letters. (See Chapter 27 of The TeXbook.)"));
		error(); goto attach_fraction;
	}
		#pragma endregion

	if (scan_keyword(TEX_STRING("true")))
		#pragma region <Adjust for magnification ratio 457>
	{
		prepare_mag();
		if (mag != 1000) {
			cur_val = xn_over_d(cur_val, 1000, mag); f = (1000 * f + 0200000 * _remainder) / mag;
			cur_val = cur_val + (f / 0200000); f = f % 0200000;
		}
	}
		#pragma endregion

	if (scan_keyword(TEX_STRING("pt"))) goto attach_fraction;

	#pragma region <Scan for all other units and adjust cur_val... 458>
	if (scan_keyword(TEX_STRING("in"))) set_conversion(7227, 100);
	else if (scan_keyword(TEX_STRING("pc"))) set_conversion(12, 1);
	else if (scan_keyword(TEX_STRING("cm"))) set_conversion(7227, 254);
	else if (scan_keyword(TEX_STRING("mm"))) set_conversion(7227, 2540);
	else if (scan_keyword(TEX_STRING("bp"))) set_conversion(7227, 7200);
	else if (scan_keyword(TEX_STRING("dd"))) set_conversion(1238, 1157);
	else if (scan_keyword(TEX_STRING("cc"))) set_conversion(14856, 1157);
	else if (scan_keyword(TEX_STRING("sp"))) goto done;
	else
		#pragma region <Complain about unknown unit and goto done2 459>
	{
		print_err(TEX_STRING("Illegal unit of measure ("));
		print(TEX_STRING("pt inserted)"));
		help6(TEX_STRING("Dimensions can be in units of em, ex, in, pt, pc,"),
			TEX_STRING("cm, mm, dd, cc, bp, or sp; but yours is a new one!"), 
			TEX_STRING("I'll assume that you meant to say pt, for printer's points."), 
			TEX_STRING("To recover gracefully from this error, it's best to"), 
			TEX_STRING("delete the erroneous units; e.g., type `2' to delete"), 
			TEX_STRING("two letters. (See Chapter 27 of The TeXbook.)"));		
		error();
		goto done2;
	}
		#pragma endregion

	cur_val = xn_over_d(cur_val, num, denom); f = (num*f + 0200000 * _remainder) / denom;
	cur_val = cur_val + (f / 0200000); f = f % 0200000;
done2:

	#pragma endregion

attach_fraction:
	if (cur_val >= 040000) arith_error = true;
	else cur_val = cur_val * unity + f;
done:


#pragma endregion

	#pragma region <Scan an optional space 443>
		 get_x_token();
		 if (cur_cmd != spacer)
			 back_input();
	#pragma endregion


attach_sign:
	if (arith_error || abs(cur_val) >= 010000000000)
		#pragma region <Report that this dimension is out of range 460>
	{
		print_err(TEX_STRING("Dimension too large"));
		help2(TEX_STRING("I can't work with sizes bigger than about 19 feet."),
			TEX_STRING("Continue and I'll use the largest value I can."));
		error();
		cur_val = max_dimen; arith_error = false;
	}
		#pragma endregion
	if (negative)
		negate(cur_val);
}

// 461
void scan_glue(small_number level)
{
	bool negative;
	pointer q;
	bool mu;

	mu = (level == mu_val);
	#pragma region <Get the next non-blank non-sign token; set negative appropriately 441>
	negative = false;
	do {
		#pragma region <Get the next non-blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion
		if (cur_tok == other_token + TEX_STRING("-")) {
			negative = !negative; cur_tok = other_token + TEX_STRING("+");
		}
	} while (!(cur_tok != other_token + TEX_STRING("+")));
	#pragma endregion
	if (cur_cmd >= min_internal && cur_cmd <= max_internal) {
		scan_something_internal(level, negative);
		if (cur_val_level >= glue_val) {
			if (cur_val_level != level) mu_error();
			return;
		}
		if (cur_val_level == int_val) scan_dimen(mu, false, true);
		else if (level == mu_val) mu_error();
	}
	else {
		back_input(); scan_dimen(mu, false, false);
		if (negative) negate(cur_val);
	}
	#pragma region <Create a new glue specification whose width is cur_val; scan for its stretch and shrink components 462>
	q = new_spec(zero_glue); width(q) = cur_val;
	if (scan_keyword(TEX_STRING("plus"))) {
		scan_dimen(mu, true, false); stretch(q) = cur_val; stretch_order(q) = cur_order;
	}
	if (scan_keyword(TEX_STRING("minus"))) {
		scan_dimen(mu, true, false); shrink(q) = cur_val; shrink_order(q) = cur_order;
	}
	cur_val = q;
	#pragma endregion

}

//1229
void trap_zero_glue()
{
	if (width(cur_val) == 0 && stretch(cur_val) == 0 && shrink(cur_val) == 0) {
		add_glue_ref(zero_glue); delete_glue_ref(cur_val); cur_val = zero_glue;
	}
}

// 465
pointer the_toks()
{
	unsigned int old_setting;
	pointer p, q, r;
	pool_pointer b;

	get_x_token();
	scan_something_internal(tok_val, false);
	if (cur_val_level >= ident_val) 
		#pragma region <Copy the token list 466>
	{
		p = temp_head; link(p) = null;
		if (cur_val_level == ident_val)
			store_new_token(cs_token_flag + cur_val);
		else if (cur_val != null) {
			r = link(cur_val);
			while (r != null) {
				store_new_token(info(r)); r = link(r);
			}
		}
		return p;
	}
		#pragma endregion
	else {
		old_setting = selector; selector = new_string; b = pool_ptr;
		switch (cur_val_level) {
		case int_val:
			print_int(cur_val);
			break;
		case dimen_val:
			print_scaled(cur_val); print(TEX_STRING("pt"));
			break;
		case glue_val:
			print_spec(cur_val, TEX_STRING("pt")); delete_glue_ref(cur_val);
			break;
		case mu_val:
			print_spec(cur_val, TEX_STRING("mu")); delete_glue_ref(cur_val);
			break;
		}
		selector = old_setting;
		return str_toks(b);
	}
}
// 467
void ins_the_toks()
{
	link(garbage) = the_toks(); ins_list(link(temp_head));
}


// 470
void conv_toks()
{
	unsigned int old_setting;
	int c;
	small_number save_scanner_status;
	pool_pointer b;

	c = cur_chr;
	#pragma region <Scan the argument for command c 471>
	switch (c) {
	case number_code:
	case roman_numeral_code:
		scan_int();
		break;
	case string_code:
	case meaning_code:
		save_scanner_status = scanner_status; scanner_status = normal;
		get_token(); scanner_status = save_scanner_status;
		break;
	case font_name_code:
		scan_font_ident();
		break;
	case job_name_code:
		if (job_name == 0) open_log_file();
		break;
	}
	#pragma endregion

	old_setting = selector; selector = new_string; b = pool_ptr;
	#pragma region <Print the result of command c 472>
	switch (c) {
	case number_code: print_int(cur_val); break;
	case roman_numeral_code: print_roman_int(cur_val); break;
	case string_code:
		if (cur_cs != 0) sprint_cs(cur_cs);
		else print_char((ASCII_code)cur_chr);
		break;
	case meaning_code: print_meaning(); break;
	case font_name_code:
		print(font_name[cur_val]);
		if (font_size[cur_val] != font_dsize[cur_val]) {
			print(TEX_STRING(" at ")); print_scaled(font_size[cur_val]);
			print(TEX_STRING("pt"));
		}
		break;
	case job_name_code: print(job_name); break;
	}
	#pragma endregion

	selector = old_setting; link(garbage) = str_toks(b); ins_list(link(temp_head));
}

// 494
void pass_text()
{
	int l;
	small_number save_scanner_status;

	save_scanner_status = scanner_status; scanner_status = skipping; l = 0; skip_line = line;

	while (1) {
		get_next();
		if (cur_cmd == fi_or_else) {
			if (l == 0) goto done;
			if (cur_chr == fi_code) decr(l);
		}
		else if (cur_cmd == if_test) incr(l);
	}
done: scanner_status = save_scanner_status;
}


// 497
void change_if_limit(small_number l, pointer p)
{
	pointer q;
	if (p == cond_ptr)
		if_limit = l;
	else {
		q = cond_ptr;
		while (1) {
			if (q == null)
				confusion(TEX_STRING("if"));
			if (link(q) == p) {
				type(q) = l;
				return;
			}
			q = link(q);
		}
	}
}

// 498
void conditional()
{
	bool b;
	unsigned char r;
	int m, n;
	pointer p, q;
	small_number save_scanner_status;
	pointer save_cond_ptr;
	small_number this_if;

	#pragma region <Push the condition stack 495>
	p = get_node(if_node_size); link(p) = cond_ptr; type(p) = if_limit;
	subtype(p) = cur_if;
	if_line_field(p) = if_line; cond_ptr = p; cur_if = cur_chr; if_limit = if_code; if_line = line;
	#pragma endregion

	save_cond_ptr = cond_ptr; this_if = cur_chr;
	#pragma region <Either process ifcase or set b to the value of a boolean condition 501>
	switch (this_if) {
	case if_char_code:
	case if_cat_code:
		#pragma region <Test if two characters match 506>
		get_x_token_or_active_char;
		if (cur_cmd > active_char || cur_chr > 255) {
			m = relax; n = 256;
		}
		else {
			m = cur_cmd; n = cur_chr;
		}
		get_x_token_or_active_char;
		if (cur_cmd > active_char || cur_chr > 255) {
			cur_cmd = relax; cur_chr = 256;
		}
		if (this_if == if_char_code) b = (n == cur_chr); else b = (m == cur_cmd);
		#pragma endregion
		break;
	case if_int_code:
	case if_dim_code:
		#pragma region <Test relation between integers or dimensions 503>
		if (this_if == if_int_code) scan_int();
		else scan_normal_dimen;
		n = cur_val;
		#pragma region <Get the next non-blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion
		if (cur_tok >= other_token + TEX_STRING("<") &&
			cur_tok <= other_token + TEX_STRING(">"))
			r = cur_tok - other_token;
		else {
			print_err(TEX_STRING("Missing = inserted for "));
			print_cmd_chr(if_test, this_if);
			help1(TEX_STRING("I was expecting to see `<', `=', or `>'. Didn't."));
			back_error();
			r = TEX_STRING("=");
		}
		if (this_if == if_int_code) scan_int();
		else scan_normal_dimen;
		switch (r) {
		case TEX_STRING("<"): b = (n < cur_val); break;
		case TEX_STRING("="): b = (n == cur_val); break;
		case TEX_STRING(">"): b = (n > cur_val); break;
		}
		#pragma endregion
		break;
	case if_odd_code:
		#pragma region <Test if an integer is odd 504>
		scan_int();
		b = myodd(cur_val);
		#pragma endregion
		break;
	case if_vmode_code: b = (abs(mode) == vmode);
		break;
	case if_hmode_code: b = (abs(mode) == hmode);
		break;
	case if_mmode_code: b = (abs(mode) == mmode);
		break;
	case if_inner_code: b = (mode < 0);
		break;
	case if_void_code:
	case if_hbox_code:
	case if_vbox_code:
		#pragma region <Test box register status 505>
		scan_eight_bit_int(); p = box(cur_val);
		if (this_if == if_void_code) b = (p == null);
		else if (p == null) b = false;
		else if (this_if == if_hbox_code) b = (type(p) == hlist_node);
		else b = (type(p) == vlist_node);
		#pragma endregion
		break;

	case ifx_code:
		#pragma region <Test if two tokens match 507>
		save_scanner_status = scanner_status; scanner_status = normal; get_next(); n = cur_cs;
		p = cur_cmd; q = cur_chr; get_next();
		if (cur_cmd != p) b = false;
		else if (cur_cmd < call) b = (cur_chr == q);
		else
			#pragma region <Test if two macro texts match 508>
		{
			p = link(cur_chr); q = link(equiv(n));
			if (p == q) b = true;
			else {
				while (p != null && q != null)
					if (info(p) != info(q)) p = null;
					else {
						p = link(p); q = link(q);
					}
				b = ((p == null) && (q == null));
			}
		}
			#pragma endregion
		scanner_status = save_scanner_status;
		#pragma endregion
		break;
	case if_eof_code:
		scan_four_bit_int(); b = (read_open[cur_val] == closed);
		break;

	case if_true_code: b = true;
		break;
	case if_false_code: b = false;
		break;
	case if_case_code:
		#pragma region <Select the appropriate case and return or goto common_ending 509>
		scan_int(); n = cur_val;
		if (tracing_commands > 1) {
			begin_diagnostic();
			print(TEX_STRING("{case ")); print_int(n);
			print_char(TEX_STRING("}"));
			end_diagnostic(false);
		}
		while (n != 0) {
			pass_text();
			if (cond_ptr == save_cond_ptr)
				if (cur_chr == or_code) decr(n);
				else goto common_ending;
			else if (cur_chr == fi_code)
				#pragma region <Pop the condition stack 496>
			{
				p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
				cond_ptr = link(p); free_node(p, if_node_size);
			}
				#pragma endregion

		}
		change_if_limit(or_code, save_cond_ptr); return;
		#pragma endregion
		break;
	}

	#pragma endregion
	if (tracing_commands > 1) 
		#pragma region <Display the value of b 502>
	{
		begin_diagnostic();
		if (b) print(TEX_STRING("{true}"));
		else print(TEX_STRING("{false}"));
		end_diagnostic(false);
	}
		#pragma endregion
	
	if (b) {
		change_if_limit(else_code, save_cond_ptr);
		return;
	}

	#pragma region <skip to else or fi then goto common_ending 500>
	while (1) {
		pass_text();
		if (cond_ptr == save_cond_ptr) {
			if (cur_chr != or_code) goto common_ending;
			print_err(TEX_STRING("Extra ")); 
			print_esc(TEX_STRING("or"));
			help1(TEX_STRING("I'm ignoring this; it doesn't match any \if."));
			error();
		}
		else if (cur_chr == fi_code)
			#pragma region <Pop the condition stack 496>
		{
			p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
			cond_ptr = link(p); free_node(p, if_node_size);
		}
			#pragma endregion
	}
	#pragma endregion
common_ending:
	if (cur_chr == fi_code)
		#pragma region <Pop the condition stack 496>
	{
		p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
		cond_ptr = link(p); free_node(p, if_node_size);
	}
		#pragma endregion
	else
		if_limit = fi_code;
}


// 366
void expand()
{
	halfword t;
	pointer p, q, r;
	int j;
	int cv_backup;
	small_number cvl_backup, radix_backup, co_backup;
	pointer backup_backup;
	small_number save_scanner_status;

	cv_backup = cur_val; cvl_backup = cur_val_level; radix_backup = radix;
	co_backup = cur_order;
	backup_backup = link(backup_head);
	if (cur_cmd < call) 
		#pragma region <Expand a nonmacro 367>
	{
		if (tracing_commands > 1) show_cur_cmd_chr();
		switch (cur_cmd) {
		case top_bot_mark:
			#pragma region <Insert the appropriate mark text into the scanner 386>
			if (cur_mark[cur_chr] != null) begin_token_list(cur_mark[cur_chr], mark_text);
			#pragma endregion
			break;
		case expand_after:
			#pragma region <Expand the token after the next token 368>
			get_token(); t = cur_tok; get_token();
			if (cur_cmd > max_command)
				expand();
			else back_input();
			cur_tok = t;
			back_input();
			#pragma endregion
			break;
		case no_expand:
			#pragma region <Suppress expansion of the next token 369>
			save_scanner_status = scanner_status; scanner_status = normal;
			get_token();
			scanner_status = save_scanner_status; t = cur_tok;
			back_input();
			if (t >= cs_token_flag) {
				p = get_avail(); info(p) = cs_token_flag + frozen_dont_expand;
				link(p) = loc;
				start = p;
				loc = p;
			}
			#pragma endregion
			break;
		case cs_name:
			#pragma region <Manufacture a control sequence name 372>
			r = get_avail(); p = r;
			do {
				get_x_token();
				if (cur_cs == 0) store_new_token(cur_tok);
			} while (!(cur_cs != 0));
			if (cur_cmd != end_cs_name) 
				#pragma region <Complain about missing endcsname 373>
			{
				print_err(TEX_STRING("Missing "));
				print_esc(TEX_STRING("endcsname"));
				print(TEX_STRING(" inserted"));
				help2(TEX_STRING("The control sequence marked <to be read again> should"),
					TEX_STRING("not appear between \csname and \endcsname."));
				back_error();
			}
				#pragma endregion

			#pragma region <Look up the characters of list r in the hash table, and set cur_cs 374>
			j = first; p = link(r);
			while (p != null) {
				if (j >= max_buf_stack) {
					max_buf_stack = j + 1;
					if (max_buf_stack == buf_size) overflow(TEX_STRING("buffer size"), buf_size);
				}
				buffer[j] = info(p) % 0400; incr(j); p = link(p);
			}
			if (j > first + 1) {
				no_new_control_sequence = false; cur_cs = id_lookup(first, j - first);
				no_new_control_sequence = true;
			}
			else if (j == first) cur_cs = null_cs;
			else cur_cs = single_base + buffer[first];
			#pragma endregion

			flush_list(r);
			if (eq_type(cur_cs) == undefined_cs) {
				eq_define(cur_cs, relax, 256);
			}
			cur_tok = cur_cs + cs_token_flag; back_input();
			#pragma endregion
			break;
		case convert:
			conv_toks();
			break;
		case the:
			ins_the_toks();
			break;
		case if_test:
			conditional();
			break;
		case fi_or_else:
			#pragma region <Terminate the current conditional and skip to fi 510>
			if (cur_chr > if_limit)
				if (if_limit == if_code) insert_relax();
				else {
					print_err(TEX_STRING("Extra ")); print_cmd_chr(fi_or_else, cur_chr);
					help1(TEX_STRING("I'm ignoring this; it doesn't match any \if."));
					error();
				}
			else {
				while (cur_chr != fi_code) pass_text();
				#pragma region <Pop the condition stack 496>
				p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
				cond_ptr = link(p); free_node(p, if_node_size);
				#pragma endregion
			}
			#pragma endregion
			break;
		case input:
			#pragma region <Initiate or terminate input from a file 378>
			if (cur_chr > 0) force_eof = true;
			else if (name_in_progress) insert_relax();
			else
				start_input();
			#pragma endregion
			break;
		default:
			#pragma region <Complain about an undefined macro 370>
			print_err(TEX_STRING("Undefined control sequence"));
			help5(TEX_STRING("The control sequence at the end of the top line"),
				TEX_STRING("of your error message was never \def'ed. If you have"),
				TEX_STRING("misspelled it (e.g., `\hobx'), type `I' and the correct"),
				TEX_STRING("spelling (e.g., `I\hbox'). Otherwise just continue,"),
				TEX_STRING("and I'll forget about whatever was undefined."));
			error();
			#pragma endregion
			break;
		}
	}
		#pragma endregion
	else if (cur_cmd < end_template) macro_call();
	else 
		#pragma region <Insert a token containing frozen_endv 375>
	{
		cur_tok = cs_token_flag + frozen_endv;
		back_input();
	}
#pragma endregion

	cur_val = cv_backup; cur_val_level = cvl_backup; radix = radix_backup; cur_order = co_backup;
	link(backup_head) = backup_backup;
}

// 389
void macro_call()
{
	pointer r, p, q, s, t, u, v, rbrace_ptr;
	small_number n;
	halfword unbalance;
	halfword m;
	pointer ref_count;
	small_number save_scanner_status;
	pointer save_warning_index;
	ASCII_code match_chr;

	save_scanner_status = scanner_status; save_warning_index = warning_index;
	warning_index = cur_cs; ref_count = cur_chr; r = link(ref_count); n = 0;
	if (tracing_macros > 0) 
		#pragma region <Show the text of the macro being expanded 401>	
	{
		begin_diagnostic();
		print_ln();
		print_cs(warning_index);
		token_show(ref_count);
		end_diagnostic(false);
	}
		#pragma endregion

	if (info(r) != end_match_token) 
		#pragma region <Scan the parameters and make link(r) pont to the macro body;.. 391>
	{
		scanner_status = matching; unbalance = 0; long_state = eq_type(cur_cs);
		if (long_state >= outer_call)
			long_state = long_state - 2;
		do {
			link(temp_head) = null;
			if (info(r) > match_token + 255 || info(r) < match_token)
				s = null;
			else {
				match_chr = info(r) - match_token;
				s = link(r);
				r = s;
				p = temp_head;
				m = 0;
			}
			#pragma region <Scan a parameter until its delimiter string has been found; or if s = null.. 392>
		mycontinue:
			get_token();
			if (cur_tok == info(r)) 
				#pragma region <Advance r; goto found if the parameter delimiter has been fully matched.. 394>
			{
				r = link(r);
				if (info(r) >= match_token && info(r) <= end_match_token) {
					if (cur_tok < left_brace_limit) decr(align_state);
					goto found;
				}
				else goto mycontinue;
			}
				#pragma endregion

			#pragma region <Contribute the recently matched tokens to the current paramter, and goto continue if a partial match... 397>			
			if (s != r)
				if (s == null)
					#pragma region <Report an improper use of teh macro and abort 398>
				{
					print_err(TEX_STRING("Use of "));
					sprint_cs(warning_index);
					print(TEX_STRING(" doesn't match its definition"));
					help4(TEX_STRING("If you say, e.g., `\def\a1{...}', then you must always"),
						TEX_STRING("put `1' after `\a', since control sequence names are"),
						TEX_STRING("made up of letters only. The macro here has not been"),
						TEX_STRING("followed by the required stuff, so I'm ignoring it."));
					error();
					goto _exit;
				}
					#pragma endregion
				else {
					t = s;
					do {
						store_new_token(info(t)); incr(m); u = link(t); v = s;
						while (1) {
							if (u == r)
								if (cur_tok != info(v)) goto done;
								else {
									r = link(v); goto mycontinue;
								}
								if (info(u) != info(v)) goto done;
								u = link(u); v = link(v);
						}
					done: t = link(t);
					} while (!(t == r));
					r = s;
				}

			#pragma endregion
			if (cur_tok == par_token)
				if (long_state != long_call) 
					#pragma region <Report a runaway argument and abort 396>
				{
					if (long_state == call) {
						runaway();
						print_err(TEX_STRING("Paragraph ended before ")); sprint_cs(warning_index);
						print(TEX_STRING(" was complete"));
						help3(TEX_STRING("I suspect you've forgotten a `}', causing me to apply this"),
							TEX_STRING("control sequence to too much text. How can we recover?"),
							TEX_STRING("My plan is to forget the whole thing and hope for the best."));
						back_error();
					}
					pstack[n] = link(temp_head); align_state -= unbalance;
					for (m = 0; m <= n; m++) flush_list(pstack[m]);
					goto _exit;
				}
					#pragma endregion
			if (cur_tok < right_brace_limit)
				if (cur_tok < left_brace_limit) 
					#pragma region <Contribute an entire group to the current paramter 399>
				{

					unbalance = 1;
					while (1) {
						store_new_token(cur_tok); get_token();
						if(cur_tok == par_token)
							if (long_state != long_call)
								#pragma region <Report a runaway argument and abort 396>
							{
								if (long_state == call) {
									runaway();
									print_err(TEX_STRING("Paragraph ended before ")); sprint_cs(warning_index);
									print(TEX_STRING(" was complete"));
									help3(TEX_STRING("I suspect you've forgotten a `}', causing me to apply this"),
										TEX_STRING("control sequence to too much text. How can we recover?"),
										TEX_STRING("My plan is to forget the whole thing and hope for the best."));
									back_error();
								}
								pstack[n] = link(temp_head); align_state -= unbalance;
								for (m = 0; m <= n; m++) flush_list(pstack[m]);
								goto _exit;
							}
								#pragma endregion
						if(cur_tok < right_brace_limit)
							if (cur_tok < left_brace_limit) incr(unbalance);
							else {
								decr(unbalance);
								if (unbalance == 0) goto done1;
							}
					}
				done1: rbrace_ptr = p; store_new_token(cur_tok);
				}
					#pragma endregion
				else
					#pragma region <Report an extra right brace and goto continue 395>
				{
					back_input();
					print_err(TEX_STRING("Argument of "));
					sprint_cs(warning_index);
					print(TEX_STRING(" has an extra }"));
					help6(TEX_STRING("I've run across a `}' that doesn't seem to match anything."),
						TEX_STRING("For example, `\def\a#1{...}' and `\a}' would produce"),
						TEX_STRING("this error. If you simply proceed now, the `\par' that"),
						TEX_STRING("I've just inserted will cause me to report a runaway"),
						TEX_STRING("argument that might be the root of the problem. But if"),
						TEX_STRING("your `}' was spurious, just type `2' and it will go away."));
					incr(align_state);
					long_state = call; cur_tok = par_token;
					ins_error();
					goto mycontinue;
				}
					#pragma endregion
			else 
				#pragma region <Store the current token but goto continue if it is a blank sapce that woudl become an undelmited paramter 393>
			{
				if (cur_tok == space_token)
					if (info(r) <= end_match_token)
						if (info(r) >= match_token)
							goto mycontinue;
				store_new_token(cur_tok);
			}
				#pragma endregion
			
			incr(m);
			if (info(r) > end_match_token)
				goto mycontinue;
			if (info(r) < match_token)
				goto mycontinue;
		found:
			if (s != null) 
				#pragma region <Tidy up the parameter just scanned and tuck it away 400>
			{
				if (m == 1 && info(p) < right_brace_limit && p != temp_head) {
					link(rbrace_ptr) = null; free_avail(p); p = link(temp_head);
					pstack[n] = link(p); free_avail(p);
				}
				else pstack[n] = link(temp_head);
				incr(n);
				if (tracing_macros > 0) {
					begin_diagnostic(); print_nl(match_chr); print_int(n); print(TEX_STRING("<-"));
					show_token_list(pstack[n - 1], null, 1000); end_diagnostic(false);
				}
			}
				#pragma endregion

			#pragma endregion

		} while (!(info(r) == end_match_token));

	}
		#pragma endregion

	#pragma region <Feed the macro body and its parameters to the scanner 390>
	while (state == token_list && loc == null && token_type != v_template)
		end_token_list();
	begin_token_list(ref_count, macro); name = warning_index; loc = link(r);
	if (n > 0) {
		if (param_ptr + n > max_param_stack) {
			max_param_stack = param_ptr + n;
			if (max_param_stack > param_size) overflow(TEX_STRING("parameter stack size"), param_size);
		}
		for (m = 0; m <= n - 1; m++) param_stack[param_ptr + m] = pstack[m];
		param_ptr += n;
	}
	#pragma endregion

_exit:
	scanner_status = save_scanner_status; warning_index = save_warning_index;
}

void get_x_token()
{
restart:
	get_next();
	if (cur_cmd <= max_command)
		goto done;
	if (cur_cmd >= call)
		if (cur_cmd < end_template)
			macro_call();
		else {
			cur_cs = frozen_endv;
			cur_cmd = endv;
			goto done;
		}
	else
		expand();
	goto restart;
done:
	if (cur_cs == 0)
		cur_tok = (cur_cmd * 0400) + cur_chr;
	else
		cur_tok = cs_token_flag + cur_cs;
}

// 944
quarterword new_trie_op(small_number d, small_number n, quarterword v)
{
	int h; //-trie_op_size..trie_op_size
	quarterword u;
	unsigned l; // 0..trie_op_size

	h = abs(n + 313 * d + 361 * v + 1009 * cur_lang) % (trie_op_size + trie_op_size) - trie_op_size;
	while (1) {
		l = trie_op_hash[h];
		if (l == 0) {
			if (trie_op_ptr == trie_op_size) overflow(TEX_STRING("pattern memory ops"), trie_op_size);
			u = trie_used[cur_lang];
			if (u == max_quarterword)
				overflow(TEX_STRING("pattern memory ops per language"), max_quarterword - min_quarterword);
			incr(trie_op_ptr); incr(u); trie_used[cur_lang] = u; hyf_distance[trie_op_ptr] = d;
			hyf_num[trie_op_ptr] = n; hyf_next[trie_op_ptr] = v; trie_op_lang[trie_op_ptr] = cur_lang;
			trie_op_hash[h] = trie_op_ptr; trie_op_val[trie_op_ptr] = u; return u;
		}
		if (hyf_distance[l] == d && hyf_num[l] == n && hyf_next[l] == v && trie_op_lang[l] == cur_lang) {
			return trie_op_val[l];
		}
		if (h > -trie_op_size) decr(h); else h = trie_op_size;
	}
}

//960
void new_patterns()
{
	unsigned char k, l;
	bool digit_sensed;
	quarterword v;
	trie_pointer p, q;
	bool first_child;
	ASCII_code c;

	if (trie_not_ready) {
		set_cur_lang;
		scan_left_brace();
		#pragma region <Enter all of the patterns into a linked trie, until coming to a right brace 961>
		k = 0; hyf[0] = 0; digit_sensed = false;
		while (1) {
			get_x_token();
			switch (cur_cmd) {
			case letter:
			case other_char:
				#pragma region <Append a new letter of a hyphen level 962>
				if (digit_sensed || cur_chr < TEX_STRING("0") || 
					cur_chr > TEX_STRING("9")) {
					if (cur_chr == TEX_STRING(".")) cur_chr = 0;
					else {
						cur_chr = lc_code(cur_chr);
						if (cur_chr == 0) {
							print_err(TEX_STRING("Nonletter"));
							help1(TEX_STRING("(See Appendix H.)"));
							error();
						}
					}
					if (k < 63) {
						incr(k); hc[k] = cur_chr; hyf[k] = 0; digit_sensed = false;
					}
				}
				else if (k < 63) {
					hyf[k] = cur_chr - TEX_STRING("0"); digit_sensed = true;
				}
				#pragma endregion
				break;
			case spacer:
			case right_brace:
				if (k > 0)
					#pragma region <Insert a new pattern into the linked trie 963>
				{
					#pragma region <Compute the trie op code, v, and set l = 0 965>
					if (hc[1] == 0) hyf[0] = 0;
					if (hc[k] == 0) hyf[k] = 0;
					l = k; v = min_quarterword;
					while (1) {
						if (hyf[l] != 0) v = new_trie_op(k - l, hyf[l], v);
						if (l > 0) decr(l); else goto done1;
					}
				done1:

					#pragma endregion
					q = 0; hc[0] = cur_lang;
					while (l <= k) {
						c = hc[l]; incr(l); p = trie_l[q]; first_child = true;
						while (p > 0 && c > so(trie_c[p])) {
							q = p; p = trie_r[q]; first_child = false;
						}
						if (p == 0 || c < so(trie_c[p]))
							#pragma region <Insert a new trie node between q and p, and make p point to it 964>
						{
							if (trie_ptr == trie_size) overflow(TEX_STRING("pattern memory"), trie_size);
							incr(trie_ptr); trie_r[trie_ptr] = p; p = trie_ptr; trie_l[p] = 0;
							if (first_child) trie_l[q] = p; else trie_r[q] = p;
							trie_c[p] = si(c); trie_o[p] = min_quarterword;
						}
							#pragma endregion
						q = p;
					}
					if (trie_o[q] != min_quarterword) {
						print_err(TEX_STRING("Duplicate pattern"));
						help1(TEX_STRING("(See Appendix H.)"));
						error();
					}
					trie_o[q] = v;
				}
					#pragma endregion
				if (cur_cmd == right_brace) goto done;
				k = 0; hyf[0] = 0; digit_sensed = false;
				break;
			default:
				print_err(TEX_STRING("Bad "));
				print_esc(TEX_STRING("patterns"));
				help1(TEX_STRING("(See Appendix H.)"));
				error();
				break;
			}
		}
	done:
		;
		#pragma endregion
	}
	else {
		print_err(TEX_STRING("Too late for "));
		print_esc(TEX_STRING("patterns"));
		help1(TEX_STRING("All patterns must be given before typesetting begins."));
		error();
		link(garbage) = scan_toks(false, false); flush_list(def_ref);
	}
}


// 1215
void get_r_token()
{
restart:
	do {
		get_token();
	} while (!(cur_tok != space_token));
	if (cur_cs == 0 || cur_cs > frozen_control_sequence) {
		print_err(TEX_STRING("Missing control sequence inserted"));
		help5(TEX_STRING("Please don't say `\def cs{...}', say `\def\cs{...}'."),
			TEX_STRING("I've inserted an inaccessible control sequence so that your"),
			TEX_STRING("definition will be completed without mixing me up too badly."),
			TEX_STRING("You can recover graciously from this error, if you're"),
			TEX_STRING("careful; see exercise 27.2 in The TeXbook."));
		if (cur_cs == 0)
			back_input();
		cur_tok = cs_token_flag + frozen_protection;
		ins_error();
		goto restart;
	}
}

// 323
void begin_token_list(pointer p, quarterword t)
{
	push_input;
	state = token_list;
	start = p;
	token_type = (enum_token_type)t;
	if (t >= macro) {
		add_token_ref(p);
		if (t == macro) param_start = param_ptr;
		else {
			loc = link(p);
			if (tracing_macros > 1) {
				begin_diagnostic();
				print_nl(TEX_STRING(""));
				switch (t) {
				case mark_text: print_esc(TEX_STRING("mark")); break;
				case write_text: print_esc(TEX_STRING("write")); break;
				default:
					print_cmd_chr(assign_toks, t - output_text + output_routine_loc);
					break;
				}
				print(TEX_STRING("->")); token_show(p);
				end_diagnostic(false);
			}
		}
	}
	else
		loc = p;
}

// 324
void end_token_list()
{
	if (token_type >= backed_up) {
		if (token_type <= inserted)
			flush_list(start);
		else {
			delete_token_ref(start);
			if (token_type == macro)
				while (param_ptr > param_start) {
					decr(param_ptr); flush_list(param_stack[param_ptr]);
				}
		}
	}
	else if (token_type == u_template)
		if (align_state > 500000) align_state = 0;
		else fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));

	pop_input; check_interrupt;
}

//381
void x_token()
{
	while (cur_cmd > max_command) {
		expand(); get_next();
	}
	if (cur_cs == 0) cur_tok = (cur_cmd * 0400) + cur_chr;
	else cur_tok = cs_token_flag + cur_cs;
}

// 403
void scan_left_brace()
{
	#pragma region <Get the next non-blank non relax non-call token 404>
	do 
	{
		get_x_token();
	} while (!(cur_cmd != spacer && cur_cmd != relax));
	#pragma endregion

	if (cur_cmd != left_brace) {
		print_err(TEX_STRING("Missing { inserted"));
		help4(TEX_STRING("A left brace was mandatory here, so I've put one in."),
			TEX_STRING("You might want to delete and/or insert some corrections"),
			TEX_STRING("so that I will find a matching right brace soon."),
			TEX_STRING("(If you're confused by all this, try typing `I}' now.)"));
		back_error();
		cur_tok = left_brace_token + TEX_STRING("{");
		cur_cmd = left_brace; cur_chr = TEX_STRING("{"); incr(align_state);
	}
}

// 473
pointer scan_toks(bool macro_def, bool xpand)
{
	halfword t;
	halfword s;
	pointer p;
	pointer q;
	halfword unbalance;
	halfword hash_brace;
	if (macro_def)
		scanner_status = defining;
	else
		scanner_status = absorbing;
	warning_index = cur_cs;
	def_ref = get_avail();
	token_ref_count(def_ref) = null;
	p = def_ref;
	hash_brace = 0;
	t = zero_token;
	if (macro_def) {
		#pragma region <Scan and build the parameter part of the macro definition 474>
		while (1) {
			get_token();
			if (cur_tok < right_brace_limit) goto done1;
			if (cur_cmd == mac_param)
				#pragma region <If the next character is a parameter number.. 476>
			{
				s = match_token + cur_chr;
				get_token();
				if (cur_cmd == left_brace) {
					hash_brace = cur_tok; store_new_token(cur_tok); store_new_token(end_match_token);
					goto done;
				}
				if (t == zero_token + 9) {
					print_err(TEX_STRING("You already have nine parameters"));
					help1(TEX_STRING("I'm going to ignore the # sign you just used."));
					error();
				}
				else {
					incr(t);
					if (cur_tok != t) {
						print_err(TEX_STRING("Parameters must be numbered consecutively"));
						help2(TEX_STRING("I've inserted the digit you should have used after the #."),
							TEX_STRING("Type `1' to delete what you did use."));
						back_error();
					}
					cur_tok = s;
				}
			}
				#pragma endregion
			store_new_token(cur_tok);
		}
	done1: store_new_token(end_match_token);
		if (cur_cmd == right_brace)
			#pragma region Express shock at the missing left brace; goto found 475
		{
			print_err(TEX_STRING("Missing { inserted")); incr(align_state);
			help2(TEX_STRING("Where was the left brace? You said something like `\def\a}',"),
				TEX_STRING("which I'm going to interpret as `\def\a{}'."));
			error();
			goto found;
		}
			#pragma endregion
		done:;
		#pragma endregion
	}
	else
		scan_left_brace();

	#pragma region <Scan and build the body of teh token list; goto found when finished 477>
	unbalance = 1;
	while (1) {
		if(xpand)
			#pragma region <Expand the next part of the input 478>
		{
			while (1) {
				get_next();
				if (cur_cmd <= max_command) goto done2;
				if (cur_cmd != the) expand();
				else {
					q = the_toks();
					if (link(temp_head) != null) {
						link(p) = link(temp_head); p = q;
					}
				}
			}
		done2:		x_token();
		}
			#pragma endregion
		else get_token();
		if (cur_tok < right_brace_limit)
			if (cur_cmd < right_brace) incr(unbalance);
			else {
				decr(unbalance);
				if (unbalance == 0) goto found;
			}
		else if(cur_cmd == mac_param)
			if(macro_def) 
				#pragma region <Look for parameter number or .. 479>
			{
				s = cur_tok;
				if (xpand) get_x_token();
				else get_token();
				if(cur_cmd != mac_param)
					if (cur_tok <= zero_token || cur_tok > t) {
						print_err(TEX_STRING("Illegal parameter number in definition of "));
						sprint_cs(warning_index);
						help3(TEX_STRING("You meant to type ## instead of #, right?"),
							TEX_STRING("Or maybe a } was forgotten somewhere earlier, and things"),
							TEX_STRING("are all screwed up? I'm going to assume that you meant ##."));
						back_error();
						cur_tok = s;
					}
					else cur_tok = out_param_token - TEX_STRING("0") + cur_chr;
			}
				#pragma endregion
		store_new_token(cur_tok);
	}
	#pragma endregion

found:
	scanner_status = normal;
	if (hash_brace != 0)
		store_new_token(hash_brace);
	return p;
}

// 482
void read_toks(int n, pointer r)
{
	pointer p;
	pointer q;
	int s;
	small_number m;

	scanner_status = defining;
	warning_index = r;
	def_ref = get_avail();
	token_ref_count(def_ref) = null;
	p = def_ref;
	store_new_token(end_match_token);
	if (n < 0 || n>15)
		m = 16;
	else
		m = n;
	s = align_state; align_state = 1000000;
	do {
		#pragma region <Input and store tokens from the next line of the file 483>
		begin_file_reading();
		name = m + 1;
		if (read_open[m] == closed)
			#pragma region <Input for read from the terminal 484>
		{

			if (interaction > nonstop_mode) {
				if (n < 0)
					prompt_input(TEX_STRING(""));
				else {
					wake_up_terminal();
					print_ln();
					sprint_cs(r);
					prompt_input(TEX_STRING("="));
					n = -1;
				}
			}
			else
				fatal_error(TEX_STRING("*** (cannot \read from terminal in nonstop modes)"));
		}
			#pragma endregion
		else if (read_open[m] == just_open) 
			#pragma region <Input the first line of read_file[m] 485>
		{			

			if (input_ln(read_file[m], false)) read_open[m] = normal;
			else {
				a_close(read_file[m]); read_open[m] = closed;
			}

		}
			#pragma endregion
		else
			#pragma region <Input the next line from read_file[m] 486>
		{
			if (!input_ln(read_file[m], true)) {
				a_close(read_file[m]); read_open[m] = closed;
				if (align_state != 1000000) {
					runaway();
					print_err(TEX_STRING("File ended within "));
					print_esc(TEX_STRING("read"));
					help1(TEX_STRING("This \read has unbalanced braces."));
					align_state = 1000000;
					error();
				}
			}
		}
			#pragma endregion
		limit = last;
		if (end_line_char_inactive)
			decr(limit);
		else
			buffer[limit] = end_line_char;
		first = limit + 1; loc = start; state = new_line;
		while (1) {
			get_token();
			if (cur_tok == 0)
				goto done;
			if (align_state < 1000000) {
				do {
					get_token();
				} while (!(cur_tok == 0));
				align_state = 1000000;
				goto done;
			}
			store_new_token(cur_tok);
		}
	done:
		end_file_reading();
		#pragma endregion
	} while (!(align_state == 1000000));
	cur_val = def_ref; scanner_status = normal; align_state = s;
}

// 581
void char_warning(internal_font_number f, eight_bits c)
{
	if (tracing_lost_chars > 0) {
		begin_diagnostic();
		print_nl(TEX_STRING("Missing character: There is no "));
		print_ASCII(c);
		print(TEX_STRING(" in font "));
		slow_print(font_name[f]); 
		print_char(TEX_STRING("!"));
		end_diagnostic(false);
	}
}

//582
pointer new_character(internal_font_number f, eight_bits c)
{
	pointer p;
	if(font_bc[f] <= c)
		if(font_ec[f]>=c)
			if (char_exists(char_info(f, qi(c)))) {
				p = get_avail(); font(p) = f; character(p) = qi(c); return p;
			}
	char_warning(f, c); return null;
}

// 526
void scan_file_name()
{
	name_in_progress = true;
	begin_name();
	#pragma region <Get the next non_blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	while (1) {
		if (cur_cmd > other_char || cur_chr > 255) {
			back_input();
			goto done;
		}
		if (!more_name((ASCII_code)cur_chr))
			goto done;
		get_x_token();
	}
done:
	end_name();
	name_in_progress = false;
}

// 560
internal_font_number read_font_info(pointer u, str_number nom, str_number aire, scaled s)
{
	font_index k;
	bool file_opened;
	halfword lf, lh, bc, ec, nw, nh, nd, ni, nl, nk, ne, np;
	internal_font_number f;
	internal_font_number g;
	eight_bits a, b, c, d;
	four_quarters qw;
	scaled sw;
	int bch_label;
	int bchar; // 0.. 256
	scaled z;
	int alpha;
	unsigned char beta;

	g = null_font;
	#pragma region <Read and check the font data; abort if the TFM file is malformed; .. and goto done 562>

	#pragma region<Open tfm_file for input 563>
	file_opened = false;
	if (aire == TEX_STRING("")) 
		pack_file_name(nom, TEX_font_area, TEX_STRING(".tfm"));
	if (!b_open_in(&tfm_file)) _abort;
	file_opened = true;
	#pragma endregion

	#pragma region <Read the TFM size fields 565>
	read_sixteen(lf);
	read_sixteen(lh);
	read_sixteen(bc);
	read_sixteen(ec);
	if (bc > ec + 1 || ec > 255) _abort;
	if (bc > 255) {
		bc = 1; ec = 0;
	}
	read_sixteen(nw); read_sixteen(nh); read_sixteen(nd); read_sixteen(ni);
	read_sixteen(nl); read_sixteen(nk); read_sixteen(ne); read_sixteen(np);
	if (lf != 6 + lh + (ec - bc + 1) + nw + nh + nd + ni + nl + nk + ne + np) _abort;
	if (nw == 0 || nh == 0 || nd == 0 || ni == 0) _abort;
	#pragma endregion

	#pragma region <Use size fields to allocate font information 566>
	lf = lf - 6 - lh;
	if (np < 7) lf = lf + 7 - np;
	if (font_ptr == font_max || fmem_ptr + lf > font_mem_size) 
		#pragma region <Apologize for not loading the font, goto done 567>
	{
		start_font_error_message; print(TEX_STRING(" not loaded: Not enough room left"));
		help4(TEX_STRING("I'm afraid I won't be able to make use of this font,"),
			TEX_STRING("because my memory for character-size data is too small."),
			TEX_STRING("If you're really stuck, ask a wizard to enlarge me."),
			TEX_STRING("Or maybe try `I\font<same font id>=<name of loaded font>'."));
		error();
		goto done;
	}
#pragma endregion
	f = font_ptr + 1; char_base[f] = fmem_ptr - bc; width_base[f] = char_base[f] + ec + 1;
	height_base[f] = width_base[f] + nw; depth_base[f] = height_base[f] + nh;
	italic_base[f] = depth_base[f] + nd; lig_kern_base[f] = italic_base[f] + ni;
	kern_base[f] = lig_kern_base[f] + nl - kern_base_offset;
	exten_base[f] = kern_base[f] + kern_base_offset + nk; param_base[f] = exten_base[f] + ne;
	#pragma endregion

	#pragma region <read the TFM header 568>
	if (lh < 2) _abort;
	store_four_quarters(font_check[f]);
	read_sixteen(z);
	
	z = z * 0400 + fgetc(tfm_file); z = (z * 020) + (fgetc(tfm_file) / 020);
	if (z < unity) _abort;
	while (lh > 2) {
		fgetc(tfm_file); fgetc(tfm_file); fgetc(tfm_file); fgetc(tfm_file);
		decr(lh);
	}
	font_dsize[f] = z;
	if (s != -1000)
		if (s >= 0) z = s;
		else z = xn_over_d(z, -s, 1000);
	font_size[f] = z;
	#pragma endregion

	#pragma region <read character data 569>
	for (k = fmem_ptr; k <= width_base[f] - 1; k++) {
		store_four_quarters(font_info[k].union_t.qqqq);
		if (a >= nw || b / 020 >= nh || b % 020 >= nd || c / 4 >= ni) _abort;
		switch (c % 4) {
		case lig_tag:if (d >= nl)_abort; break;
		case ext_tag:if (d >= ne) _abort; break;
		case list_tag:
			#pragma region <Check for charlist cycle 570>
			check_byte_range(d);
			while (d < current_character_being_worked_on) {
				qw = char_info(f, d);
				if (char_tag(qw) != list_tag) goto not_found;
				d = qo(rem_byte(qw));
			}
			if (d == current_character_being_worked_on) _abort;
		not_found:
			#pragma endregion
			break;
		default:
			//do_nothing
			break;
		}
	}
	#pragma endregion

	#pragma region <read box dimensions 571>
	{
		#pragma region <Replace z by z prime and compute alpha, beta 572>
		{
			alpha = 16;
			while (z >= 040000000) {
				z = z / 2; alpha = alpha + alpha;
			}
			beta = 256 / alpha; alpha = alpha * z;
		}
		#pragma endregion
		for (k = width_base[f]; k <= lig_kern_base[f] - 1; k++) store_scaled(font_info[k].sc);
		if (font_info[width_base[f]].sc != 0) _abort;
		if (font_info[height_base[f]].sc != 0) _abort;
		if (font_info[depth_base[f]].sc != 0) _abort;
		if (font_info[italic_base[f]].sc != 0) _abort;
	}
	#pragma endregion

	#pragma region <read ligature/kern program 573>
	bch_label = 077777; bchar = 256;
	if (nl > 0) {
		for (k = lig_kern_base[f]; k <= kern_base[f] + kern_base_offset - 1;k++) {
			store_four_quarters(font_info[k].union_t.qqqq);
			if (a > 128) {
				if (256 * c + d >= nl) _abort;
				if (a == 255)
					if (k == lig_kern_base[f]) bchar = b;
			}
			else {
				if (b != bchar) check_existence(b);
				if (c < 128) check_existence(d);
				else if (256 * (c - 128) + d >= nk) _abort;
				if (a < 128)
					if (k - lig_kern_base[f] + a + 1 >= nl) _abort;
			}
		}
		if (a == 255) bch_label = 256 * c + d;
	}
	for (k = kern_base[f] + kern_base_offset; k <= exten_base[f] - 1; k++)
		store_scaled(font_info[k].sc);
	#pragma endregion

	#pragma region <read extensible chracter recipes 574>
	for (k = exten_base[f]; k <= param_base[f] - 1; k++) {
		store_four_quarters(font_info[k].union_t.qqqq);
		if (a != 0) check_existence(a);
		if (b != 0) check_existence(a);
		if (c != 0) check_existence(a);
		check_existence(d);
		
	}
	#pragma endregion

	#pragma region <read font parameters 575>
	{
		for(k=1;k<=np;k++)
			if (k == 1) {
				sw = fgetc(tfm_file);
				if (sw > 127) sw = sw - 256;
				sw = sw * 0400 + fgetc(tfm_file);
				sw = sw * 0400 + fgetc(tfm_file);
				font_info[param_base[f]].sc = (sw * 020) + (fgetc(tfm_file) / 020);
			}
			else store_scaled(font_info[param_base[f] + k - 1].sc);
		if (feof(tfm_file)) _abort;
		for (k = np + 1; k <= 7; k++) font_info[param_base[f] + k - 1].sc = 0;
	}
	#pragma endregion

	#pragma region <Make final adjustments and goto done 576>
	if (np >= 7)font_params[f] = np; else font_params[f] = 7;
	hyphen_char[f] = default_hyphen_char; skew_char[f] = default_skew_char;
	if (bch_label < nl) bchar_label[f] = bch_label + lig_kern_base[f];
	else bchar_label[f] = non_address;
	font_bchar[f] = qi(bchar); font_false_bchar[f] = qi(bchar);
	if(bchar<=ec)
		if (bchar >= bc) {
			qw = char_info(f, bchar);
			if (char_exists(qw)) font_false_bchar[f] = non_char;
		}
	// overflow check
	if (bc < 0 || bc > 255 || ec < 0 || ec > 255) {
		printf("overflow in 576\n");
		exit(1);
	}
	font_name[f] = nom; font_area[f] = aire; font_bc[f] = (eight_bits)bc; font_ec[f] = (eight_bits)ec;
	font_glue[f] = null; adjust(char_base); adjust(width_base); adjust(lig_kern_base);
	adjust(kern_base); adjust(exten_base);
	decr(param_base[f]); fmem_ptr += lf; font_ptr = f; g = f;
	goto done;
	#pragma endregion

	#pragma endregion


bad_tfm:
	#pragma region <Report that the font wont be loaded 561>
	start_font_error_message;
	if (file_opened) print(TEX_STRING(" not loadable: Bad metric (TFM) file"));
	else print(TEX_STRING(" not loadable: Metric (TFM) file not found"));
	help5(TEX_STRING("I wasn't able to read the size data for this font,"),
		TEX_STRING("so I will ignore the font specification."),
		TEX_STRING("[Wizards can fix TFM files using TFtoPL/PLtoTF.]"),
		TEX_STRING("You might try inserting a different font spec;"),
		TEX_STRING("e.g., type `I\font<same font id>=<substitute font name>'."));
	error();
	#pragma endregion
done:
	if (file_opened)
		b_close(tfm_file);
	return g;
}


// 615
void prune_movements(int l)
{
	pointer p;
	while (down_ptr != null) {
		if (location(down_ptr) < l) goto done;
		p = down_ptr; down_ptr = link(p); free_node(p, movement_node_size);
	}
done:
	while (right_ptr != null) {
		if (location(right_ptr) < l) return;
		p = right_ptr; right_ptr = link(p); free_node(p, movement_node_size);
	}
}

//619
void hlist_out()
{
	scaled base_line;
	scaled left_edge;
	scaled save_h, save_v;
	pointer this_box;
	glue_ord g_order;
	int g_sign; // normal..shrinking
	pointer p;
	int save_loc;
	pointer leader_box;
	scaled leader_wd;
	scaled lx;
	bool outer_doing_leaders;
	scaled edge;
	double glue_temp;
	double cur_glue;
	scaled cur_g;

	cur_g = 0; cur_glue = 0.0f; this_box = temp_ptr; g_order = glue_order(this_box);
	g_sign = glue_sign(this_box); p = list_ptr(this_box); incr(cur_s);
	if (cur_s > 0) dvi_out(dvi_const::push);
	if (cur_s > max_push) max_push = cur_s;
	save_loc = dvi_offset + dvi_ptr; base_line = cur_v; left_edge = cur_h;
	while (p != null)
		#pragma region <Output node p for hlist_out and move to the next node.. 620>
		reswitch:
		if(is_char_node(p))
		{
			synch_h; synch_v;
			do
			{
				f = font(p); c = character(p);
				if (f != dvi_f)
					#pragma region <Change font dvi_f to f 621>
				{
					if (!font_used[f]) {
						dvi_font_def(f); font_used[f] = true;
					}
					if (f <= 64 + font_base) dvi_out(f - font_base - 1 + dvi_const::fnt_num_0);
					else {
						dvi_out(dvi_const::fnt1); dvi_out(f - font_base - 1);
					}
					dvi_f = f;
				}
	#pragma endregion
				if (c >= qi(128)) dvi_out(dvi_const::set1);
				dvi_out(qo(c));
				cur_h += char_width(f, char_info(f, c)); p = link(p);
			} while (!(!is_char_node(p)));
			dvi_h = cur_h;
		}
		else
			#pragma region <Output the non-char node p for hlist_out and move to the next node 622>
		{
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
				#pragma region <Output a box in an hlist 623>
				if (list_ptr(p) == null) cur_h += width(p);
				else {
					save_h = dvi_h; save_v = dvi_v; cur_v = base_line + shift_amount(p);
					temp_ptr = p; edge = cur_h;
					if (type(p) == vlist_node) vlist_out(); else hlist_out();
					dvi_h = save_h; dvi_v = save_v; cur_h = edge + width(p); cur_v = base_line;
				}
	#pragma endregion
				break;
			case rule_node:
				rule_ht = height(p); rule_dp = depth(p); rule_wd = width(p); goto fin_rule;
				break;
			case whatsit_node:
				#pragma region <Output the whatsit node p in an hlist 1367>
				out_what(p);
	#pragma endregion
				break;
			case glue_node:
				#pragma region <Move right or output leaders 625>
				g = glue_ptr(p); rule_wd = width(g) - cur_g;
				if (g_sign != normal) {
					if (g_sign == stretching) {
						if (stretch_order(g) == g_order) {
							cur_glue += stretch(g); vet_glue(_float(glue_set(this_box))*cur_glue);
							cur_g = (scaled)round(glue_temp);
						}
					}
					else if (shrink_order(g) == g_order) {
						cur_glue -= shrink(g); vet_glue(_float(glue_set(this_box))*cur_glue);
						cur_g = (scaled)round(glue_temp);
					}
				}
				rule_wd += cur_g;
				if (subtype(p) >= a_leaders)
					#pragma region <Output leaders in an hlist, goto fin_rule if a rule or to next_p if done 626>
				{
					leader_box = leader_ptr(p);
					if (type(leader_box) == rule_node) {
						rule_ht = height(leader_box); rule_dp = depth(leader_box); goto fin_rule;
					}
					leader_wd = width(leader_box);
					if (leader_wd > 0 && rule_wd > 0) {
						rule_wd += 10;
						edge = cur_h + rule_wd; lx = 0;
						#pragma region <Let cur_h be the position of the first box, and set leader_wd +lx.. 627>
						if (subtype(p) == a_leaders) {
							save_h = cur_h; cur_h = left_edge + leader_wd * ((cur_h - left_edge) / leader_wd);
							if (cur_h < save_h) cur_h += leader_wd;
						}
						else {
							lq = rule_wd / leader_wd;
							lr = rule_wd % leader_wd;
							if (subtype(p) == c_leaders) cur_h += (lr / 2);
							else {
								lx = lr / (lq + 1); cur_h += ((lr - (lq - 1)*lx) / 2);
							}
						}
	#pragma endregion
						while (cur_h + leader_wd <= edge)
							#pragma region <Output a leader box at cur_h, then advance cur_h by leader_wd+lx 628>
						{
							cur_v = base_line + shift_amount(leader_box); synch_v; save_v = dvi_v;
							synch_h; save_h = dvi_h; temp_ptr = leader_box; outer_doing_leaders = doing_leaders;
							doing_leaders = true;
							if (type(leader_box) == vlist_node) vlist_out(); else hlist_out();
							doing_leaders = outer_doing_leaders; dvi_v = save_v; dvi_h = save_h; cur_v = base_line;
							cur_h = save_h + leader_wd + lx;
						}
	#pragma endregion
						cur_h = edge - 10; goto next_p;
					}
				}
	#pragma endregion
				goto move_past;

				#pragma endregion
				break;
			case kern_node:
			case math_node:
				cur_h += width(p);
				break;
			case ligature_node:
				#pragma region <Make node p look like a char_node and goto reswitch 652>
				mem[lig_trick] = mem[lig_char(p)]; link(lig_trick) = link(p); p = lig_trick; goto reswitch;
				#pragma endregion
				break;
			default:
				//do_nothing
				break;
			}
			goto next_p;

fin_rule:

	#pragma region <Output a rule in an hlist 624>
			if (is_running(rule_ht)) rule_ht = height(this_box);
			if (is_running(rule_dp)) rule_dp = depth(this_box);
			rule_ht += rule_dp;
			if (rule_ht > 0 && rule_wd > 0) {
				synch_h; cur_v = base_line + rule_dp; synch_v; dvi_out(dvi_const::set_rule); dvi_four(rule_ht);
				dvi_four(rule_wd); cur_v = base_line; dvi_h += rule_wd;
			}
	#pragma endregion
	move_past:
			cur_h += rule_wd;
	next_p:
			p = link(p);
		}
	#pragma endregion

		#pragma endregion

	prune_movements(save_loc);
	if (cur_s > 0) dvi_pop(save_loc);
	decr(cur_s);
}

//629
void vlist_out()
{
	scaled left_edge;
	scaled top_edge;
	scaled save_h, save_v;
	pointer this_box;
	glue_ord g_order;
	int g_sign; // normal..shrinking
	pointer p;
	int save_loc;
	pointer leader_box;
	scaled leader_ht;
	scaled lx;
	bool outer_doing_leaders;
	scaled edge;
	double glue_temp;
	double cur_glue;
	scaled cur_g;

	cur_g = 0; cur_glue = 0.0f; this_box = temp_ptr; g_order = glue_order(this_box);
	g_sign = glue_sign(this_box); p = list_ptr(this_box); incr(cur_s);
	if (cur_s > 0) dvi_out(dvi_const::push);
	if (cur_s > max_push) max_push = cur_s;
	save_loc = dvi_offset + dvi_ptr; left_edge = cur_h; cur_v = cur_v - height(this_box); top_edge = cur_v;
	while (p != null)
		#pragma region <Output node p for vlist_out and move to the next node, maintaining.. 630>
	{
		if (is_char_node(p)) 
			confusion(TEX_STRING("vlistout"));
		else
			#pragma region <Output the non-char node p for vlist_out 631>
		{
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
				#pragma region <Output a box in a vlist 632>
				if (list_ptr(p) == null) cur_v += height(p) + depth(p);
				else {
					cur_v += height(p); synch_v; save_h = dvi_h; save_v = dvi_v;
					cur_h = left_edge + shift_amount(p);
					temp_ptr = p;
					if (type(p) == vlist_node) vlist_out(); else hlist_out();
					dvi_h = save_h; dvi_v = save_v; cur_v = save_v + depth(p); cur_h = left_edge;
				}
				#pragma endregion
				break;
			case rule_node:
				rule_ht = height(p); rule_dp = depth(p); rule_wd = width(p); goto fin_rule;
				break;
			case whatsit_node:
				#pragma region <Output the whatsit node p in a vlist 1366>
				out_what(p);
				#pragma endregion
				break;
			case glue_node:
				#pragma region <Move down or output leaders 634>
				g = glue_ptr(p); rule_ht = width(g) - cur_g;
				if (g_sign != normal) {
					if (g_sign == stretching) {
						if (stretch_order(g) == g_order) {
							cur_glue += stretch(g); vet_glue(_float(glue_set(this_box))*cur_glue);
							cur_g = (scaled)round(glue_temp);
						}
					}
					else if (shrink_order(g) == g_order) {
						cur_glue -= shrink(g); vet_glue(_float(glue_set(this_box))*cur_glue);
						cur_g = (scaled)round(glue_temp);
					}
				}
				rule_ht += cur_g;
				if (subtype(p) >= a_leaders)
					#pragma region <Output leaders in a vlist, goto fin_rule if a rule or to next_p if done 635>
				{
					leader_box = leader_ptr(p);
					if (type(leader_box) == rule_node) {
						rule_wd = width(leader_box); rule_dp = 0; goto fin_rule;
					}
					leader_ht = height(leader_box) + depth(leader_box);
					if (leader_ht > 0 && rule_ht > 0) {
						rule_ht += 10;
						edge = cur_v + rule_ht; lx = 0;
						#pragma region <Let cur_v be the position of the first box, and set leader_ht+lx to.. 636>
						if (subtype(p) == a_leaders) {
							save_v = cur_v; cur_v = top_edge + leader_ht * ((cur_v - top_edge) / leader_ht);
							if (cur_v < save_v) cur_v += leader_ht;
						}
						else {
							lq = rule_ht / leader_ht;
							lr = rule_ht % leader_ht;
							if (subtype(p) == c_leaders) cur_v += (lr / 2);
							else {
								lx = lr / (lq + 1); cur_v += ((lr - (lq - 1)*lx) / 2);
							}
						}
#pragma endregion
						while (cur_v + leader_ht <= edge)
							#pragma region <Output a leader box at cur_v, then advance cur_v by leader_ht+lx 637>
						{
							cur_h = left_edge + shift_amount(leader_box); synch_h; save_h = dvi_h;
							cur_v += height(leader_box); synch_v; save_v = dvi_v; temp_ptr = leader_box;
							outer_doing_leaders = doing_leaders; doing_leaders = true;
							if (type(leader_box) == vlist_node) vlist_out(); else hlist_out();
							doing_leaders = outer_doing_leaders; dvi_v = save_v; dvi_h = save_h; cur_h = left_edge;
							cur_v = save_v - height(leader_box) + leader_ht + lx;
						}
							#pragma endregion
					
						cur_v = edge - 10; goto next_p;
					}
				}
#pragma endregion

				goto move_past;

#pragma endregion
				break;
			case kern_node:
				cur_v += width(p);
				break;
			default:
				//do_nothing
				break;
			}
			goto next_p;

		fin_rule:
		#pragma region <Output a rule in a vlist, goto next_p 633>
			if (is_running(rule_wd)) rule_wd = width(this_box);
			rule_ht += rule_dp;
			cur_v += rule_ht;
			if (rule_ht > 0 && rule_wd > 0) {
				synch_h; synch_v; dvi_out(dvi_const::put_rule); dvi_four(rule_ht); dvi_four(rule_wd);
			}
			goto next_p;
		#pragma endregion

		move_past:
			cur_v += rule_ht;
		}
			#pragma endregion
	
		next_p:
			  p = link(p);
	}
		#pragma endregion

	prune_movements(save_loc);
	if (cur_s > 0) dvi_pop(save_loc);
	decr(cur_s);
}


// 638
void ship_out(pointer p)
{
	int page_loc;
	int j, k; // 0..9
	pool_pointer s;
	int old_setting; // 0..max_selector

	if (tracing_output > 0) {
		print_nl(TEX_STRING("")); print_ln(); print(TEX_STRING("Completed box being shipped out"));
	}
	if (term_offset > max_print_line - 9) print_ln();
	else if (term_offset > 0 || file_offset > 0) print_char(TEX_STRING(" "));
	print_char(TEX_STRING("[")); j = 9;
	while (count(j) == 0 && j > 0) decr(j);
	for (k = 0; k <= j; k++) {
		print_int(count(k));
		if (k < j) print_char(TEX_STRING("."));
	}
	update_terminal();
	if (tracing_output > 0) {
		print_char(TEX_STRING("]"));
		begin_diagnostic();
		show_box(p);
		end_diagnostic(true);
	}
	#pragma region <Ship box p out 640>

	#pragma region <Update the values of max_h and max_v; but if the page is too large, goto done 641>
	if (height(p) > max_dimen || depth(p) > max_dimen ||
		height(p) + depth(p) + v_offset > max_dimen || width(p) + h_offset > max_dimen) {
		print_err(TEX_STRING("Huge page cannot be shipped out"));
		help2(TEX_STRING("The page just created is more than 18 feet tall or"),
			TEX_STRING("more than 18 feet wide, so I suspect something went wrong."));
		error();
		if (tracing_output <= 0) {
			begin_diagnostic(); print_nl(TEX_STRING("The following box has been deleted:")); show_box(p);
			end_diagnostic(true);
		}
		goto done;
	}
	if (height(p) + depth(p) + v_offset > max_v) max_v = height(p) + depth(p) + v_offset;
	if (width(p) + h_offset > max_h) max_h = width(p) + h_offset;
	#pragma endregion

	#pragma region <Initialize variables as ship_out begins 617>
	dvi_h = 0; dvi_v = 0; cur_h = h_offset; dvi_f = null_font; ensure_dvi_open;
	if (total_pages == 0) {
		dvi_out(dvi_const::pre); dvi_out(id_byte);
		dvi_four(25400000); dvi_four(473628672);
		prepare_mag(); dvi_four(mag);
		old_setting = selector; selector = new_string; print(TEX_STRING(" TeX output ")); print_int(year);
		print_char(TEX_STRING(".")); print_two(month); print_char(TEX_STRING(".")); print_two(day); print_char(TEX_STRING(":"));
		print_two(time / 60); print_two(time % 60); selector = old_setting; dvi_out(cur_length);
		for (s = str_start[str_ptr]; s <= pool_ptr - 1; s++) dvi_out(so(str_pool[s]));
		pool_ptr = str_start[str_ptr];
	}
	#pragma endregion
	page_loc = dvi_offset + dvi_ptr; dvi_out(dvi_const::bop);
	for (k = 0; k <= 9; k++) dvi_four(count(k));
	dvi_four(last_bop); last_bop = page_loc; cur_v = height(p) + v_offset; temp_ptr = p;
	if (type(p) == vlist_node) vlist_out(); else hlist_out();
	dvi_out(dvi_const::eop); incr(total_pages); cur_s = -1;
done:

	#pragma endregion

	if (tracing_output <= 0) print_char(TEX_STRING("]"));
	dead_cycles = 0; update_terminal();
	#pragma region <Flush the box from memory, showing statistics if requested 639>
	//stat
	if (tracing_stats > 1) {
		print_nl(TEX_STRING("Memory usage before: ")); print_int(var_used); print_char(TEX_STRING("&"));
		print_int(dyn_used); print_char(TEX_STRING(";"));
	}
	//tats
	flush_node_list(p);
	//stat
	if (tracing_stats > 1) {
		print(TEX_STRING(" after: ")); print_int(var_used); print_char(TEX_STRING("&")); print_int(dyn_used);
		print(TEX_STRING("; still untouched: ")); print_int(hi_mem_min - lo_mem_max - 1); print_ln();
	}
	//tats
	#pragma endregion

}



// 1069
void extra_right_brace()
{
	print_err(TEX_STRING("Extra }, or forgotten "));
	switch (cur_group) {
	case semi_simple_group:
		print_esc(TEX_STRING("endgroup"));
		break;
	case math_shift_group:
		print_char(TEX_STRING("$"));
		break;
	case math_left_group:
		print_esc(TEX_STRING("right"));
		break;
	}
	help5(TEX_STRING("I've deleted a group-closing symbol because it seems to be"),
		TEX_STRING("spurious, as in `$x}$'. But perhaps the } is legitimate and"),
		TEX_STRING("you forgot something else, as in `\hbox{$x}'. In such cases"),
		TEX_STRING("the way to recover is to insert both the forgotten and the"),
		TEX_STRING("deleted material, e.g., by typing `I$}'."));
	error();
}


// 668
pointer vpackage(pointer p, scaled h, small_number m, scaled l)
{
	pointer r;
	scaled w, d, x;
	scaled s;
	pointer g;
	glue_ord o;

	last_badness = 0; r = get_node(box_node_size); type(r) = vlist_node;
	subtype(r) = min_quarterword; shift_amount(r) = 0; list_ptr(r) = p;
	w = 0;
	#pragma region <Clear dimensions to zero 650>
	d = 0; x = 0; total_stretch[normal] = 0; total_shrink[normal] = 0; total_stretch[fil] = 0;
	total_shrink[fil] = 0; total_stretch[fill] = 0; total_shrink[fill] = 0; total_stretch[filll] = 0;
	total_shrink[filll] = 0;
	#pragma endregion

	while (p != 0) 
		#pragma region <Examine node p in the vlist, taking account of its effect on the dimensions of the new box; then advance p to the next node 669>
	{
		if (is_char_node(p)) confusion(TEX_STRING("vpack"));
		else
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
			case unset_node:
				#pragma region <Incorporate box dimensions into the dimensions of the vbox that will contain 670>
				x = x + d + height(p); d = depth(p);
				if (type(p) >= rule_node) s = 0;
				else
					s = shift_amount(p);
				if (width(p) + s > w) w = width(p) + s;
				#pragma endregion
				break;

			case whatsit_node:
				//<Incorporate a wahtsit node into a vbox 1359>
				// do_nothing

				break;

			case glue_node:
				#pragma region <Icorporate glue into the vertical totals 671>
				x = x + d; d = 0;
				g = glue_ptr(p); x = x + width(g);
				o = stretch_order(g); total_stretch[o] = total_stretch[o] + stretch(g); o = shrink_order(g);
				total_shrink[o] += shrink(g);
				if (subtype(p) >= a_leaders) {
					g = leader_ptr(p);
					if (width(g) > w) w = width(g);
				}
				#pragma endregion
				break;

			case kern_node:
				x = x + d + width(p); d = 0;
				break;

			default:
				break;
			}

		p = link(p);
	}
		#pragma endregion

	width(r) = w;
	if (d > l) {
		x = x + d - l; depth(r) = l;
	}
	else depth(r) = d;
	#pragma region <Determine the value of height(r) and the appropriate glue setting; then return or goto common_ending 672>
	if (m == additional) h = x + h;
	height(r) = h; x = h - x;
	if (x == 0) {
		glue_sign(r) = normal; glue_order(r) = normal; set_glue_ratio_zero(glue_set(r));
		goto _exit;
	}
	else if (x > 0) 
		#pragma region <Determine vertical glue stretch setting, then return or goto commond_ending 673>
	{
		#pragma region <Determine the stretch order 659>
		if (total_stretch[filll] != 0) o = filll;
		else if (total_stretch[fill] != 0) o = fill;
		else if (total_stretch[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion
		glue_order(r) = o; glue_sign(r) = stretching;
		if (total_stretch[o] != 0) glue_set(r) = unfloat(float(x) / total_stretch[o]);
		else {
			glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if(o==normal)
			if (list_ptr(r) != null) 
				#pragma region <Report an underfull vbox adn goto common_ending, if this box is sufficiently bad 674>
			{
				last_badness = badness(x, total_stretch[normal]);
				if (last_badness > vbadness) {
					print_ln();
					if (last_badness > 100) print_nl(TEX_STRING("Underfull"));
					else print_nl(TEX_STRING("Loose"));
					print(TEX_STRING(" \vbox (badness ")); print_int(last_badness);
					goto common_ending;
				}
			}
				#pragma endregion
			
		goto _exit;
	}
		#pragma endregion
	else 
		#pragma region <Determine vertical glue shrink setting then return or goto common_ending 676>
	{
		#pragma region <Determine the shrink order 665>
		if (total_shrink[filll] != 0) o = filll;
		else if (total_shrink[fill] != 0) o = fill;
		else if (total_shrink[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion
		glue_order(r) = 0; glue_sign(r) = shrinking;
		if (total_shrink[o] != 0) glue_set(r) = unfloat(float(-x) / total_shrink[o]);
		else {
			glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if (total_shrink[o] < -x && o == normal && list_ptr(r) != null) {
			last_badness = 1000000; set_glue_ratio_one(glue_set(r));

			#pragma region <Report an overfull vbox adn goto common_ending, if this box is sufficienlty bad 677>
			if (-x - total_shrink[normal] > vfuzz || vbadness < 100) {
				print_ln(); print_nl(TEX_STRING("Overfull \vbox (")); print_scaled(-x - total_shrink[normal]);
				print(TEX_STRING("pt too high")); goto common_ending;
			}
			#pragma endregion
		}
		else if(o == normal)
			if (list_ptr(r) != null) 
				#pragma region <Report a tight vbox and goto common_ending if this box is sufficienlty bad 678>
			{
				last_badness = badness(-x, total_shrink[normal]);
				if (last_badness > vbadness) {
					print_ln(); print_nl(TEX_STRING("Tight \vbox (badness "));
					print_int(last_badness);
					goto common_ending;
				}
			}
#pragma endregion
			
		goto _exit;
	}
		#pragma endregion

#pragma endregion

common_ending:

	#pragma region <Finish issuing a diagnostic message for an overfull or underfull vbox 675>
	if (output_active) print(TEX_STRING(") has occurred while \output is active"));
	else {
		if (pack_begin_line != 0) {
			print(TEX_STRING(") in alignment at lines ")); print_int(abs(pack_begin_line));
			print(TEX_STRING("--"));
		}
		else print(TEX_STRING(") detected at line "));
		print_int(line); print_ln();
	}
	begin_diagnostic(); show_box(r); end_diagnostic(true);
	#pragma endregion

_exit:
	return r;
}

// 645
void scan_spec(group_code c, bool three_codes)
{
	int s;
	unsigned char spec_code;
	if (three_codes)s = saved(0);
	if (scan_keyword(TEX_STRING("to"))) spec_code = exactly;
	else if (scan_keyword(TEX_STRING("spread"))) spec_code = additional;
	else {
		spec_code = additional; cur_val = 0; goto found;
	}
	scan_normal_dimen;
found:
	if (three_codes) {
		saved(0) = s; incr(save_ptr);
	}
	saved(0) = spec_code; saved(1) = cur_val; save_ptr += 2; new_save_level(c); scan_left_brace();
}


// 649
pointer hpack(pointer p, scaled w, small_number m)
{
	pointer r;
	pointer q;
	scaled h, d, x;
	scaled s;
	pointer g;
	glue_ord o;
	internal_font_number f;
	four_quarters i;
	eight_bits hd;

	last_badness = 0; r = get_node(box_node_size); type(r) = hlist_node;
	subtype(r) = min_quarterword; shift_amount(r) = 0; q = r + list_offset; link(q) = p;
	h = 0;
	#pragma region <Clear dimensions to zero 650>
	d = 0; x = 0; total_stretch[normal] = 0; total_shrink[normal] = 0; total_stretch[fil] = 0;
	total_shrink[fil] = 0; total_stretch[fill] = 0; total_shrink[fill] = 0; total_stretch[filll] = 0;
	total_shrink[filll] = 0;
	#pragma endregion

	while (p != null) 
		#pragma region <Examine node p in the hlist, taking account of its effect on the dimensions of the .. to the next node 651>
	{
	reswitch:
		while (is_char_node(p)) 
			#pragma region <Incorporate character dimensions into the dimensions of the hbox that will contain it, then move to the next node 654>
		{
			f = font(p); i = char_info(f, character(p)); hd = height_depth(i); x += char_width(f, i);
			s = char_height(f, hd); if (s > h) h = s;
			s = char_depth(f, hd); if (s > d) d = s;
			p = link(p);
		}
			#pragma endregion

		
		if (p != null) {
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
			case unset_node:
				#pragma region <Incorporate box dimensions into the dimensions of the hbox that will contain it 653>
				x += width(p);
				if (type(p) >= rule_node) s = 0; else s = shift_amount(p);
				if (height(p) - s > h) h = height(p) - s;
				if (depth(p) + s > d) d = depth(p) + s;
				#pragma endregion
				break;
			case ins_node:
			case mark_node:
			case adjust_node:
				if (adjust_tail != null) 
					#pragma region <transfer node p to the adjustment list 655>
				{
					while (link(q) != p) q = link(q);
					if (type(p) == adjust_node) {
						link(adjust_tail) = adjust_ptr(p);
						while (link(adjust_tail) != null) adjust_tail = link(adjust_tail);
						p = link(p); free_node(link(q), small_node_size);
					}
					else {
						link(adjust_tail) = p; adjust_tail = p; p = link(p);
					}
					link(q) = p; p = q;
				}
					#pragma endregion
				break;
			case whatsit_node:
				//<Incorporate whatsit node into an hbox 1360>
				//do_nothing
				break;
			case glue_node:
				#pragma region <Incorporate glue into the horizontal totals 656>
				g = glue_ptr(p); x += width(g);
				o = stretch_order(g); total_stretch[o] += stretch(g); o = shrink_order(g);
				total_shrink[o] += shrink(g);
				if (subtype(p) >= a_leaders) {
					g = leader_ptr(p);
					if (height(g) > h) h = height(g);
					if (depth(g) > d) d = depth(g);
				}
				#pragma endregion
				break;
			case kern_node:
			case math_node:
				x += width(p);
				break;
			case ligature_node:
				#pragma region <Make node p look like a char_node and goto reswitch 652>
				mem[lig_trick] = mem[lig_char(p)]; link(lig_trick) = link(p); p = lig_trick;
				goto reswitch;
				#pragma endregion
				break;
			}
			p = link(p);
		}
	}
		#pragma endregion

	if (adjust_tail != null) link(adjust_tail) = null;
	height(r) = h; depth(r) = d;

	#pragma region <Determine the value of width(r)and the appropriate glue setting; then return or goto common_ending 657>
	if (m == additional) w += x;
	width(r) = w; x = w - x;
	if (x == 0) {
		glue_sign(r) = normal; glue_order(r) = normal; set_glue_ratio_zero(glue_set(r));
		goto _exit;
	}
	else if (x > 0) 
		#pragma region <Determine horizontal glue stretch setting, then return or goto common_ending 658>
	{
		#pragma region <Determine the stretch order 659>
		if (total_stretch[filll] != 0) o = filll;
		else if (total_stretch[fill] != 0) o = fill;
		else if (total_stretch[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion


		glue_order(r) = o; glue_sign(r) = stretching;
		if (total_stretch[o] != 0) glue_set(r) = unfloat(float(x) / total_stretch[o]);
		else { glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if(o==normal)
			if (list_ptr(r) != null)
				#pragma region <Report an underfull hbox and goto common_ending, if this box is sufficiently bad 660>
			{

				last_badness = badness(x, total_stretch[normal]);
				if (last_badness > hbadness) {
					print_ln();
					if (last_badness > 100) print_nl(TEX_STRING("Underfull")); 
					else print_nl(TEX_STRING("Loose"));
					print(TEX_STRING(" \hbox (badness ")); print_int(last_badness);
					goto common_ending;
				}
			}
				#pragma endregion
		goto _exit;
	}
		#pragma endregion
	else 
		#pragma region <Determine horizontal glue shrink setting, then return or goto common_ending 664>	
	{
		#pragma region <Determine the shrink order 665>
		if (total_shrink[filll] != 0) o = filll;
		else if (total_shrink[fill] != 0) o = fill;
		else if (total_shrink[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion


		glue_order(r) = o; glue_sign(r) = shrinking;
		if (total_shrink[o] != 0) glue_set(r) = unfloat(float(-x) / total_shrink[o]);
		else { glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if (total_shrink[o] < -x && o == normal && list_ptr(r) != null) {
			last_badness = 1000000; set_glue_ratio_one(glue_set(r));
			#pragma region <Report and overfull hbox and goto common ending, if this box is sufficienlty bad 666>
			if (-x - total_shrink[normal] > hfuzz || hbadness < 100) {
				if (overfull_rule > 0 && -x - total_shrink[normal] > hfuzz) {
					while (link(q) != null) q = link(q);
					link(q) = new_rule(); width(link(q)) = overfull_rule;
				}
				print_ln(); print_nl(TEX_STRING("Overfull \hbox (")); print_scaled(-x - total_shrink[normal]);
				print(TEX_STRING("pt too wide"));
				goto common_ending;
			}
			#pragma endregion
		}
		else if(o==normal)
			if (list_ptr(r) != null) 
				#pragma region <Report a tight hbox and goto common_ending, if this box is suffiently bad 667>
			{
				last_badness = badness(-x, total_shrink[normal]);
				if (last_badness > hbadness) {
					print_ln();
					print_nl(TEX_STRING("Tight \hbox (badness ")); print_int(last_badness);
					goto common_ending;
				}
			}
				#pragma endregion

		goto _exit;
	}
		#pragma endregion


	#pragma endregion

common_ending:
	#pragma region <Finish issuing a diagnostic message for an overfull or underfull hbox 663>
	if (output_active) print(TEX_STRING(") has occurred while \output is active"));
	else {
		if (pack_begin_line != 0) {
			if (pack_begin_line > 0) print(TEX_STRING(") in paragraph at lines "));
			else print(TEX_STRING(") in alignment at lines "));
			print_int(abs(pack_begin_line));
			print(TEX_STRING("--"));
		}
		else print(TEX_STRING(") detected at line "));
		print_int(line);
	}
	print_ln();
	font_in_short_display = null_font; short_display(list_ptr(r));
	print_ln();
	begin_diagnostic();
	show_box(r);
	end_diagnostic(true);
	#pragma endregion
	_exit:

	return r;
}

//829
void try_break(int pi, small_number break_type)
{
	pointer r;
	pointer prev_r;
	halfword old_l;
	bool no_break_yet;
	#pragma region <Other local variables for try_break 830>
	pointer prev_prev_r;
	pointer s;
	pointer q;
	pointer v;
	int t;
	internal_font_number f;
	halfword l;
	bool node_r_stays_active;
	scaled line_width;
	unsigned char fit_class; // very_loose_fit..tight_fit
	halfword b;
	int d;
	bool artificial_demerits;
	pointer save_link;
	scaled shortfall;
	#pragma endregion

	#pragma region <Make sure that pi is in the proper range 831>
	if (abs(pi) >= inf_penalty)
		if (pi > 0) goto myexit;
		else pi = eject_penalty;
	#pragma endregion

	no_break_yet = true; prev_r = active; old_l = 0; do_all_six(copy_to_cur_active);
	while (1) {
	mycontinue:
		r = link(prev_r);
		#pragma region <If node r is of type delta_node ... 832>
		if (type(r) == delta_node) {
			do_all_six(update_width); prev_prev_r = prev_r; prev_r = r; goto mycontinue;
		}
		#pragma endregion
		
		#pragma region <If a line number class has ended, create new active nodes for the best feasible breaks in that class... 835>
		{
			l = line_number(r);
			if (l > old_l) {
				if (minimum_demerits < awful_bad && (old_l != easy_line || r == last_active))
					#pragma region <Create new active nodes for the best feasible breaks just found 836>
				{
					if (no_break_yet)
						#pragma region <Compute the values of break_width 837>
					{
						no_break_yet = false; do_all_six(set_break_width_to_background); s = cur_p;
						if(break_type > unhyphenated)
							if (cur_p != null)
								#pragma region <Compute the discretionary break_width values 840>
							{
								t = replace_count(cur_p); v = cur_p; s = post_break(cur_p);
								while (t > 0) {
									decr(t); v = link(v);
									#pragma region <Subtract the width of node v from break_width 841>
									if (is_char_node(v)) {
										f = font(v); break_width[1] -= char_width(f, char_info(f, character(v)));
									}
									else
										switch (type(v)) {
										case ligature_node:
											f = font(lig_char(v));
											break_width[1] -= char_width(f, char_info(f, character(lig_char(v))));
											break;
										case hlist_node:
										case vlist_node:
										case rule_node:
										case kern_node:
											break_width[1] -= width(v);
											break;
										default:
											confusion(TEX_STRING("disc1"));
											break;
										}
									#pragma endregion
								}
								while (s != null) {
									#pragma region <Add the width of node s to break_width 842>
									if (is_char_node(s)) {
										f = font(s); break_width[1] += char_width(f, char_info(f, character(s)));
									}
									else switch (type(s)) {
									case ligature_node:
										f = font(lig_char(s));
										break_width[1] += char_width(f, char_info(f, character(lig_char(s))));
										break;
									case hlist_node:
									case vlist_node:
									case rule_node:
									case kern_node:
										break_width[1] += width(s);
										break;
									default:
										confusion(TEX_STRING("disc2"));
										break;
									}
									#pragma endregion
									s = link(s);
								}
								break_width[1] += disc_width;
								if (post_break(cur_p) == null) s = link(v);
							}
								#pragma endregion
						while (s != null) {
							if (is_char_node(s)) goto done;
							switch (type(s)) {
							case glue_node:
								#pragma region <Subtract glue from break_width 838>
								v = glue_ptr(s); break_width[1] -= width(v);
								break_width[2 + stretch_order(v)] -= stretch(v);
								break_width[6] -= shrink(v);
								#pragma endregion
								break;
							case penalty_node:
								//do_nothing
								break;
							case math_node:
								break_width[1] -= width(s);
								break;
							case kern_node:
								if (subtype(s) != _explicit) goto done;
								else break_width[1] -= width(s);
								break;
							default:
								goto done;
								break;
							}
							s = link(s);
						}
					done:
						;
					}
						#pragma endregion

					#pragma region <Insert a delta node to prepare for breaks at cur_p 843>
					if (type(prev_r) == delta_node) {
						do_all_six(convert_to_break_width);
					}
					else if (prev_r == active) {
						do_all_six(store_break_width);
					}
					else {
						q = get_node(delta_node_size); link(q) = r; type(q) = delta_node;
						subtype(q) = 0;
						do_all_six(new_delta_to_break_width); link(prev_r) = q; prev_prev_r = prev_r; prev_r = q;
					}
					#pragma endregion

					if (abs(adj_demerits) >= awful_bad - minimum_demerits) minimum_demerits = awful_bad - 1;
					else minimum_demerits += abs(adj_demerits);
					for (fit_class = very_loose_fit; fit_class <= tight_fit; fit_class++) {
						if (minimal_demerits[fit_class] <= minimum_demerits)
							#pragma region <Insert a new active node from best_place[fit_class] to cur_p 845>
						{
							q = get_node(passive_node_size); link(q) = passive; passive = q; cur_break(q) = cur_p;
							//stat
							incr(pass_number); serial(q) = pass_number;
							//tats
							prev_break(q) = best_place[fit_class];
							q = get_node(active_node_size); break_node(q) = passive; line_number(q) = best_pl_line[fit_class] + 1;
							fitness(q) = fit_class;  type(q) = break_type; total_demerits(q) = minimal_demerits[fit_class];
							link(q) = r; link(prev_r) = q; prev_r = q;
							//stat
							if (tracing_paragraphs > 0)
								#pragma region <Print symbolic description of the new break node 846>
							{
								print_nl(TEX_STRING("@@")); print_int(serial(passive));
								print(TEX_STRING(": line ")); print_int(line_number(q) - 1);
								print_char(TEX_STRING(".")); print_int(fit_class);
								if (break_type == hyphenated) print_char(TEX_STRING("-"));
								print(TEX_STRING(" t=")); print_int(total_demerits(q));
								print(TEX_STRING(" -> @@"));
								if (prev_break(passive) == null) print_char(TEX_STRING("0"));
								else print_int(serial(prev_break(passive)));
							}
								#pragma endregion
							//tats
						}
						#pragma endregion
						minimal_demerits[fit_class] = awful_bad;
					}
					minimum_demerits = awful_bad;
					#pragma region <Insert a delta node to prepare for the next active node 844>
					if (r != last_active) {
						q = get_node(delta_node_size); link(q) = r; type(q) = delta_node;
						subtype(q) = 0;
						do_all_six(new_delta_from_break_width); link(prev_r) = q; prev_prev_r = prev_r; prev_r = q;
					}
					#pragma endregion

				}
				#pragma endregion
				if (r == last_active) goto myexit;
				#pragma region <Compute the new line width 850>
				if (l > easy_line) {
					line_width = second_width; old_l = max_halfword - 1;
				}
				else {
					old_l = l;
					if (l > last_special_line) line_width = second_width;
					else if (par_shape_ptr == null) line_width = first_width;
					else line_width = mem[par_shape_ptr + 2 * l].sc;
				}
				#pragma endregion
			}
		}
		#pragma endregion

		#pragma region <Consider demerits for a line from r to cur_p ... 851>
		{
			artificial_demerits = false;
			shortfall = line_width - cur_active_width[1];
			if (shortfall > 0)
				#pragma region <Set the value of b to the badness for stretching the line.. 852>
				if (cur_active_width[3] != 0 || cur_active_width[4] != 0 || cur_active_width[5] != 0) {
					b = 0; fit_class = decent_fit;
				}
				else {
					if(shortfall>7230584)
						if (cur_active_width[2] < 1663497) {
							b = inf_bad; fit_class = very_loose_fit; goto done1;
						}
					b = badness(shortfall, cur_active_width[2]);
					if (b > 12)
						if (b > 99) fit_class = very_loose_fit;
						else fit_class = loose_fit;
					else fit_class = decent_fit;
				done1:
					;
				}
				#pragma endregion
			else
				#pragma region <Set the value of b to the badness for shrinking the line.. 853>
			{
				if (-shortfall > cur_active_width[6]) b = inf_bad + 1;
				else b = badness(-shortfall, cur_active_width[6]);
				if (b > 12) fit_class = tight_fit; else fit_class = decent_fit;
			}
				#pragma endregion
			if (b > inf_bad || pi == eject_penalty)
				#pragma region <Prepare to deactivate node r, and goto deactivate.. 854>
			{
				if (final_pass && minimum_demerits == awful_bad && link(r) == last_active && prev_r == active)
					artificial_demerits = true;
				else if (b > threshold) goto deactivate;
				node_r_stays_active = false;
			}
				#pragma endregion
			else {
				prev_r = r;
				if (b > threshold) goto mycontinue;
				node_r_stays_active = true;
			}
			#pragma region <Record a new feasible break 855>
			if (artificial_demerits) d = 0;
			else
				#pragma region <Compute the demerits, d, from r to cur_p 859>
			{
				d = line_penalty + b;
				if (abs(d) >= 10000) d = 100000000; else d = d * d;
				if (pi != 0)
					if (pi > 0) d = d + pi * pi;
					else if (pi > eject_penalty) d = d - pi * pi;
				if (break_type == hyphenated && type(r) == hyphenated)
					if (cur_p != null) d = d + double_hyphen_demerits;
					else d = d + final_hyphen_demerits;
				if (abs(fit_class - fitness(r)) > 1) d = d + adj_demerits;
			}
				#pragma endregion
			//stat
			if (tracing_paragraphs > 0)
				#pragma region <Print a symbolic description of this feasible break 856>
			{
				if (printed_node != cur_p)
					#pragma region <Print the list between printed_node and cur_p, then set printed_node = cur_p 857>
				{
					print_nl(TEX_STRING(""));
					if (cur_p == null) short_display(link(printed_node));
					else {
						save_link = link(cur_p); link(cur_p) = null; print_nl(TEX_STRING(""));
						short_display(link(printed_node)); link(cur_p) = save_link;
					}
					printed_node = cur_p;
				}
					#pragma endregion
				print_nl(TEX_STRING("@"));
				if (cur_p == null) print_esc(TEX_STRING("par"));
				else if (type(cur_p) != glue_node) {
					if (type(cur_p) == penalty_node) print_esc(TEX_STRING("penalty"));
					else if (type(cur_p) == disc_node) print_esc(TEX_STRING("discretionary"));
					else if (type(cur_p) == kern_node) print_esc(TEX_STRING("kern"));
					else print_esc(TEX_STRING("math"));
				}
				print(TEX_STRING(" via @@"));
				if (break_node(r) == null) print_char(TEX_STRING("0"));
				else print_int(serial(break_node(r)));
				print(TEX_STRING(" b="));
				if (b > inf_bad) print_char(TEX_STRING("*")); else print_int(b);
				print(TEX_STRING(" p=")); print_int(pi); 
				print(TEX_STRING(" d="));
				if (artificial_demerits) print_char(TEX_STRING("*")); else print_int(d);
			}
				#pragma endregion
			//tats
			d += total_demerits(r);
			if (d <= minimal_demerits[fit_class]) {
				minimal_demerits[fit_class] = d; best_place[fit_class] = break_node(r); best_pl_line[fit_class] = l;
				if (d < minimum_demerits) minimum_demerits = d;
			}
			#pragma endregion
			if (node_r_stays_active) goto mycontinue;
	deactivate:
			#pragma region <Deactivate node r 860>
			link(prev_r) = link(r); free_node(r, active_node_size);
			if (prev_r == active)
				#pragma region <Update the active widths, since the first active node has been deleted 861>
			{
				r = link(active);
				if (type(r) == delta_node) {
					do_all_six(update_active); do_all_six(copy_to_cur_active); link(active) = link(r);
					free_node(r, delta_node_size);
				}
			}
				#pragma endregion
			else if (type(prev_r) == delta_node) {
				r = link(prev_r);
				if (r == last_active) {
					do_all_six(downdate_width); link(prev_prev_r) = last_active;
					free_node(prev_r, delta_node_size); prev_r = prev_prev_r;
				}
				else if (type(r) == delta_node) {
					do_all_six(update_width); do_all_six(combine_two_deltas); link(prev_r) = link(r);
					free_node(r, delta_node_size);
				}
			}
			#pragma endregion
		}
		#pragma endregion
	}

myexit:
	//stat
	#pragma region <Update the value of printed_node for symbolic displays 858>
	if (cur_p == printed_node)
		if (cur_p != null)
			if (type(cur_p) == disc_node) {
				t = replace_count(cur_p);
				while (t > 0) {
					decr(t); printed_node = link(printed_node);
				}
			}
	#pragma endregion
	//tats
}


// 1075
void box_end(int box_context)
{
	pointer p;
	if (box_context < box_flag) 
		#pragma region <Append box cur_box to the current list, shifted by box_context 1076>
	{
		if (cur_box != null) {
			shift_amount(cur_box) = box_context;
			if (abs(mode) == vmode) {
				append_to_vlist(cur_box);
				if (adjust_tail != null) {
					if (adjust_head != adjust_tail) {
						link(tail) = link(adjust_head); tail = adjust_tail;
					}
					adjust_tail = null;
				}
				if (mode > 0) build_page();
			}
			else {
				if (abs(mode) == hmode) space_factor = 1000;
				else {
					p = new_noad(); math_type(nucleus(p)) = sub_box; info(nucleus(p)) = cur_box;
					cur_box = p;
				}
				link(tail) = cur_box; tail = cur_box;
			}
		}
	}
		#pragma endregion
	else if (box_context < ship_out_flag) 
		#pragma region <Store cur_box in a box register 1077>
	{
		if (box_context < box_flag + 256) eq_define(box_base - box_flag + box_context, box_ref, cur_box);
		else geq_define(box_base - box_flag - 256 + box_context, box_ref, cur_box);
	}
		#pragma endregion
	else if(cur_box != null)
		if (box_context > ship_out_flag) 
			#pragma region <Append a new leader node that uses cur_box 1078>
		{
			#pragma region <Get the next non-blank non-relax non-call token 404>
			do
			{
				get_x_token();
			} while (!(cur_cmd != spacer && cur_cmd != relax));
			#pragma endregion
			if (cur_cmd == hskip && abs(mode) != vmode || cur_cmd == vskip && abs(mode) == vmode) {
				append_glue(); subtype(tail) = box_context - (leader_flag - a_leaders);
				leader_ptr(tail) = cur_box;
			}
			else {
				print_err(TEX_STRING("Leaders not followed by proper glue"));
				help3(TEX_STRING("You should say `\leaders <box or rule><hskip or vskip>'."),
					TEX_STRING("I found the <box or rule>, but there's no suitable"),
					TEX_STRING("<hskip or vskip>, so I'm ignoring these leaders."));
				back_error();
				flush_node_list(cur_box);
			}
		}
			#pragma endregion
		else ship_out(cur_box);
}


// 1086
void package(small_number c)
{
	scaled h;
	pointer p;
	scaled d;

	d = box_max_depth; unsave(); save_ptr = save_ptr - 3;
	if (mode == -hmode) cur_box = hpack(link(head), saved(2), saved(1));
	else {
		cur_box = vpackage(link(head), saved(2), saved(1), d);
		if (c == vtop_code) 
			#pragma region <Readjust the height and depth of cur_box for vtop 1087>
		{
			h = 0; p = list_ptr(cur_box);
			if (p != null)
				if (type(p) <= rule_node) h = height(p);
			depth(cur_box) = depth(cur_box) - h + height(cur_box); height(cur_box) = h;
		}
			#pragma endregion
	}
	pop_nest();
	box_end(saved(0));
}


// 597
void write_dvi(dvi_index a, dvi_index b)
{
	dvi_index k;
	for (k = a; k <= b;k++)
		fputc(dvi_buf[k], dvi_file);
}


// 598
void dvi_swap()
{
	if (dvi_limit == dvi_buf_size) {
		write_dvi(0, half_buf - 1); dvi_limit = half_buf; dvi_offset += dvi_buf_size;
		dvi_ptr = 0;
	}
	else {
		write_dvi(half_buf, dvi_buf_size - 1); dvi_limit = dvi_buf_size;
	}
	dvi_gone += half_buf;
}

// 600
void dvi_four(int x)
{
	if (x >= 0)
		dvi_out(x / 0100000000);
	else {
		x += 010000000000;
		x += 010000000000;
		dvi_out((x / 0100000000) + 128);
	}
	x %= 0100000000; dvi_out(x / 0200000); x %= 0200000; dvi_out(x / 0400);
	dvi_out(x % 0400);
}

// 601
void dvi_pop(int l)
{
	if (l == dvi_offset + dvi_ptr && dvi_ptr > 0)
		decr(dvi_ptr);
	else
		dvi_out(dvi_const::pop);
}

// 602
void dvi_font_def(internal_font_number f)
{
	pool_pointer k;
	dvi_out(dvi_const::fnt_def1); dvi_out(f - font_base - 1);
	dvi_out(qo(font_check[f].b0)); dvi_out(qo(font_check[f].b1)); dvi_out(qo(font_check[f].b2));
	dvi_out(qo(font_check[f].b3));
	dvi_four(font_size[f]); dvi_four(font_dsize[f]);
	dvi_out(length(font_area[f])); dvi_out(length(font_name[f]));
	#pragma region <Output the font name whose internal number is f 603>
	for (k = str_start[font_area[f]]; k <= str_start[font_area[f] + 1] - 1; k++)
		dvi_out(so(str_pool[k]));
	for (k = str_start[font_name[f]]; k <= str_start[font_name[f] + 1] - 1; k++)
		dvi_out(so(str_pool[k]));
	#pragma endregion
}


// 1333
void close_files_and_terminate()
{
	int k;
	#pragma region <finish the extensions 1378>
	for (k = 0; k < 16; k++) {
		if (write_open[k])
			a_close(write_file[k]);
	}
	#pragma endregion

	if (tracing_stats > 0)
		#pragma region <Output statistics about this job 1334>
		if (log_opened) {
			wlog_ln_s(" "); wlog_ln_s("Here is how much of TeX\'s memory you used:");
			{
				std::stringstream oss;
				oss << " " << str_ptr - init_str_ptr << " string";
				wlog_s(oss.str().c_str());
				if (str_ptr != init_str_ptr + 1) {
					wlog_s("s");
				}
			}
			{
				std::stringstream oss;
				oss << " out of " << max_strings - init_str_ptr;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << pool_ptr - init_pool_ptr << " string characters out of " << pool_size - init_pool_ptr;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << lo_mem_max - mem_min + mem_end - hi_mem_min + 2 << " words of memory out of ";
				oss << mem_end + 1 - mem_min;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << cs_count << " multiletter control sequences out of " << hash_size;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << fmem_ptr << " words of font info for " << font_ptr - font_base << " font";
				wlog_s(oss.str().c_str());
			}
			if (font_ptr != font_base + 1)
				wlog_s("s");
			{
				std::stringstream oss;
				oss << ", out of " << font_mem_size << " for " << font_max - font_base;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << hyph_count << " hyphenation exception";
				wlog_s(oss.str().c_str());
			}
			if (hyph_count != 1)
				wlog_s("s");
			{
				std::stringstream oss;
				oss << " out of " << hyph_size;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << max_in_stack << "i," << max_nest_stack << "n," << max_param_stack << "p," <<
					max_buf_stack + 1 << "b," << max_save_stack + 6 << "s stack positions out of " <<
					stack_size << "i," << nest_size << "n," << param_size << "p," << buf_size << "b," << save_size << "s";
				wlog_ln_s(oss.str().c_str());
			}
		}
		#pragma endregion

	wake_up_terminal();
	
	#pragma region <Finish the DVI file 642>
	while (cur_s > -1) {
		if (cur_s > 0)
			dvi_out(dvi_const::pop);
		else {
			dvi_out(dvi_const::eop); incr(total_pages);
		}
		decr(cur_s);
	}
	if (total_pages == 0)
		print_nl(TEX_STRING("No pages of output."));
	else {
		dvi_out(dvi_const::post);
		dvi_four(last_bop); last_bop = dvi_offset + dvi_ptr - 5;
		dvi_four(25400000); dvi_four(473628672);
		prepare_mag(); dvi_four(mag);
		dvi_four(max_v); dvi_four(max_h);
		dvi_out(max_push / 256); dvi_out(max_push % 256);
		dvi_out((total_pages / 256) % 256); dvi_out(total_pages % 256);

		#pragma region <Output the font definitions for all fonts that were used 643
		while (font_ptr > font_base) {
			if (font_used[font_ptr])
				dvi_font_def(font_ptr);
			decr(font_ptr);
		}
		#pragma endregion

		dvi_out(dvi_const::post_post); dvi_four(last_bop); dvi_out(id_byte);
		k = 4 + ((dvi_buf_size - dvi_ptr) % 4);
		while (k > 0) {
			dvi_out(223);
			decr(k);
		}

		#pragma region <Empty the last bytes out of dvi_buf 599>
		if (dvi_limit == half_buf)
			write_dvi(half_buf, dvi_buf_size - 1);
		if (dvi_ptr > 0)
			write_dvi(0, dvi_ptr - 1);
		#pragma endregion

		print_nl(TEX_STRING("Output written on ")); slow_print(output_file_name);
		print(TEX_STRING(" (")); print_int(total_pages);
		print(TEX_STRING(" page"));
		if (total_pages != 1)
			print_char(TEX_STRING("s"));
		print(TEX_STRING(", ")); print_int(dvi_offset + dvi_ptr);
		print(TEX_STRING(" bytes).")); b_close(dvi_file);

	}
	#pragma endregion

	if (log_opened) {
		wlog_cr;
		a_close(log_file);
		selector -= 2;
		if (selector == term_only) {
			print_nl(TEX_STRING("Transcript written on "));
			slow_print(log_name);
			print_char('.');
		}
	}
}

// 292
void show_token_list(int p, int q, int l)
{
	int m, c;
	ASCII_code match_chr;
	ASCII_code n;
	match_chr = TEX_STRING("#");
	n = TEX_STRING("0");
	tally = 0;
	while (p != null && tally < l) {
		if (p == q)
			#pragma region <Do magic computation 320>
			set_trick_count;
			#pragma endregion

		#pragma region <Display token p, and return if there are problems 293>
		if (p < hi_mem_min || p > mem_end) {
			print_esc(TEX_STRING("CLOBBERED."));
			return;
		}
		if (info(p) >= cs_token_flag)
			print_cs(info(p) - cs_token_flag);
		else {
			m = info(p) / 0400; c = info(p) % 0400;
			if (info(p) < 0)
				print_esc(TEX_STRING("BAD."));
			else
				#pragma region <Display the token (m,c) 294>
				switch (m) {
					case left_brace:
					case right_brace:
					case math_shift:
					case tab_mark:
					case sup_mark:
					case sub_mark:
					case spacer:
					case letter:
					case other_char:
						print(c);
						break;
					case mac_param:
						print(c); print(c);
						break;
					case out_param:
						print(match_chr);
						if (c <= 9)
							print_char(c + TEX_STRING("0"));
						else {
							print_char(TEX_STRING("!"));
							return;
						}
						break;
					case match:
						match_chr = c;
						print(c);
						incr(n);
						print_char(n);
						if (n > TEX_STRING("9"))
							return;
						break;
					case end_match:
						print(TEX_STRING("->"));
						break;
					default:
						print_esc(TEX_STRING("BAD."));
						break;
				}
				#pragma endregion
		}
		#pragma endregion
		p = link(p);
	}
	if (p != null)
		print_esc(TEX_STRING("ETC."));
}

// 295
void token_show(pointer p)
{
	if (p != null)
		show_token_list(link(p), null, 10000000);
}

// 934
void new_hyph_exceptions()
{
	unsigned char n;
	unsigned char j;
	hyph_pointer h;
	str_number k;
	pointer p;
	pointer q;
	str_number s, t;
	pool_pointer u, v;

	scan_left_brace();
	set_cur_lang;
	#pragma region <Enter as many hyphenation exceptions as are listed, until coming to a right brace; then return 935>
	n = 0; p = null;
	while (1) {
		get_x_token();
	reswitch:
		switch (cur_cmd) {
		case letter:
		case other_char:
		case char_given:
			#pragma region <Append a new letter or hyphen 937>
			if (cur_chr == TEX_STRING("-"))
				#pragma region <Append the value n to list p 938>
			{
				if (n < 63) {
					q = get_avail(); link(q) = p; info(q) = n; p = q;
				}
			}
				#pragma endregion
			else {
				if (lc_code(cur_chr) == 0) {
					print_err(TEX_STRING("Not a letter"));
					help2(TEX_STRING("Letters in \hyphenation words must have \lccode>0."),
						TEX_STRING("Proceed; I'll ignore the character I just read."));
					error();
				}
				else if (n < 63) {
					incr(n); hc[n] = lc_code(cur_chr);
				}
			}
			#pragma endregion
			break;
		case char_num:
			scan_char_num(); cur_chr = cur_val; cur_cmd = char_given; goto reswitch;
			break;

		case spacer:
		case right_brace:
			if (n > 1)
				#pragma region <Enter a hyphenation exception 939>
			{
				incr(n); hc[n] = cur_lang; str_room(n); h = 0;
				for (j = 1; j <= n; j++) {
					h = (h + h + hc[j]) % hyph_size; append_char(hc[j]);
				}
				s = make_string();
				#pragma region <Insert the pair (s,p) into the exception table 940>
				if (hyph_count == hyph_size) overflow(TEX_STRING("exception dictionary"), hyph_size);
				incr(hyph_count);
				while (hyph_word[h] != 0) {
					#pragma region <If the string hyph_word[h] is less than or equal to s, interchange .. 941>
					k = hyph_word[h];
					if (length(k) < length(s)) goto found;
					if (length(k) > length(s)) goto not_found;
					u = str_start[k]; v = str_start[s];
					do {
						if (str_pool[u] < str_pool[v]) goto found;
						if (str_pool[u] > str_pool[v]) goto not_found;
						incr(u); incr(v);
					} while (!(u == str_start[k + 1]));
				found:
					q = hyph_list[h]; hyph_list[h] = p; p = q;
					t = hyph_word[h]; hyph_word[h] = s; s = t;
				not_found:

				#pragma endregion
					if (h > 0) decr(h); else h = hyph_size;
				}
				hyph_word[h] = s; hyph_list[h] = p;
				#pragma endregion
			}
				#pragma endregion
			if (cur_cmd == right_brace) return;
			n = 0; p = null;
			break;

		default:
			#pragma region <Give improper hyphenation error 936>
			print_err(TEX_STRING("Improper "));
			print_esc(TEX_STRING("hyphenation"));
			print(TEX_STRING(" will be flushed"));
			help2(TEX_STRING("Hyphenation exceptions must contain only letters"),
				TEX_STRING("and hyphens. But continue; I'll forgive and forget."));
			error();
			#pragma endregion
			break;
		}
	}
	#pragma endregion
}

//987
void freeze_page_specs(small_number s)
{
	page_contents = s; page_goal = vsize; page_max_depth = max_depth;
	page_depth = 0;
	do_all_six(set_page_so_far_zero); least_page_cost = awful_bad;
	//stat
	if (tracing_pages > 0) {
		begin_diagnostic();
		print_nl(TEX_STRING("%% goal height=")); print_scaled(page_goal);
		print(TEX_STRING(", max depth=")); print_scaled(page_max_depth);
		end_diagnostic(false);
	}
	//tats
}

// 992
void box_error(eight_bits n)
{
	error();
	begin_diagnostic();
	print_nl(TEX_STRING("The following box has been deleted:"));
	show_box(box(n));
	end_diagnostic(true);
	flush_node_list(box(n));
	box(n) = null;
}

// 993
void ensure_vbox(eight_bits n)
{
	pointer p;

	p = box(n);
	if(p!=null)
		if (type(p) == hlist_node) {
			print_err(TEX_STRING("Insertions can only be added to a vbox"));
			help3(TEX_STRING("Tut tut: You're trying to \insert into a"),
				TEX_STRING("\box register that now contains an \hbox."),
				TEX_STRING("Proceed, and I'll discard its present contents."));
			box_error(n);
		}
}

// 994
void build_page()
{
	pointer p;
	pointer q, r;
	int b, c;
	int pi;
	unsigned char n;
	scaled delta, h, w;

	if (link(contrib_head) == null || output_active)
		return;
	do {
	my_continue:
		p = link(contrib_head);
		#pragma region <Update the values of last_glue, last_penalty, and last_kern 996>
		if (last_glue != max_halfword)
			delete_glue_ref(last_glue);
		last_penalty = 0; last_kern = 0;
		if (type(p) == glue_node) {
			last_glue = glue_ptr(p); add_glue_ref(last_glue);
		}
		else {
			last_glue = max_halfword;
			if (type(p) == penalty_node)
				last_penalty = penalty(p);
			else if (type(p) == kern_node)
				last_kern = width(p);
		}
		#pragma endregion

		#pragma region <Move node p to the current page; if it is time for a page break, .. 997>

		#pragma region <If the current page is empty and ndoe p is to be deleted... 1000>

		switch (type(p)) {
		case hlist_node:
		case vlist_node:
		case rule_node:
			if (page_contents < box_there) 
				#pragma region <Initialize the current page, insert the topskip glue ahead of p and goto continue 1001>
			{
				if (page_contents == empty)
					freeze_page_specs(box_there);
				else
					page_contents = box_there;
				q = new_skip_param(top_skip_code);
				if (width(temp_ptr) > height(p))
					width(temp_ptr) -= height(p);
				else width(temp_ptr) = 0;
				link(q) = p; link(contrib_head) = q;
				goto my_continue;

			}
				#pragma endregion
			else
				#pragma region <Prepare to move a box or rule node to the current page then goto contribute 1002>
			{
				page_total += page_depth + height(p);
				page_depth = depth(p);
				goto contribute;
			}
				#pragma endregion
			break;
		case whatsit_node:
			//<Prepare to move whatsit p to the current page, then goto contribute 1364>
			goto contribute;
			break;

		case glue_node:
			if (page_contents < box_there)
				goto done1;
			else if (precedes_break(page_tail))
				pi = 0;
			else goto update_heights;
			break;

		case kern_node:
			if (page_contents < box_there)
				goto done1;
			else if (link(p) == null)
				return;
			else if (type(link(p)) == glue_node)
				pi = 0;
			else goto update_heights;
			break;
		case penalty_node:
			if (page_contents < box_there)
				goto done1;
			else pi = penalty(p);
			break;
		case mark_node:
			goto contribute;
			break;
		case ins_node:
			#pragma region <Append an insertion to the current page and goto contribute 1008>
			if (page_contents == empty)
				freeze_page_specs(inserts_only);
			n = subtype(p); r = page_ins_head;
			while (n >= subtype(link(r))) r = link(r);

			n = qo(n);
			if (subtype(r) != qi(n)) 
				#pragma region <Create a page insertion node with subtype(r) = qi(n), and include the correction for box n in the current page state 1009>
			{
				q = get_node(page_ins_node_size);
				link(q) = link(r); link(r) = q; r = q; subtype(r) = qi(n);
				type(r) = inserting; ensure_vbox(n);
				if (box(n) == null)
					height(r) = 0;
				else height(r) = height(box(n)) + depth(box(n));
				best_ins_ptr(r) = null;
				q = skip(n);
				if (count(n) == 1000)
					h = height(r);
				else h = x_over_n(height(r), 1000)*count(n);
				page_goal -= h + width(q);
				page_so_far[2 + stretch_order(q)] += stretch(q);
				page_shrink += shrink(q);
				if (shrink_order(q) != normal && shrink(q) != 0) {
					print_err(TEX_STRING("Infinite glue shrinkage inserted from "));
					print_esc(TEX_STRING("skip"));
					print_int(n);
					help3(TEX_STRING("The correction glue for page breaking with insertions"),
						TEX_STRING("must have finite shrinkability. But you may proceed,"),
						TEX_STRING("since the offensive shrinkability has been made finite."));
					error();
				}
			}
				#pragma endregion
			if (type(r) == split_up)
				insert_penalties += float_cost(p);
			else {
				last_ins_ptr(r) = p; delta = page_goal - page_total - page_depth + page_shrink;
				if (count(n) == 1000)
					h = height(p);
				else
					h = x_over_n(height(p), 1000)*count(n);
				if ((h <= 0 || h <= delta) && height(p) + height(r) <= dimen(n)) {
					page_goal -= h; height(r) += height(p);
				}
				else
					#pragma region <Find the best way to split the insertion and change type(r) to split_up 1010>
				{
					if (count(n) <= 0)
						w = max_dimen;
					else {
						w = page_goal - page_total - page_depth;
						if (count(n) != 1000)
							w = x_over_n(w, count(n)) * 1000;
					}
					if (w > dimen(n) - height(r))
						w = dimen(n) - height(r);
					q = vert_break(ins_ptr(p), w, depth(p)); height(r) += best_height_plus_depth;
					//stat
					if (tracing_pages > 0)
						#pragma region <Display the insertion split cost 1011>
					{
						
						begin_diagnostic(); print_nl(TEX_STRING("% split"));
						print_int(n); print(TEX_STRING(" to ")); print_scaled(w);
						print_char(TEX_STRING(",")); print_scaled(best_height_plus_depth);
						print(TEX_STRING(" p="));
						if (q == null) print_int(eject_penalty);
						else if (type(q) == penalty_node) print_int(penalty(q));
						else print_char(TEX_STRING("0"));
						end_diagnostic(false);
					}
						#pragma endregion
					//tats
					if (count(n) != 1000)
						best_height_plus_depth = x_over_n(best_height_plus_depth, 1000)*count(n);
					page_goal -= best_height_plus_depth; type(r) = split_up; broken_ptr(r) = q;
					broken_ins(r) = p;
					if (q == null)
						insert_penalties += eject_penalty;
					else if (type(q) == penalty_node)
						insert_penalties += penalty(q);
				}
					#pragma endregion
			}
			goto contribute;
			#pragma endregion
			break;

		default:
			confusion(TEX_STRING("page"));
			break;
		}
		#pragma endregion

		#pragma region <Check if node p is a new champion breakpont; then ... 1005>

		if (pi < inf_penalty) {
			#pragma region <Compute the badness b of the current page using awful_bad if the box is too full 1007>

			if (page_total < page_goal) {
				if (page_so_far[3] != 0 || page_so_far[4] != 0 || page_so_far[5] != 0)
					b = 0;
				else
					b = badness(page_goal - page_total, page_so_far[2]);
			}
			else if (page_total - page_goal > page_shrink)
				b = awful_bad;
			else
				b = badness(page_total - page_goal, page_shrink);
			#pragma endregion

			if (b < awful_bad) {
				if (pi <= eject_penalty)
					c = pi;
				else if (b < inf_bad)
					c = b + pi + insert_penalties;
				else
					c = deplorable;
			}
			else
				c = b;
			if (insert_penalties >= 10000)
				c = awful_bad;
			//stat
			if (tracing_pages > 0) 
				#pragma region <Display the page break cost 1006>
			{
				begin_diagnostic();
				print_nl(TEX_STRING("%"));
				print(TEX_STRING(" t="));
				print_totals();
				print(TEX_STRING(" g=")); print_scaled(page_goal);
				print(TEX_STRING(" b="));
				if (b == awful_bad)
					print_char(TEX_STRING("*"));
				else
					print_int(b);
				print(TEX_STRING(" p=")); print_int(pi);
				print(TEX_STRING(" c="));
				if (c == awful_bad)
					print_char(TEX_STRING("*"));
				else
					print_int(c);
				if (c <= least_page_cost)
					print_char(TEX_STRING("#"));
				end_diagnostic(false);
			}
				#pragma endregion
			//tats
			if (c <= least_page_cost) {
				best_page_break = p; best_size = page_goal; least_page_cost = c;
				r = link(page_ins_head);
				while (r != page_ins_head) {
					best_ins_ptr(r) = last_ins_ptr(r); r = link(r);
				}
			}
			if (c == awful_bad || pi <= eject_penalty) {
				fire_up(p);
				if (output_active)
					return;
				goto done;
			}
		}
		#pragma endregion

		if (type(p) < glue_node || type(p) > kern_node)
			goto contribute;

update_heights:
		#pragma region <Update the current page measurements with respect to the glue or kern specified by node p 1004>
		if (type(p) == kern_node)
			q = p;
		else {
			q = glue_ptr(p);
			page_so_far[2 + stretch_order(q)] += stretch(q);
			page_shrink += shrink(q);
			if (shrink_order(q) != normal && shrink(q) != 0) {
				print_err(TEX_STRING("Infinite glue shrinkage found on current page"));
				help4(TEX_STRING("The page about to be output contains some infinitely"),
					TEX_STRING("shrinkable glue, e.g., `\vss' or `\vskip 0pt minus 1fil'."),
					TEX_STRING("Such glue doesn't belong there; but you can safely proceed,"),
					TEX_STRING("since the offensive shrinkability has been made finite."));
				error();
				r = new_spec(q);
				shrink_order(r) = normal; delete_glue_ref(q); glue_ptr(p) = r; q = r;
			}
		}
		page_total += page_depth + width(q); page_depth = 0;
		#pragma endregion

contribute:
		#pragma region <Make sure that page_max_depth is not exceeded 1003>
		if (page_depth > page_max_depth) {
			page_total = page_total + page_depth - page_max_depth;
			page_depth = page_max_depth;
		}
		#pragma endregion

		#pragma region <Link node p into the current page and goto done 998>
		link(page_tail) = p; page_tail = p; link(contrib_head) = link(p); link(p) = null;
		goto done;
		#pragma endregion
done1:
		#pragma region <Recycle node p 999>
		link(contrib_head) = link(p); link(p) = null; flush_node_list(p);
		#pragma endregion
done:

		;

#pragma endregion
	} while (!(link(contrib_head) == null));

#pragma region <Make the contribution list empty by setting its tail to contrib_head 995>
	if (nest_ptr == 0)
		tail = contrib_head;
	else
		contrib_tail = contrib_head;
#pragma endregion
}

// 1265
void new_interaction()
{
	print_ln();
	if (cur_chr > 255) {
		printf("overflow in 1265\n");
		exit(1);
	}
	interaction = (unsigned char)cur_chr;
	#pragma region <Initialize the print selector based on interaction 75>
	if (interaction == batch_mode) selector = no_print; else selector = term_only;
	#pragma endregion
	if (log_opened)
		selector = selector + 2;
}

// 1049
void you_cant()
{
	print_err(TEX_STRING("You can't use `"));
	print_cmd_chr(cur_cmd, cur_chr);
	print(TEX_STRING("' in "));
	print_mode(mode);
}


// 1050
void report_illegal_case()
{
	you_cant();
	help4(TEX_STRING("Sorry, but I'm not programmed to handle this case;"),
		TEX_STRING("I'll just pretend that you didn't ask for it."),
		TEX_STRING("If you're in the wrong mode, you might be able to"),
		TEX_STRING("return to the right one by typing `I}' or `I$' or `I\par'."));
	error();
}

// 1051
bool privileged()
{
	if (mode > 0)
		return true;
	else {
		report_illegal_case();
		return false;
	}
}

// 1241
void fix_date_and_time()
{
	time = 12 * 60;
	day = 4;
	month = 7;
	year = 1776;
}

// 1257
void new_font(small_number a)
{
	pointer u;
	scaled s;
	internal_font_number f;
	str_number t;
	unsigned int old_setting;
	str_number flushable_string;

	if (job_name == null)
		open_log_file();
	get_r_token();
	u = cur_cs;
	if (u >= hash_base)
		t = text(u);
	else if (u >= single_base) 
		if (u == null_cs)
			t = TEX_STRING("FONT");
		else
			t = u - single_base;
	
	else {
		old_setting = selector; selector = new_string; print(TEX_STRING("FONT"));
		print(u - active_base);
		selector = old_setting; str_room(1); t = make_string();
	}
	define(u, set_font, null_font); scan_optional_equals(); scan_file_name();

	#pragma region <Scan the font size specification 1258>
	name_in_progress = true;
	if (scan_keyword(TEX_STRING("at"))) {
		//<Put the (positive) at size int s 1259>
		scan_normal_dimen; s = cur_val;
		if (s <= 0 || s >= 01000000000) {
			print_err(TEX_STRING("Improper `at' size ("));
			print_scaled(s); print(TEX_STRING("pt), replaced by 10pt"));
			help2(TEX_STRING("I can only handle fonts at positive sizes that are"),
				TEX_STRING("less than 2048pt, so I've changed what you said to 10pt."));
			error();
			s = 10 * unity;
		}
	}
	else if (scan_keyword(TEX_STRING("scaled"))) {
		scan_int(); s = -cur_val;
		if (cur_val <= 0 || cur_val > 32768) {
			print_err(TEX_STRING("Illegal magnification has been changed to 1000"));
			help1(TEX_STRING("The magnification ratio must be between 1 and 32768."));
			int_error(cur_val);
			s = -1000;
		}
	}
	else
		s = -1000;
	name_in_progress = false;

	#pragma endregion
	
	#pragma region <If this font has already been loaded set f to the internal font number and goto common_ending 1260>
	flushable_string = str_ptr - 1;
	for (f = font_base + 1; f <= font_ptr; f++)
		if (str_eq_str(font_name[f], cur_name) && str_eq_str(font_area[f], cur_area)) {
			if (cur_name == flushable_string) {
				flush_string; cur_name = font_name[f];
			}
			if (s > 0) {
				if (s == font_size[f]) goto common_ending;
			}
			else if (font_size[f] == xn_over_d(font_dsize[f], -s, 1000)) goto common_ending;
		}

	#pragma endregion

	f = read_font_info(u, cur_name, cur_area, s);

common_ending:
	equiv(u) = f; eqtb[font_id_base + f] = eqtb[u]; font_id_text(f) = t;
}

// 1338
// skip implementing this for now
// debug
void debug_help()
{

}
// gubed

// 1284
void give_err_help()
{
	token_show(err_help);
}

// 1335
void final_cleanup()
{
	small_number c;
	c = cur_chr;
	if (job_name == 0)
		open_log_file();
	while (input_ptr > 0) {
		if (state == token_list)
			end_token_list();
		else
			end_file_reading();
	}
	while (open_parens > 0) {
		print(TEX_STRING(" )"));
		decr(open_parens);
	}
	if (cur_level > level_one) {
		print_nl(TEX_STRING("("));
		print_esc(TEX_STRING("end occurred "));
		print(TEX_STRING("inside a group at level "));
		print_int(cur_level - level_one); print_char(TEX_STRING(")"));
	}
	while (cond_ptr != null) {
		print_nl(TEX_STRING("("));
		print_esc(TEX_STRING("end occurred "));
		print(TEX_STRING("when "));
		print_cmd_chr(if_test, cur_if);
		if (if_line != 0) {
			print(TEX_STRING(" on line ")); print_int(if_line);

		}
		print(TEX_STRING(" was incomplete)")); if_line = if_line_field(cond_ptr); cur_if = subtype(cond_ptr);
		temp_ptr = cond_ptr; cond_ptr = link(cond_ptr); free_node(temp_ptr, if_node_size);
	}
	if (history != spotless) {
		if (history == warning_issued || interaction < error_stop_mode) {
			if (selector == term_and_log) {
				selector = term_only;
				print_nl(TEX_STRING("(see the transcript file for additional information)"));
				selector = term_and_log;
			}
		}
	}
	if (c == 1) {
		// init
		for (c = top_mark_code; c <= split_bot_mark_code; c++) {
			if (cur_mark[c] != null)
				delete_token_ref(cur_mark[c]);
		}
		if (last_glue != max_halfword)
			delete_glue_ref(last_glue);
		store_fmt_file();


		return;
		// tini
		print_nl(TEX_STRING("(\dump is performed only by INITEX)"));
		return;
	}

}

// 440
void scan_int()
{
	bool negative;
	int m;
	small_number d;
	bool vacuous;
	bool OK_so_far;


	radix = 0;
	OK_so_far = true;
	#pragma region <Get the next non_blank non-sign token; set negative appropriately 441>
	negative = false;
	do {
		#pragma region <Get the next non-blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion

		if (cur_tok == other_token + TEX_STRING("-")) {
			negative = !negative; cur_tok = other_token + TEX_STRING("+");
		}
	} while (!(cur_tok != other_token + TEX_STRING("+")));

	#pragma endregion

	if (cur_tok == alpha_token)
		#pragma region <Scan an alphabetic character code into cur_val 442>
	{		
		get_token();
		if (cur_tok < cs_token_flag) {
			cur_val = cur_chr;
			if (cur_cmd <= right_brace)
				if (cur_cmd == right_brace)
					incr(align_state);
				else
					decr(align_state);
		}
		else if (cur_tok < cs_token_flag + single_base)
			cur_val = cur_tok - cs_token_flag - active_base;
		else
			cur_val = cur_tok - cs_token_flag - single_base;
		if (cur_val > 255) {
			print_err(TEX_STRING("Improper alphabetic constant"));
			help2(TEX_STRING("A one-character control sequence belongs after a ` mark."),
				TEX_STRING("So I'm essentially inserting \0 here."));
			cur_val = TEX_STRING("0");
			back_error();
		}
		else 
			#pragma region <Scan an optional space 443>
		{
			get_x_token();
			if (cur_cmd != spacer)
				back_input();
		}
			#pragma endregion
		
	}
		#pragma endregion
	else if (cur_cmd >= min_internal && cur_cmd <= max_internal)
		scan_something_internal(int_val, false);
	else 
		#pragma region <Scan a numeric constant 444>
	{
		
		radix = 10; m = 214748364;
		if (cur_tok == octal_token) {
			radix = 8; m = 02000000000;
			get_x_token();
		}
		else if (cur_tok == hex_token) {
			radix = 16; m = 01000000000;
			get_x_token();
		}
		vacuous = true; cur_val = 0;

		#pragma region <Accumulate the constant until cur_toks is not a suitable digit 445>
		while (1) {
			if (cur_tok < zero_token + radix && cur_tok >= zero_token && cur_tok <= zero_token + 9)
				d = cur_tok - zero_token;
			else if (radix == 16)
				if (cur_tok <= A_token + 5 && cur_tok >= A_token) d = cur_tok - A_token + 10;
				else if (cur_tok <= other_A_token + 5 && cur_tok >= other_A_token)
					d = cur_tok - other_A_token + 10;
				else goto done;
			else goto done;
			vacuous = false;
			if (cur_val >= m && (cur_val > m || d > 7 || radix != 10)) {
				if (OK_so_far) {
					print_err(TEX_STRING("Number too big"));
					help2(TEX_STRING("I can only go up to 2147483647='17777777777=""7FFFFFFF,"),
						TEX_STRING("so I'm using that number instead of yours."));
					error();
					cur_val = infinity;
					OK_so_far = false;
				}
			}
			else cur_val = cur_val * radix + d;
			get_x_token();
		}
	done:

		#pragma endregion

		if (vacuous) 
			#pragma region <Express astonishment that no number was here 446>
		{
			print_err(TEX_STRING("Missing number, treated as zero"));
			help3(TEX_STRING("A number should have been here; I inserted `0'."),
				TEX_STRING("(If you can't figure out why I needed to see a number,"),
				TEX_STRING("look up `weird error' in the index to The TeXbook.)"));
			back_error();
		}
			#pragma endregion
		else if (cur_cmd != spacer) back_input();
	}
		#pragma endregion

	if (negative)
		negate(cur_val);
}


// 407
bool scan_keyword(str_number s)
{
	pointer p;
	pointer q;
	pool_pointer k;
	p = backup_head; link(p) = null; k = str_start[s];

	while (k < str_start[s + 1]) {
		get_x_token();
		if (cur_cs == 0 && (cur_chr == so(str_pool[k]) || cur_chr == so(str_pool[k]) - TEX_STRING("a") +
			TEX_STRING("A"))) {
			store_new_token(cur_tok); incr(k);
		}
		else if (cur_cmd != spacer || p != backup_head) {
			back_input();
			if (p != backup_head)
				back_list(link(backup_head));
			return false;
		}
	}
	flush_list(link(backup_head));
	return true;
}

// 434
void scan_char_num()
{
	scan_int();
	if (cur_val < 0 || cur_val > 255) {
		print_err(TEX_STRING("Bad character code"));
		help2(TEX_STRING("A character number must be between 0 and 255."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

// 537
void start_input()
{
	scan_file_name();
	if (cur_ext == TEX_STRING(""))
		cur_ext = TEX_STRING(".tex");
	pack_cur_name;
	while (1) {
		begin_file_reading();
		if (a_open_in(&cur_file)) goto done;
		if (cur_area == TEX_STRING("")) {
			pack_file_name(cur_name, TEX_area, cur_ext);
			if (a_open_in(&cur_file)) goto done;
		}
		end_file_reading();
		prompt_file_name(TEX_STRING("input file name"),
			TEX_STRING(".tex"));
	}
done:
	name = a_make_name_string(cur_file);
	if (job_name == 0) {
		job_name = cur_name; open_log_file();
	}
	if (term_offset + length(name) > max_print_line - 2) print_ln();
	else if (term_offset > 0 || file_offset > 0) print_char(TEX_STRING(" "));
	print_char(TEX_STRING("(")); incr(open_parens); slow_print(name); update_terminal(); state = new_line;
	if (name == str_ptr - 1) {
		flush_string;
		name = cur_name;
	}
	#pragma region <Read the first line of the new file 538>
	line = 1;

#pragma warning(push)
#pragma warning(disable : 4390)
	if (input_ln(cur_file, false))
		; // do_nothing
#pragma warning(pop)
	firm_up_the_line();
	if (end_line_char_inactive) decr(limit);
	else buffer[limit] = end_line_char;
	first = limit + 1; loc = start;
	#pragma endregion
}


// 1054
bool its_all_over()
{
	if (privileged()) {
		if (page_head == page_tail && head == tail && dead_cycles == 0) {
			return true;
		}
		back_input();
		tail_append(new_null_box()); width(tail) = hsize; tail_append(new_glue(fill_glue));
		tail_append(new_penalty(-010000000000));
		build_page();
	}
	return false;
}

// 1194
void after_math()
{
	bool l;
	bool danger;
	int m;
	pointer p;
	pointer a;
	#pragma region <Local varaibles for finishing a displayed formula 1198>
	pointer b;
	scaled w;
	scaled z;
	scaled e;
	scaled q;
	scaled d;
	scaled s;
	small_number g1, g2;
	pointer r;
	pointer t;
	#pragma endregion

	danger = false;
	#pragma region <Check that the necessary fonts for math symbols are present; if not flush the current math lists and set danger = true 1195>
	if (font_params[fam_fnt(2 + text_size)] < total_mathsy_params ||
		font_params[fam_fnt(2 + script_size)] < total_mathsy_params ||
		font_params[fam_fnt(2 + script_script_size)] < total_mathsy_params) {
		print_err(TEX_STRING("Math formula deleted: Insufficient symbol fonts"));
		help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 2"),
			TEX_STRING("and \scriptfont 2 and \scriptscriptfont 2 have all"),
			TEX_STRING("the \fontdimen values needed in math symbol fonts."));
		error();
		flush_math();
		danger = true;
	}
	else if (font_params[fam_fnt(3 + text_size)] < total_mathex_params ||
		font_params[fam_fnt(3 + script_size)] < total_mathex_params ||
		font_params[fam_fnt(3 + script_script_size)] < total_mathex_params) {
		print_err(TEX_STRING("Math formula deleted: Insufficient extension fonts"));
		help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 3"),
			TEX_STRING("and \scriptfont 3 and \scriptscriptfont 3 have all"),
			TEX_STRING("the \fontdimen values needed in math extension fonts."));
		error();
		flush_math();
		danger = true;
	}
	#pragma endregion

	m = mode; l = false; p = fin_mlist(null);
	if (mode == -m) {
		#pragma region <Check that another $ follows 1197>
		{
			get_x_token();
			if (cur_cmd != math_shift) {
				print_err(TEX_STRING("Display math should end with $$"));
				help2(TEX_STRING("The `$' that I just saw supposedly matches a previous `$$'."),
					TEX_STRING("So I shall assume that you typed `$$' both times."));
				back_error();
			}
		}
		#pragma endregion

		cur_mlist = p; cur_style = text_style; mlist_penalties = false; mlist_to_hlist();
		a = hpack(link(temp_head), 0, additional); unsave(); decr(save_ptr);
		if (saved(0) == 1) l = true;
		danger = false;
		#pragma region <Check that the necessary fonts for math symbols are presnet; if nt flush the current math lists adn set danger = true 1195>
		if (font_params[fam_fnt(2 + text_size)] < total_mathsy_params ||
			font_params[fam_fnt(2 + script_size)] < total_mathsy_params ||
			font_params[fam_fnt(2 + script_script_size)] < total_mathsy_params) {
			print_err(TEX_STRING("Math formula deleted: Insufficient symbol fonts"));
			help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 2"),
				TEX_STRING("and \scriptfont 2 and \scriptscriptfont 2 have all"),
				TEX_STRING("the \fontdimen values needed in math symbol fonts."));
			error();
			flush_math();
			danger = true;
		}
		else if (font_params[fam_fnt(3 + text_size)] < total_mathex_params ||
			font_params[fam_fnt(3 + script_size)] < total_mathex_params ||
			font_params[fam_fnt(3 + script_script_size)] < total_mathex_params) {
			print_err(TEX_STRING("Math formula deleted: Insufficient extension fonts"));
			help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 3"),
				TEX_STRING("and \scriptfont 3 and \scriptscriptfont 3 have all"),
				TEX_STRING("the \fontdimen values needed in math extension fonts."));
			error();
			flush_math();
			danger = true;
		}
		#pragma endregion
		m = mode; p = fin_mlist(null);
	}
	else a = null;
	if (m < 0) 
		#pragma region <Finish math in text 1196>
	{
		//
		tail_append(new_math(math_surround, before)); cur_mlist = p; cur_style = text_style;
		mlist_penalties = (mode > 0); mlist_to_hlist(); link(tail) = link(temp_head);
		while (link(tail) != null) tail = link(tail);
		tail_append(new_math(math_surround, after)); space_factor = 1000; unsave();
	}
		#pragma endregion
	else {
		if (a == null) 
			#pragma region <Check that another $ follows 1197>
		{
			get_x_token();
			if (cur_cmd != math_shift) {
				print_err(TEX_STRING("Display math should end with $$"));
				help2(TEX_STRING("The `$' that I just saw supposedly matches a previous `$$'."),
					TEX_STRING("So I shall assume that you typed `$$' both times."));
				back_error();
			}
		}
			#pragma endregion
		#pragma region <Finish displayed math 1199>
		cur_mlist = p; cur_style = display_style; mlist_penalties = false; mlist_to_hlist(); p = link(temp_head);
		adjust_tail = adjust_head; b = hpack(p, 0, additional); p = list_ptr(b); t = adjust_tail; adjust_tail = null;
		w = width(b); z = display_width; s = display_indent;
		if (a == null || danger) {
			e = 0; q = 0;
		}
		else {
			e = width(a); q = e + math_quad(text_size);
		}
		if (w + q > z) 
			#pragma region <Squeeze the equation as much as possible if ther is an equaton number that should go on a separate line by itself, set e = 0 1201>
		{
			if (e != 0 && (w - total_shrink[normal] + q <= z || total_shrink[fil] != 0 ||
				total_shrink[fill] != 0 || total_shrink[filll]!=0)) {
				free_node(b, box_node_size); b = hpack(p, z - q, exactly);
			}
			else {
				e = 0;
				if (w > z) {
					free_node(b, box_node_size); b = hpack(p, z, exactly);
				}
			}
			w = width(b);
		}
			#pragma endregion

		#pragma region <Determine the displacement, d of the left edge of the equation with respect to the line size z assuming that l = false 1202>
		d = half(z - w);
		if (e > 0 && d < 2 * e) {
			d = half(z - w - e);
			if (p != null)
				if (!is_char_node(p))
					if (type(p) == glue_node)
						d = 0;
		}
		#pragma endregion

		#pragma region <Append the glue or equation number preceding the display 1203>
		tail_append(new_penalty(pre_display_penalty));
		if (d + s <= pre_display_size || l) {
			g1 = above_display_skip_code; g2 = below_display_skip_code;
		}
		else {
			g1 = above_display_short_skip_code; g2 = below_display_short_skip_code;
		}
		if (l && (e == 0)) {
			shift_amount(a) = s; append_to_vlist(a); tail_append(new_penalty(inf_penalty));
		}
		else tail_append(new_param_glue(g1));
		#pragma endregion

		#pragma region <Append the display and perhaps also the equation number 1204>
		if (e != 0) {
			r = new_kern(z - w - e - d);
			if (l) {
				link(a) = r; link(r) = b; b = a; d = 0;
			}
			else {
				link(b) = r; link(r) = a;
			}
			b = hpack(b, 0, additional);
		}
		shift_amount(b) = s + d; append_to_vlist(b);
		#pragma endregion

		#pragma region <Append the glue or equation number folllowing the display 1205>
		if (a != null && e == 0 && !l) {
			tail_append(new_penalty(inf_penalty)); shift_amount(a) = s + z - width(a); append_to_vlist(a);
			g2 = 0;
		}
		if (t != adjust_head) {
			link(tail) = link(adjust_head); tail = t;
		}
		tail_append(new_penalty(post_display_penalty));
		if (g2 > 0) tail_append(new_param_glue(g2));
		#pragma endregion

		resume_after_display();
		#pragma endregion
	}
}


// 1211
void prefixed_command()
{
	small_number a;
	internal_font_number f;
	halfword j;
	font_index k;
	pointer p, q;
	int n;
	bool e;


	a = 0;
	while (cur_cmd == prefix) {
		if (!myodd(a / cur_chr))
			a = a + cur_chr;
		#pragma region <Get the next non-blank non-relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion

		if (cur_cmd <= max_non_prefixed_command)
			#pragma region <Discard erroneous prefixes and return 1212>
		{
			print_err(TEX_STRING("You can't use a prefix with `")); print_cmd_chr(cur_cmd, cur_chr);
			print_char(TEX_STRING("'"));
			help1(TEX_STRING("I'll pretend you didn't say \long or \outer or \global."));
			back_error();
			return;
		}
			#pragma endregion
	}
	#pragma region <Discard the prefixes long and outer if they are irrelevant 1213>
	if (cur_cmd != def && (a % 4 != 0)) {
		print_err(TEX_STRING("You can't use `"));
		print_esc(TEX_STRING("long"));
		print(TEX_STRING("' or `"));
		print_esc(TEX_STRING("outer"));
		print(TEX_STRING("' with `")); print_cmd_chr(cur_cmd, cur_chr);
		print_char(TEX_STRING("'"));
		help1(TEX_STRING("I'll pretend you didn't say \long or \outer here."));
		error();
	}
	#pragma endregion

	#pragma region <Adjust for the setting of globaldefs 1214>
	if(global_defs != 0)
		if (global_defs < 0) {
			if (global) a -= 4;
		}
		else {
			if (!global) a += 4;
		}
	#pragma endregion

	switch (cur_cmd) {
	#pragma region <Assignments 1217>

		//1218
	case set_font:
		define(cur_font_loc, data, cur_chr);
		break;
	case def:
		if (myodd(cur_chr) && !global && global_defs >= 0)
			a = a + 4;
		e = (cur_chr >= 2);
		get_r_token();
		p = cur_cs;
		q = scan_toks(true, e);
		define(p, call + (a % 4), def_ref);
		break;
		//1221
	case let:
		n = cur_chr;
		get_r_token();
		p = cur_cs;
		if (n == normal) {
			do {
				get_token();
			} while (!(cur_cmd != spacer));
			if (cur_tok == other_token + TEX_STRING("=")) {
				get_token();
				if (cur_cmd == spacer)
					get_token();
			}
		}
		else {
			get_token();
			q = cur_tok;
			get_token();
			back_input();
			cur_tok = q;
			back_input();
		}
		if (cur_cmd >= call)
			add_token_ref(cur_chr);
		define(p, cur_cmd, cur_chr);
		break;
		//1224
	case shorthand_def:
		n = cur_chr;
		get_r_token();
		p = cur_cs;
		define(p, relax, 256);
		scan_optional_equals();
		switch (n) {
		case char_def_code:
			scan_char_num();
			define(p, char_given, cur_val);
			break;
		case math_char_def_code:
			scan_fifteen_bit_int();
			define(p, math_given, cur_val);
			break;
		default:
			scan_eight_bit_int();
			switch (n) {
			case count_def_code:
				define(p, assign_int, count_base + cur_val);
				break;
			case dimen_def_code:
				define(p, assign_dimen, scaled_base + cur_val);
				break;
			case skip_def_code:
				define(p, assign_glue, skip_base + cur_val);
				break;
			case mu_skip_def_code:
				define(p, assign_mu_glue, mu_skip_base + cur_val);
				break;
			case toks_def_code:
				define(p, assign_toks, toks_base + cur_val);
				break;
			}
		}
		break;
		//1225
	case read_to_cs:
		scan_int();
		n = cur_val;
		if (!scan_keyword(TEX_STRING("to"))) {
			print_err(TEX_STRING("Missing `to' inserted"));
			help2(TEX_STRING("You should have said `\read<number> to \cs'."),
				TEX_STRING("I'm going to look for the \cs now."));
			error();
		}
		get_r_token();
		p = cur_cs;
		read_toks(n, p);
		define(p, call, cur_val);
		break;
		//1226
	case toks_register:
	case assign_toks:
		q = cur_cs;
		if (cur_cmd == toks_register) {
			scan_eight_bit_int();
			p = toks_base + cur_val;
		}
		else
			p = cur_chr;
		scan_optional_equals();
		#pragma region <Get the next non-blank non-relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion
		if (cur_cmd != left_brace) 
			#pragma region <If the right-hand side is a token parameter or token register, finish the assignment and goto done 1227>
		{
			if (cur_cmd == toks_register) {
				scan_eight_bit_int();
				cur_cmd = assign_toks;
				cur_chr = toks_base + cur_val;
			}
			if (cur_cmd == assign_toks) {
				q = equiv(cur_chr);
				if (q == null) define(p, undefined_cs, null);
				else {
					add_token_ref(q); define(p, call, q);
				}
				goto done;
			}
		}
			#pragma endregion

		back_input();
		cur_cs = q;
		q = scan_toks(false, false);
		if (link(def_ref) == null) {
			define(p, undefined_cs, null);
			free_avail(def_ref);
		}
		else {
			if (p == output_routine_loc) {
				link(q) = get_avail(); q = link(q); info(q) = right_brace_token + TEX_STRING("}");
				q = get_avail();
				info(q) = left_brace_token + TEX_STRING("{"); link(q) = link(def_ref); link(def_ref) = q;
			}
			define(p, call, def_ref);
		}

		break;
		//1228
	case assign_int:
		p = cur_chr;
		scan_optional_equals();
		scan_int();
		word_define(p, cur_val);
		break;
	case assign_dimen:
		p = cur_chr;
		scan_optional_equals();
		scan_normal_dimen;
		word_define(p, cur_val);
		break;

	case assign_glue:
	case assign_mu_glue:
		p = cur_chr;
		n = cur_cmd;
		scan_optional_equals();
		if (n == assign_mu_glue)
			scan_glue(mu_val);
		else
			scan_glue(glue_val);
		trap_zero_glue();
		define(p, glue_ref, cur_val);
		break;
		//1232
	case def_code:
		#pragma region <Let ne be the largest legal code value, based on cur_chr 1233>
		if (cur_chr == cat_code_base) n = max_char_code;
		else if (cur_chr == math_code_base) n = 0100000;
		else if (cur_chr == sf_code_base) n = 077777;
		else if (cur_chr == del_code_base) n = 077777777;
		else n = 255;
		#pragma endregion
		p = cur_chr;
		scan_char_num();
		p = p + cur_val;
		scan_optional_equals();
		scan_int();
		if (cur_val < 0 && p < del_code_base || cur_val > n) {
			print_err(TEX_STRING("Invalid code (")); print_int(cur_val);
			if (p < del_code_base)
				print(TEX_STRING("), should be in the range 0.."));
			else print(TEX_STRING("), should be at most "));
			print_int(n);
			help1(TEX_STRING("I'm going to use 0 instead of that illegal code value."));
			error();
			cur_val = 0;
		}
		if (p < math_code_base)
			define(p, data, cur_val);
		else if (p < del_code_base)
			define(p, data, hi(cur_val));
		else
			word_define(p, cur_val);

		break;
		//1234
	case def_family:
		p = cur_chr;
		scan_four_bit_int();
		p = p + cur_val;
		scan_optional_equals();
		scan_font_ident();
		define(p, data, cur_val);
		break;
		//1235
	case _register:
	case advance:
	case multiply:
	case divide:
		do_register_command(a);
		break;
		//1241
	case set_box:
		scan_eight_bit_int();
		if (global)
			n = 256 + cur_val;
		else
			n = cur_val;
		scan_optional_equals();
		if (set_box_allowed)
			scan_box(box_flag + n);
		else {
			print_err(TEX_STRING("Improper "));
			print_esc(TEX_STRING("setbox"));
			help2(TEX_STRING("Sorry, \setbox is not allowed after \halign in a display,"),
				TEX_STRING("or between \accent and an accented character."));
			error();
		}
		break;
		//1242
	case set_aux:
		alter_aux();
		break;
	case set_prev_graf:
		alter_prev_graf();
		break;
	case set_page_dimen:
		alter_page_so_far();
		break;
	case set_page_int:
		alter_integer();
		break;
	case set_box_dimen:
		alter_box_dimen();
		break;
		//1217
	case set_shape:
		scan_optional_equals();
		scan_int();
		n = cur_val;
		if (n <= 0)
			p = null;
		else {
			p = get_node(2 * n + 1); info(p) = n;
			for (j = 1; j <= n; j++) {
				scan_normal_dimen; mem[p + 2 * j - 1].sc = cur_val;
				scan_normal_dimen; mem[p + 2 * j].sc = cur_val;
			}
		}
		define(par_shape_loc, shape_ref, p);
		break;
		//1217
	case hyph_data:
		if (cur_chr == 1) {
			//init
			new_patterns();
			goto done;
			//tini
			print_err(TEX_STRING("Patterns can be loaded only by INITEX"));
			help0;
			error();
			do {
				get_token();
			} while (!(cur_cmd == right_brace));
			return;
		}
		else {
			new_hyph_exceptions();
			goto done;
		}
		break;
		// 1217
	case assign_font_dimen:
		find_font_dimen(true);
		k = cur_val;
		scan_optional_equals();
		scan_normal_dimen;
		font_info[k].sc = cur_val;
		break;
	case assign_font_int:
		n = cur_chr;
		scan_font_ident();
		f = cur_val;
		scan_optional_equals();
		scan_int();
		if (n == 0)
			hyphen_char[f] = cur_val;
		else
			skew_char[f] = cur_val;
		break;
		//1256
	case def_font:
		new_font(a);
		break;
		//1264
	case set_interaction:
		new_interaction();
		break;


	#pragma endregion

	default:
		confusion(TEX_STRING("prefix"));
		break;
	}
done:
	#pragma region <Insert a token saved by afterassignment, if any 1269>
	if (after_token) {
		cur_tok = after_token;
		back_input();
		after_token = 0;
	}
	#pragma endregion
}

// 1012
void fire_up(pointer c)
{
	pointer p, q, r, s;
	pointer prev_p;
	unsigned char n;
	bool wait;
	int save_vbadness;
	scaled save_vfuzz;
	pointer save_split_top_skip;

	#pragma region <Set the value of output_penalty 1013>
	if (type(best_page_break) == penalty_node) {
		geq_word_define(int_base + output_penalty_code, penalty(best_page_break));
		penalty(best_page_break) = inf_penalty;
	}
	else geq_word_define(int_base + output_penalty_code, inf_penalty);
	#pragma endregion
	
	if (bot_mark != null) {
		if (top_mark != null)
			delete_token_ref(top_mark);
		top_mark = bot_mark; add_token_ref(top_mark); delete_token_ref(first_mark);
		first_mark = null;
	}
	#pragma region <Put the optimal current page into box 255 update first_mark and bot_mark append insertions to their boxes and put the remianiing ndoes bac on teh contribution list 1014>
	if (c == best_page_break) best_page_break = null;
	#pragma region <Ensure that box 255 is empty before output 1015>
	if (box(255) != null) {
		print_err(TEX_STRING(""));
		print_esc(TEX_STRING("box"));
		print(TEX_STRING("255 is not void"));
		help2(TEX_STRING("You shouldn't use \box255 except in \output routines."),
			TEX_STRING("Proceed, and I'll discard its present contents."));
		box_error(255);
	}
	#pragma endregion

	insert_penalties = 0;
	save_split_top_skip = split_top_skip;
	if (holding_inserts <= 0) 
		#pragma region <Prepare all the boxes involved in insertions to act as queues 1018>
	{
		r = link(page_ins_head);
		while (r != page_ins_head) {
			if (best_ins_ptr(r) != null) {
				n = qo(subtype(r)); ensure_vbox(n);
				if (box(n) == null) box(n) = new_null_box();
				p = box(n) + list_offset;
				while (link(p) != null) p = link(p);
				last_ins_ptr(r) = p;
			}
			r = link(r);
		}
	}
		#pragma endregion
	q = hold_head; link(q) = null; prev_p = page_head; p = link(prev_p);
	while (p != best_page_break) {
		if (type(p) == ins_node) {
			if (holding_inserts <= 0) 
				#pragma region <Either insert the material specified by node p into the appropriate box, or hold it for the next page; also delete node p from the current page 1020>
			{
				r = link(page_ins_head);
				while (subtype(r) != subtype(p)) r = link(r);
				if (best_ins_ptr(r) == null) wait = true;
				else {
					wait = false; s = last_ins_ptr(r); link(s) = ins_ptr(p);
					if (best_ins_ptr(r) == p) 
						#pragma region <Wrap up the box specified by node r, splitting node p if called for set wait = true if node p holds a remainder after splitting 1021>
					{
						
						if(type(r) == split_up)
							if (broken_ins(r) == p && broken_ptr(r) != null) {
								while (link(s) != broken_ptr(r)) s = link(s);
								link(s) = null; split_top_skip = split_top_ptr(p); ins_ptr(p) = prune_page_top(broken_ptr(r));
								if (ins_ptr(p) != null) {
									temp_ptr = vpack(ins_ptr(p), 0, additional); height(p) = height(temp_ptr) + depth(temp_ptr);
									free_node(temp_ptr, box_node_size); wait = true;
								}
							}
						best_ins_ptr(r) = null; n = qo(subtype(r)); temp_ptr = list_ptr(box(n));
						free_node(box(n), box_node_size); box(n) = vpack(temp_ptr, 0, additional);
					}
						#pragma endregion
					else {
						while (link(s) != null) s = link(s);
						last_ins_ptr(r) = s;
					}
				}
				#pragma region <Either append the insertion node p after node q, and remove it from the current page, or delete node(p) 1022>
				link(prev_p) = link(p); link(p) = null;
				if (wait) {
					link(q) = p; q = p; incr(insert_penalties);
				}
				else {
					delete_glue_ref(split_top_ptr(p)); free_node(p, ins_node_size);
				}
				p = prev_p;
				#pragma endregion
			}
				#pragma endregion
		}
		else if (type(p) == mark_node) 
			#pragma region <Update the values of first_mark and bot_mark 1016>
		{
			if (first_mark == null) {
				first_mark = mark_ptr(p); add_token_ref(first_mark);
			}
			if (bot_mark != null) delete_token_ref(bot_mark);
			bot_mark = mark_ptr(p); add_token_ref(bot_mark);
		}
			#pragma endregion
		prev_p = p; p = link(prev_p);
	}
	split_top_skip = save_split_top_skip;
	#pragma region <Break the current page at node p, put it in box 255, and put the remaining nodes on the contribution list 1017>
	if (p != null) {
		if (link(contrib_head) == null)
			if (nest_ptr == 0) tail = page_tail;
			else contrib_tail = page_tail;
		link(page_tail) = link(contrib_head); link(contrib_head) = p; link(prev_p) = null;
	}
	save_vbadness = vbadness; vbadness = inf_bad; save_vfuzz = vfuzz; vfuzz = max_dimen;
	box(255) = vpackage(link(page_head), best_size, exactly, page_max_depth);
	vbadness = save_vbadness;
	vfuzz = save_vfuzz;
	if (last_glue != max_halfword) delete_glue_ref(last_glue);
	#pragma region <Start a new current page 991>
	page_contents = empty; page_tail = page_head; link(page_head) = null;
	last_glue = max_halfword; last_penalty = 0; last_kern = 0; page_depth = 0; page_max_depth = 0;
	#pragma endregion
	
	if (q != hold_head) {
		link(page_head) = link(hold_head); page_tail = q;
	}
	#pragma endregion

	#pragma region <Delete the page-insertion nodes 1019>
	r = link(page_ins_head);
	while (r != page_ins_head) {
		q = link(r); free_node(r, page_ins_node_size); r = q;
	}
	link(page_ins_head) = page_ins_head;
	#pragma endregion

	#pragma endregion
	if (top_mark != null && first_mark == null) {
		first_mark = top_mark; add_token_ref(top_mark);
	}
	if (output_routine != null)
		if (dead_cycles >= max_dead_cycles) 
			#pragma region <Explain that too many dead cycles have occurred in a row 1024>
		{
			//
			print_err(TEX_STRING("Output loop---"));
			print_int(dead_cycles);
			print(TEX_STRING(" consecutive dead cycles"));
			help3(TEX_STRING("I've concluded that your \output is awry; it never does a"),
				TEX_STRING("\shipout, so I'm shipping \box255 out myself. Next time"),
				TEX_STRING("increase \maxdeadcycles if you want me to be more patient!"));
			error();
		}
			#pragma endregion
		else 
			#pragma region <Fire up the users output routine and return 1025>
		{
			
			output_active = true; incr(dead_cycles); push_nest(); mode = (mode_type)-vmode;
			prev_depth = ignore_depth; mode_line = -line;
			begin_token_list(output_routine, output_text);
			new_save_level(output_group); normal_paragraph(); scan_left_brace();
			goto _exit;
		}
			#pragma endregion

	#pragma region <Perform the default output routine 1023>
	{
		if (link(page_head) != null) {
			if (link(contrib_head) == null)
				if (nest_ptr == 0) tail = page_tail;
				else contrib_tail = page_tail;
			else link(page_tail) = link(contrib_head);
			link(contrib_head) = link(page_head); link(page_head) = null; page_tail = page_head;
		}
		ship_out(box(255)); box(255) = null;
	}
	#pragma endregion
_exit:
	return;
}

// 1060
void append_glue()
{
	small_number s;
	s = cur_chr;
	switch (s) {
	case fil_code:
		cur_val = fil_glue;
		break;
	case fill_code:
		cur_val = fill_glue;
		break;
	case ss_code:
		cur_val = ss_glue;
		break;
	case fil_neg_code:
		cur_val = fil_neg_glue;
		break;
	case skip_code:
		scan_glue(glue_val);
		break;
	case mskip_code:
		scan_glue(mu_val);
		break;
	}
	tail_append(new_glue(cur_val));
	if (s >= skip_code)
	{
		decr(glue_ref_count(cur_val));
		if (s > skip_code)
			subtype(tail) = mu_glue;
	}
}

// 1061
void append_kern()
{
	quarterword s;
	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment append_kern\n");
		exit(1);
	}
	s = (quarterword)cur_chr;

	//--------
	scan_dimen(s == mu_glue, false, false); tail_append(new_kern(cur_val));
	subtype(tail) = s;
}

// 970
pointer vert_break(pointer p, scaled h, scaled d)
{
	pointer prev_p;
	pointer q, r;
	int pi;
	int b;
	int least_cost;
	pointer best_place;
	scaled prev_dp;
	small_number t;

	prev_p = p;
	least_cost = awful_bad; do_all_six(set_height_zero); prev_dp = 0;
	while (1) {
		#pragma region <If node p is a legal breakpoint, check if this break is the best known, and goto done if p is.. 972>
		if (p == null) pi = eject_penalty;
		else
			#pragma region <Use node p to update the current height and depth measurements; if this node is not a legal..break 973>

			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
				cur_height = cur_height + prev_dp + height(p); prev_dp = depth(p);
				goto not_found;
				break;
			case whatsit_node:
				//<Process whatsit p in vert_break loop, goto not_found 1365>
				goto not_found;
				break;

			case glue_node:
				if (precedes_break(prev_p)) pi = 0;
				else goto update_heights;
				break;
			case kern_node:
				if (link(p) == null) t = penalty_node;
				else t = type(link(p));
				if (t == glue_node) pi = 0;
				else goto update_heights;
				break;
			case penalty_node:
				pi = penalty(p);
				break;
			case mark_node:
			case ins_node:
				goto not_found;
				break;
			default:
				confusion(TEX_STRING("vertbreak"));
				break;
			}
#pragma endregion

		#pragma region <Check if node p is a new champion breakpoint .. 974>
		if (pi < inf_penalty) {
			#pragma region <Compute the badness, b, using awful_bad if the box is too full 975>
			if (cur_height < h)
				if (active_height[3] != 0 || active_height[4] != 0 || active_height[5] != 0) b = 0;
				else b = badness(h - cur_height, active_height[2]);
			else if (cur_height - h > active_height[6]) b = awful_bad;
			else
				b = badness(cur_height - h, active_height[6]);
			#pragma endregion
			if (b < awful_bad)
				if (pi <= eject_penalty) 
					b = pi;
				else if (b < inf_bad) 
					b += pi;
				else 
					b = deplorable;
			if (b <= least_cost) {
				best_place = p; least_cost = b; best_height_plus_depth = cur_height + prev_dp;
			}
			if (b == awful_bad || pi <= eject_penalty) goto done;
		}
		#pragma endregion

		if (type(p) < glue_node || type(p) > kern_node) goto not_found;
	update_heights:
		#pragma region <Update the current height and depth measurements with respect to a glue or kern node p 976>
		if (type(p) == kern_node) q = p;
		else {
			q = glue_ptr(p);
			active_height[2 + stretch_order(q)] += stretch(q);
			active_height[6] += shrink(q);
			if (shrink_order(q) != normal && shrink(q) != 0) {
				print_err(TEX_STRING("Infinite glue shrinkage found in box being split"));
				help4(TEX_STRING("The box you are \vsplitting contains some infinitely"),
					TEX_STRING("shrinkable glue, e.g., `\vss' or `\vskip 0pt minus 1fil'."), 
					TEX_STRING("Such glue doesn't belong there; but you can safely proceed,"), 
					TEX_STRING("since the offensive shrinkability has been made finite."));
				error();
				r = new_spec(q);
				shrink_order(r) = normal; delete_glue_ref(q); glue_ptr(p) = r; q = r;
			}
		}
		cur_height += prev_dp + width(q); prev_dp = 0;
		#pragma endregion

		not_found: 
		if (prev_dp > d) {
			cur_height = cur_height + prev_dp - d; prev_dp = d;
		}
		#pragma endregion
		prev_p = p; p = link(prev_p);
	}
done:
	return best_place;
}

void print_totals()
{
	print_scaled(page_total);
	print_plus(2, TEX_STRING(""));
	print_plus(3, TEX_STRING("fil"));
	print_plus(4, TEX_STRING("fill"));
	print_plus(5, TEX_STRING("filll"));
	if (page_shrink != 0) {
		print(TEX_STRING(" minus "));
		print_scaled(page_shrink);
	}
}

// 977
pointer vsplit(eight_bits n, scaled h)
{
	pointer v;
	pointer p;
	pointer q;

	v = box(n);
	if (split_first_mark != null) {
		delete_token_ref(split_first_mark); split_first_mark = null;
		delete_token_ref(split_bot_mark);
		split_bot_mark = null;
	}

	#pragma region <Dispense with trivial cases of void or bad boxes 978>
	if (v == null) {
		return null;
	}
	if (type(v) != vlist_node) {
		print_err(TEX_STRING(""));
		print_esc(TEX_STRING("vsplit"));
		print(TEX_STRING(" needs a "));
		print_esc(TEX_STRING("vbox"));
		help2(TEX_STRING("The box you are trying to split is an \hbox."),
			TEX_STRING("I can't split such a box, so I'll leave it alone."));
		error();
		return null;
	}
	#pragma endregion



	q = vert_break(list_ptr(v), h, split_max_depth);

	#pragma region <Look at all the marks in nodes before the break, and set the final link to null at the break 979>
	p = list_ptr(v);
	if (p == q) list_ptr(v) = null;
	else while (1) {
		if(type(p) == mark_node)
			if (split_first_mark == null) {
				split_first_mark = mark_ptr(p); split_bot_mark = split_first_mark;
				token_ref_count(split_first_mark) += 2;
			}
			else {
				delete_token_ref(split_bot_mark); split_bot_mark = mark_ptr(p);
				add_token_ref(split_bot_mark);
			}
			if (link(p) == q) {
				link(p) = null; goto done;
			}
			p = link(p);
	}
done:
	#pragma endregion


	q = prune_page_top(q); p = list_ptr(v); free_node(v, box_node_size);
	if (q == null) box(n) = null;
	else box(n) = vpack(q, 0, additional);



	return vpackage(p, h, exactly, split_max_depth);
}



//1200
void resume_after_display()
{
	if (cur_group != math_shift_group) confusion(TEX_STRING("display"));
	unsave(); prev_graf += 3; push_nest(); mode = hmode; space_factor = 1000; set_cur_lang;
	clang = cur_lang;
	prev_graf = (norm_min(left_hyphen_min) * 0100 + norm_min(right_hyphen_min)) * 0200000 + cur_lang;
	#pragma region <Scan an optional space 443>
	get_x_token();
	if (cur_cmd != spacer)
		back_input();
	#pragma endregion
	if (nest_ptr == 1) build_page();
}


//1236
void do_register_command(small_number a)
{
	pointer l, q, r, s;
	int p; // int_val..mu_val
	q = cur_cmd;
	#pragma region <Compute the register location l and its type p; but return if invalid 1237>
	{
		if (q != _register) {
			get_x_token();
			if (cur_cmd >= assign_int && cur_cmd <= assign_mu_glue) {
				l = cur_chr; p = cur_cmd - assign_int; goto found;
			}
			if (cur_cmd != _register) {
				print_err(TEX_STRING("You can't use `")); print_cmd_chr(cur_cmd, cur_chr); print(TEX_STRING("' after "));
				print_cmd_chr((quarterword)q, 0); help1(TEX_STRING("I'm forgetting what you said and not changing anything."));
				error();
				return;
			}
		}
		p = cur_chr; scan_eight_bit_int();
		switch (p) {
		case int_val: l = cur_val + count_base; break;
		case dimen_val: l = cur_val + scaled_base; break;
		case glue_val: l = cur_val + skip_base; break;
		case mu_val: l = cur_val + mu_skip_base; break;
		}
	}
found:

	#pragma endregion
	if (q == _register) scan_optional_equals();
#pragma warning(push)
#pragma warning(disable : 4390)	
	else if (scan_keyword(TEX_STRING("by")))
		;//do_nothing
#pragma warning(pop)

	arith_error = false;
	if(q<multiply)
		#pragma region <Compute result of register or advance, put it in cur_val 1238>
		if (p < glue_val) {
			if (p == int_val) scan_int(); else scan_normal_dimen;
			if (q == advance) cur_val += eqtb[l].union_t.an_int;
		}
		else {
			scan_glue(p);
			if (q == advance)
				#pragma region <Compute the sum of two glue specs 1239>
			{
				q = new_spec(cur_val); r = equiv(l); delete_glue_ref(cur_val); width(q) += width(r);
				if (stretch(q) == 0) stretch_order(q) = normal;
				if (stretch_order(q) == stretch_order(r)) stretch(q) += stretch(r);
				else if (stretch_order(q) < stretch_order(r) && stretch(r) != 0) {
					stretch(q) = stretch(r); stretch_order(q) = stretch_order(r);
				}
				if (shrink(q) == 0) shrink_order(q) = normal;
				if (shrink_order(q) == shrink_order(r)) shrink(q) += shrink(r);
				else if (shrink_order(q) < shrink_order(r) && shrink(r) != 0) {
					shrink(q) = shrink(r); shrink_order(q) = shrink_order(r);
				}
				cur_val = q;
			}
				#pragma endregion
		}
		#pragma endregion
	else
		#pragma region <Compute result of multiply or divide, put it in cur_val 1240>
	{
		scan_int();
		if (p < glue_val)
			if (q == multiply)
				if (p == int_val) cur_val = mult_integers(eqtb[l].union_t.an_int, cur_val);
				else cur_val = nx_plus_y(eqtb[l].union_t.an_int, cur_val, 0);
			else cur_val = x_over_n(eqtb[l].union_t.an_int, cur_val);
		else {
			s = equiv(l); r = new_spec(s);
			if (q == multiply) {
				width(r) = nx_plus_y(width(s), cur_val, 0); stretch(r) = nx_plus_y(stretch(s), cur_val, 0);
				shrink(r) = nx_plus_y(shrink(s), cur_val, 0);
			}
			else {
				width(r) = x_over_n(width(s), cur_val); stretch(r) = x_over_n(stretch(s), cur_val);
				shrink(r) = x_over_n(shrink(s), cur_val);
			}
			cur_val = r;
		}
	}
		#pragma endregion
	if (arith_error) {
		print_err(TEX_STRING("Arithmetic overflow"));
		help2(TEX_STRING("I can't carry out that multiplication or division,"),
			TEX_STRING("since the result is out of range."));
		if (p >= glue_val) delete_glue_ref(cur_val);
		error();
		return;
	}
	if (p < glue_val) word_define(l, cur_val);
	else {
		trap_zero_glue(); define(l, glue_ref, cur_val);
	}
}

// 1275
void open_or_close_in()
{
	unsigned char c;
	unsigned char n;
	
	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment open_or_close_in\n");
		exit(1);
	}
	// ----
	c = (unsigned char)cur_chr; scan_four_bit_int(); n = cur_val;
	if (read_open[n] != closed) {
		a_close(read_file[n]); read_open[n] = closed;
	}
	if (c != 0) {
		scan_optional_equals();
		scan_file_name();
		if (cur_ext == TEX_STRING(""))
			cur_ext = TEX_STRING(".tex");
		pack_cur_name;
		if (a_open_in(&read_file[n])) read_open[n] = just_open;
	}
}

//1279
void issue_message()
{
	unsigned int old_setting;
	unsigned char c;
	str_number s;

	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment open_or_close_in\n");
		exit(1);
	}

	c = (unsigned char)cur_chr; link(garbage) = scan_toks(false, true); old_setting = selector;
	selector = new_string; token_show(def_ref); selector = old_setting;
	flush_list(def_ref); str_room(1);
	s = make_string();
	if (c == 0) 
		#pragma region <Print string s on the terminal 1280>
	{
		if (term_offset + length(s) > max_print_line - 2)
			print_ln();
		else if (term_offset > 0 || file_offset > 0)
			print_char(TEX_STRING(" "));
		slow_print(s); update_terminal();
	}
		#pragma endregion
	else 
		#pragma region <Print string s as an error message 1283>
	{
		print_err(TEX_STRING(""));
		slow_print(s);
		if (err_help != null) use_err_help = true;
		else if (long_help_seen)
			help1(TEX_STRING("(That was another \errmessage.)"));
		else {
			if (interaction < error_stop_mode) long_help_seen = true;
			help4(TEX_STRING("This error message was generated by an \errmessage"),
				TEX_STRING("command, so I can't give any explicit help."),
				TEX_STRING("Pretend that you're Hercule Poirot: Examine all clues,"),
				TEX_STRING("and deduce the truth by order and method."));
		}
		error();
		use_err_help = false;
	}
		#pragma endregion
	flush_string;
}

// 218
void show_activities()
{
	int p; // 0..nest_size
	short m; // -mmode..mmode
	memory_word a;
	pointer q, r;
	int t;

	nest[nest_ptr] = cur_list;
	print_nl(TEX_STRING("")); print_ln();
	for (p = nest_ptr; p >= 0; p--) {
		m = nest[p].mode_field; a = nest[p].aux_field; print_nl(TEX_STRING("### ")); print_mode(m);
		print(TEX_STRING(" entered at line ")); print_int(abs(nest[p].ml_field));
		if(m==hmode)
			if (nest[p].pg_field != 040600000) {
				print(TEX_STRING(" (language")); print_int(nest[p].pg_field % 0200000); print(TEX_STRING(":hyphenmin"));
				print_int(nest[p].pg_field / 020000000); print_char(TEX_STRING(","));
				print_int((nest[p].pg_field / 0200000) % 0100); print_char(TEX_STRING(")"));
			}
		if (nest[p].ml_field < 0) print(TEX_STRING(" (\output routine)"));
		if (p == 0) {
			#pragma region <Show the status of the current page 986>
			if (page_head != page_tail) {
				print_nl(TEX_STRING("### current page:"));
				if (output_active) print(TEX_STRING(" (held over for next output)"));
				show_box(link(page_head));
				if (page_contents > empty) {
					print_nl(TEX_STRING("total height ")); print_totals(); print_nl(TEX_STRING(" goal height "));
					print_scaled(page_goal); r = link(page_ins_head);
					while (r != page_ins_head) {
						print_ln(); print_esc(TEX_STRING("insert")); t = qo(subtype(r)); print_int(t); print(TEX_STRING(" adds "));
						if (count(t) == 1000) t = height(r);
						else t = x_over_n(height(r), 1000)*count(t);
						print_scaled(t);
						if (type(r) == split_up) {
							q = page_head; t = 0;
							do {
								q = link(q);
								if (type(q) == ins_node && subtype(q) == subtype(r)) incr(t);
							} while (!(q == broken_ins(r)));
							print(TEX_STRING(", #")); print_int(t); print(TEX_STRING(" might split"));
						}
						r = link(r);
					}
				}
			}
			#pragma endregion
			if (link(contrib_head) != null) print_nl(TEX_STRING("### recent contributions:"));
		}
		show_box(link(nest[p].head_field));
		#pragma region <Show the auxiliary field 219>
		switch (abs(m) / (max_command + 1)) {
		case 0:
			print_nl(TEX_STRING("prevdepth "));
			if (a.sc <= ignore_depth) print(TEX_STRING("ignored"));
			else print_scaled(a.sc);
			if (nest[p].pg_field != 0) {
				print(TEX_STRING(", prevgraf ")); print_int(nest[p].pg_field); print(TEX_STRING(" line"));
				if (nest[p].pg_field != 1) print_char(TEX_STRING("s"));
			}
			break;
		case 1:
			print_nl(TEX_STRING("spacefactor ")); print_int(a.union_t.hh.union_t.lh);
			if (m > 0) if (a.union_t.hh.rh > 0) {
				print(TEX_STRING(", current language ")); print_int(a.union_t.hh.rh);
			}
			break;
		case 2:
			if (a.union_t.an_int != null) {
				print(TEX_STRING("this will be denominator of:")); show_box(a.union_t.an_int);
			}
			break;
		}
		#pragma endregion

	}
}


// 1160
void scan_delimiter(pointer p, bool r)
{
	if (r) scan_twenty_seven_bit_int();
	else {
		#pragma region <Get the next non-blank non relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion

		switch (cur_cmd) {
		case letter:
		case other_char:
			cur_val = del_code(cur_chr);
			break;
		case delim_num:
			scan_twenty_seven_bit_int();
			break;
		default:
			cur_val = -1;
			break;
		}
	}
	if (cur_val < 0) 
		#pragma region <Report that an invalid delimiter code is beign changed to null set cur_val = 0 1161>
	{
		print_err(TEX_STRING("Missing delimiter (. inserted)"));
		help6(TEX_STRING("I was expecting to see something like `(' or `\{' or"),
			TEX_STRING("`\}' here. If you typed, e.g., `{' instead of `\{', you"),
			TEX_STRING("should probably delete the `{' by typing `1' now, so that"),
			TEX_STRING("braces don't get unbalanced. Otherwise just proceed."),
			TEX_STRING("Acceptable delimiters are characters whose \delcode is"),
			TEX_STRING("nonnegative, or you can use `\delimiter <delimiter code>'."));
		back_error();
		cur_val = 0;
	}
		#pragma endregion

	small_fam(p) = (cur_val / 04000000) % 16;
	small_char(p) = qi((cur_val / 010000) % 256);
	large_fam(p) = (cur_val / 256) % 16; large_char(p) = qi(cur_val % 256);
	
}

//1288
void shift_case()
{
	pointer b;
	pointer p;
	halfword t;
	eight_bits c;

	b = cur_chr; p = scan_toks(false, false); p = link(def_ref);
	while (p != null) {
		#pragma region <Change the case of the token in p, if a change is appropriate 1289>
		t = info(p);
		if (t < cs_token_flag + single_base) {
			c = t % 256;
			if (equiv(b + c) != 0) info(p) = t - c + equiv(b + c);
		}
		#pragma endregion
		p = link(p);
	}
	back_list(link(def_ref)); free_avail(def_ref);
}

// 280
void save_for_after(halfword t)
{
	if (cur_level > level_one) {
		check_full_save_stack;
		save_type(save_ptr) = insert_token; save_level(save_ptr) = level_zero;
		save_index(save_ptr) = t; incr(save_ptr);
	}
}

// 689
pointer new_choice()
{
	pointer p;
	p = get_node(style_node_size); type(p) = choice_node; subtype(p) = 0;
	display_mlist(p) = null; text_mlist(p) = null; script_mlist(p) = null; script_script_mlist(p) = null;
	return p;
}

// 1159
void math_limit_switch()
{
	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment math_limit_switch\n");
		exit(1);
	}
	if(head!= tail)
		if (type(tail) == op_noad) {
			subtype(tail) = (quarterword)cur_chr;
			goto _exit;
		}
	print_err(TEX_STRING("Limit controls must follow a math operator"));
	help1(TEX_STRING("I'm ignoring this misplaced \limits or \nolimits command."));
	error();
_exit:
	;
}

// 1163
void math_radical()
{
	tail_append(get_node(radical_noad_size)); type(tail) = radical_noad; subtype(tail) = normal;
	mem[nucleus(tail)].union_t.hh = empty_field; mem[subscr(tail)].union_t.hh = empty_field;
	mem[supscr(tail)].union_t.hh = empty_field; scan_delimiter(left_delimiter(tail), true);
	scan_math(nucleus(tail));
}

// 1165
void math_ac()
{
	if (cur_cmd == accent) {
		//<Complain that the user should have said \mathaccent 1166>
		print_err(TEX_STRING("Please use "));
		print_esc(TEX_STRING("mathaccent"));
		print(TEX_STRING(" for accents in math mode"));
		help2(TEX_STRING("I'm changing \accent to \mathaccent here; wish me luck."),
			TEX_STRING("(Accents are not the same in formulas as they are in text.)"));
		error();
	}
	tail_append(get_node(accent_noad_size)); type(tail) = accent_noad; subtype(tail) = normal;
	mem[nucleus(tail)].union_t.hh = empty_field; mem[subscr(tail)].union_t.hh = empty_field;
	mem[supscr(tail)].union_t.hh = empty_field; math_type(accent_chr(tail)) = math_char;
	scan_fifteen_bit_int();
	character(accent_chr(tail)) = qi(cur_val % 256);
	if (cur_val >= var_code && fam_in_range) fam(accent_chr(tail)) = cur_fam;
	else fam(accent_chr(tail)) = (cur_val / 256) % 16;
	scan_math(nucleus(tail));
}

// 1172
void append_choices()
{
	tail_append(new_choice()); incr(save_ptr); saved(-1) = 0; push_math(math_choice_group);
	scan_left_brace();
}

// 1176
void sub_sup()
{
	small_number t;
	pointer p;
	t = empty; p = null;
	if(tail != head)
		if (scripts_allowed(tail)) {
			p = supscr(tail) + cur_cmd - sup_mark;
			t = math_type(p);
		}
	if (p == null || t != empty) 
		#pragma region <Insert a dummy noad to be sub/superscripted 1177>
	{
		tail_append(new_noad()); p = supscr(tail) + cur_cmd - sup_mark;
		if (t != empty) {
			if (cur_cmd == sup_mark) {
				print_err(TEX_STRING("Double superscript"));
				help1(TEX_STRING("I treat `x^1^2' essentially like `x^1{}^2'."));
			}
			else {
				print_err(TEX_STRING("Double subscript"));
				help1(TEX_STRING("I treat `x_1_2' essentially like `x_1{}_2'."));
			}
			error();
		}
	}
		#pragma endregion

	scan_math(p);
	
}

// 1181
void math_fraction()
{
	small_number c;
	c = cur_chr;
	if (incompleat_noad != null) 
		#pragma region <Ignore the fraction operation and complain about this ambiguous case 1183>
	{
		if (c >= delimited_code) {
			scan_delimiter(garbage, false); scan_delimiter(garbage, false);
		}
		if (c % delimited_code == above_code) scan_normal_dimen;
		print_err(TEX_STRING("Ambiguous; you need another { and }"));
		help3(TEX_STRING("I'm ignoring this fraction specification, since I don't"),
			TEX_STRING("know whether a construction like `x \over y \over z'"),
			TEX_STRING("means `{x \over y} \over z' or `x \over {y \over z}'."));
		error();
	}
		#pragma endregion
	else {
		incompleat_noad = get_node(fraction_noad_size); type(incompleat_noad) = fraction_noad;
		subtype(incompleat_noad) = normal; math_type(numerator(incompleat_noad)) = sub_mlist;
		info(numerator(incompleat_noad)) = link(head);
		mem[denominator(incompleat_noad)].union_t.hh = empty_field;
		mem[left_delimiter(incompleat_noad)].union_t.qqqq = null_delimiter;
		mem[right_delimiter(incompleat_noad)].union_t.qqqq = null_delimiter;
		link(head) = null; tail = head;
		#pragma region <Use code c to distinguish between generalized fraction 1182>
		if (c >= delimited_code) {
			scan_delimiter(left_delimiter(incompleat_noad), false);
			scan_delimiter(right_delimiter(incompleat_noad), false);
		}
		switch (c % delimited_code) {
		case above_code:
			scan_normal_dimen; thickness(incompleat_noad) = cur_val;
			break;
		case over_code:
			thickness(incompleat_noad) = default_code;
			break;
		case atop_code:
			thickness(incompleat_noad) = 0;
			break;
		}
		#pragma endregion
	}
}

// 1270
void do_assignments()
{
	while (1) {
		#pragma region <Get the next non-blank non-relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion
		if (cur_cmd <= max_non_prefixed_command) return;
		set_box_allowed = false; prefixed_command(); set_box_allowed = true;
	}
}


//1191
void math_left_right()
{
	small_number t;
	pointer p;

	t = cur_chr;
	if (t == right_noad && cur_group != math_left_group) 
		#pragma region < Try to recover from mismatched right 1192>
	{
		if (cur_group == math_shift_group) {
			scan_delimiter(garbage, false); print_err(TEX_STRING("Extra "));
			print_esc(TEX_STRING("right"));
			help1(TEX_STRING("I'm ignoring a \right that had no matching \left."));
			error();
		}
		else off_save();
	}
		#pragma endregion
	else {
		p = new_noad(); type(p) = t; scan_delimiter(delimiter(p), false);
		if (t == left_noad) {
			push_math(math_left_group); link(head) = p; tail = p;
		}
		else {
			p = fin_mlist(p); unsave();
			tail_append(new_noad()); type(tail) = inner_noad; math_type(nucleus(tail)) = sub_mlist;
			info(nucleus(tail)) = p;
		}
	}
}

// 296
void print_meaning()
{
	print_cmd_chr(cur_cmd, cur_chr);
	if (cur_cmd >= call) {
		print_char(TEX_STRING(":")); print_ln(); token_show(cur_chr);
	}
	else if (cur_cmd == top_bot_mark) {
		print_char(TEX_STRING(":")); print_ln(); token_show(cur_mark[cur_chr]);
	}
}

// 1293
void show_whatever()
{
	pointer p;
	switch (cur_chr) {
	case show_lists:
		begin_diagnostic();
		show_activities();
		break;

	case show_box_code:
		//<Show the current contents of a box 1296>
		scan_eight_bit_int();
		begin_diagnostic();
		print_nl(TEX_STRING("> \box")); print_int(cur_val); print_char(TEX_STRING("="));
		if (box(cur_val) == null) print(TEX_STRING("void"));
		else show_box(box(cur_val));
		break;

	case show_code:
		//<Show the current meaning of a token, then goto common_ending 1294>
		get_token();
		if (interaction == error_stop_mode) wake_up_terminal();
		print_nl(TEX_STRING("> "));
		if (cur_cs != 0) {
			sprint_cs(cur_cs); print_char(TEX_STRING("="));
		}
		print_meaning();
		goto common_ending;
		break;
	default:
		//<Show the current value of some parameter or register, then goto common_ending 1297>
		p = the_toks();
		if (interaction == error_stop_mode) wake_up_terminal();
		print_nl(TEX_STRING("> ")); token_show(temp_head);
		flush_list(link(temp_head));
		goto common_ending;
		break;
	}
	#pragma region <Complete a potentially long show command 1298>
	end_diagnostic(true); print_err(TEX_STRING("OK"));
	if(selector == term_and_log)
		if (tracing_online) {
			selector = term_only;
			print(TEX_STRING(" (see the transcript file)"));
			selector = term_and_log;
		}
	#pragma endregion
common_ending:
	if (interaction < error_stop_mode) {
		help0; decr(error_count);
	}
	else if (tracing_online > 0) {
		help3(TEX_STRING("This isn't an error message; I'm just \showing something."),
			TEX_STRING("Type `I\show...' to show more (e.g., \show\cs,"),
			TEX_STRING("\showthe\count10, \showbox255, \showlists)."));
	}
	else {
		help5(TEX_STRING("This isn't an error message; I'm just \showing something."),
			TEX_STRING("Type `I\show...' to show more (e.g., \show\cs,"),
			TEX_STRING("\showthe\count10, \showbox255, \showlists)."),
			TEX_STRING("And type `I\tracingonline=1\show...' to show boxes and"),
			TEX_STRING("lists on your terminal as well as in the transcript file."));
	}
	error();
}

// 1047
void insert_dollar_sign()
{
	back_input(); cur_tok = math_shift_token + TEX_STRING("$");
	print_err(TEX_STRING("Missing $ inserted"));
	help2(TEX_STRING("I've inserted a begin-math/end-math symbol since I think"),
		TEX_STRING("you left one out. Proceed, with fingers crossed."));
	ins_error();
}

// 1084
void scan_box(int box_context)
{
	#pragma region <Get the next non-blank non relax non-call token 404>
	do
	{
		get_x_token();
	} while (!(cur_cmd != spacer && cur_cmd != relax));
	#pragma endregion

	if (cur_cmd == make_box) begin_box(box_context);
	else if (box_context >= leader_flag && (cur_cmd == hrule || cur_cmd == vrule)) {
		cur_box = scan_rule_spec(); box_end(box_context);
	}
	else {
		print_err(TEX_STRING("A <box> was supposed to be here"));
		help3(TEX_STRING("I was expecting to see \hbox or \vbox or \copy or \box or"),
			TEX_STRING("something like that. So you might find something missing in"),
			TEX_STRING("your output. But keep trying; you can fix this later."));
		back_error();
	}
}

// 1303
bool load_fmt_file()
{
	int j, k;
	pointer p, q;
	int x;
	four_quarters w;

	#pragma region <Undump constants for consistency check 1308>
	fread(&x, sizeof x, 1, fmt_file);
	if (x != @$) goto bad_fmt;
	undump_int(&x);
	if (x != mem_bot) goto bad_fmt;
	undump_int(&x);
	if (x != mem_top) goto bad_fmt;
	undump_int(&x);
	if (x != eqtb_size) goto bad_fmt;
	undump_int(&x);
	if (x != hash_prime) goto bad_fmt;
	undump_int(&x);
	if (x != hyph_size) goto bad_fmt;
	#pragma endregion

	#pragma region <Undump the string pool 1310>
	undump_size(0, pool_size, "string pool size", pool_ptr);
	undump_size(0, max_strings, "max strings", str_ptr);
	for (k = 0; k <= str_ptr; k++)
		undump(0, pool_ptr, str_start[k]);
	k = 0;
	while (k + 4 < pool_ptr) {
		undump_four_ASCII; k += 4;
	}
	k = pool_ptr - 4; undump_four_ASCII; init_str_ptr = str_ptr; init_pool_ptr = pool_ptr;

	#pragma endregion

	#pragma region <Undump the dynamic memory 1312>
	undump(lo_mem_stat_max + 1000, hi_mem_stat_min - 1, lo_mem_max);
	undump(lo_mem_stat_max + 1, lo_mem_max, rover); p = mem_bot; q = rover;
	do {
		for (k = p; k <= q + 1; k++) undump_wd(&mem[k]);
		p = q + node_size(q);
		if (p > lo_mem_max || q >= rlink(q) && rlink(q) != rover) goto bad_fmt;
		q = rlink(q);
	} while (!(q == rover));
	for (k = p; k <= lo_mem_max; k++) undump_wd(&mem[k]);
	if (mem_min < mem_bot - 2) {
		p = llink(rover); q = mem_min + 1; link(mem_min) = null;
		info(mem_min) = null;
		rlink(p) = q; llink(rover) = q;
		rlink(q) = rover; llink(q) = p; link(q) = empty_flag; node_size(q) = mem_bot - q;
	}
	undump(lo_mem_max + 1, hi_mem_stat_min, hi_mem_min);
	undump(null, mem_top, avail);
	mem_end = mem_top;
	for (k = hi_mem_min; k <= mem_end; k++) undump_wd(&mem[k]);
	undump_int(&var_used); undump_int(&dyn_used);
	#pragma endregion

	#pragma region <Undump the table of equivalents 1314>
	#pragma region <Undump regions 1 to 6 of eqtb 1317>
	k = active_base;
	do {
		undump_int(&x);
		if (x<1 || k + x > eqtb_size + 1) goto bad_fmt;
		for (j = k; j <= k + x - 1; j++) undump_wd(&eqtb[j]);
		k += x; undump_int(&x);
		if (x<0 || k + x > eqtb_size + 1) goto bad_fmt;
		for (j = k; j <= k + x - 1; j++) eqtb[j] = eqtb[k - 1];
		k += x;
	} while (!(k > eqtb_size));
	#pragma endregion


	undump(hash_base, frozen_control_sequence, par_loc); par_token = cs_token_flag + par_loc;
	undump(hash_base, frozen_control_sequence, write_loc);

	#pragma region Undump the hash table 1319>
	undump(hash_base, frozen_control_sequence, hash_used); p = hash_base - 1;
	do {
		undump(p + 1, hash_used, p); undump_hh(&hash[p]);
	} while (!(p == hash_used));
	for (p = hash_used + 1; p <= undefined_control_sequence - 1; p++) undump_hh(&hash[p]);
	undump_int(&cs_count);
	#pragma endregion

	#pragma endregion

	#pragma region <Undump the font information 1321>
	undump_size(7, font_mem_size, "font mem size", fmem_ptr);
	for (k = 0; k <= fmem_ptr - 1; k++) undump_wd(&font_info[k]);
	undump_size(font_base, font_max, "font max", font_ptr);
	for (k = null_font; k <= font_ptr; k++)
		#pragma region <Undump the array info for internal font number k 1323>
	{
		
		undump_qqqq(&font_check[k]);
		undump_int(&font_size[k]); undump_int(&font_dsize[k]);
		undump(min_halfword, max_halfword, font_params[k]);
		undump_int(&hyphen_char[k]); undump_int(&skew_char[k]);
		undump(0, str_ptr, font_name[k]); undump(0, str_ptr, font_area[k]);
		undump(0, 255, font_bc[k]); undump(0, 255, font_ec[k]);
		undump_int(&char_base[k]); undump_int(&width_base[k]); undump_int(&height_base[k]);
		undump_int(&depth_base[k]); undump_int(&italic_base[k]); undump_int(&lig_kern_base[k]);
		undump_int(&kern_base[k]); undump_int(&exten_base[k]); undump_int(&param_base[k]);
		undump(min_halfword, lo_mem_max, font_glue[k]); 
		undump(0, fmem_ptr - 1, bchar_label[k]);  undump(min_quarterword, non_char, font_bchar[k]);
		undump(min_quarterword, non_char, font_false_bchar[k]);
	}
		#pragma endregion

	#pragma endregion

	#pragma region <Undump the hyphenation tables 1325>
	undump(0, hyph_size, hyph_count);
	for (k = 1; k <= hyph_count; k++) {
		undump(0, hyph_size, j); undump(0, str_ptr, hyph_word[j]);
		undump(min_halfword, max_halfword, hyph_list[j]);
	}
	undump_size(0, trie_size, "trie size", j);
	//init
	trie_max = j;
	//tini

	for (k = 0; k <= j; k++) undump_hh(&trie[k]);
	undump_size(0, trie_op_size, "trie op size", j);
	//init
	trie_op_ptr = j;
	//tini

	for (k = 1; k <= j; k++) {
		undump(0, 63, hyf_distance[k]);
		undump(0, 63, hyf_num[k]); undump(min_quarterword, max_quarterword, hyf_next[k]);
	}
	//init
	for (k = 0; k <= 255; k++) trie_used[k] = min_quarterword;
	//tini
	k = 256;
	while (j > 0) {
		undump(0, k - 1, k); undump(1, j, x);
		//init
		trie_used[k] = qi(x);
		//tini

		j = j - x; op_start[k] = qo(j);
	}
	//init
	trie_not_ready = false;
	//tini
	#pragma endregion



	#pragma region <Undump a couple of more things and the closing check word 1327>
	undump(batch_mode, error_stop_mode, interaction); undump(0, str_ptr, format_ident); undump_int(&x);
	if (x != 69069 || feof(fmt_file)) goto bad_fmt;
	#pragma endregion



	return true;

bad_fmt:
	wake_up_terminal(); wterm_ln_s("(Fatal format file error; I'm stymied)");
	return false;
}


// 1349
void new_whatsit(small_number s, small_number w)
{
	pointer p;
	p = get_node(w); type(p) = whatsit_node; subtype(p) = s; link(tail) = p; tail = p;
}



// 1350
void new_write_whatsit(small_number w)
{
	new_whatsit(cur_chr, w);
	if (w != write_node_size)
		scan_four_bit_int();
	else {
		scan_int();
		if (cur_val < 0)
			cur_val = 17;
		else if (cur_val > 15)
			cur_val = 16;
	}
	write_stream(tail) = cur_val;
}

// 1355
void print_write_whatsit(str_number s, pointer p)
{
	print_esc(s);
	if (write_stream(p) < 16) print_int(write_stream(p));
	else if (write_stream(p) == 16) print_char(TEX_STRING("*"));
	else print_char(TEX_STRING("-"));
}


// 1368
void special_out(pointer p)
{
	unsigned int old_setting;
	pool_pointer k;

	synch_h; synch_v;

	old_setting = selector; selector = new_string;
	show_token_list(link(write_tokens(p)), null, pool_size - pool_ptr); selector = old_setting; str_room(1);
	if (cur_length < 256) {
		dvi_out(dvi_const::xxx1); dvi_out(cur_length);
	}
	else {
		dvi_out(dvi_const::xxx4); dvi_four(cur_length);
	}
	for (k = str_start[str_ptr]; k <= pool_ptr - 1; k++)
		dvi_out(so(str_pool[k]));
	pool_ptr = str_start[str_ptr];
}

//1370
void write_out(pointer p)
{
	unsigned int old_setting;
	int old_mode;
	small_number j;
	pointer q, r;

	#pragma region <Expand macros in the token list and make link(def_ref) point to the result 1371>
	q = get_avail(); info(q) = right_brace_token + TEX_STRING("}");
	r = get_avail(); link(q) = r; info(r) = end_write_token; ins_list(q);
	begin_token_list(write_tokens(p), write_text);
	q = get_avail(); info(q) = left_brace_token + TEX_STRING("{"); ins_list(q);
	old_mode = mode; mode = (mode_type)0;
	cur_cs = write_loc; q = scan_toks(false, true);
	get_token(); 
	if (cur_tok != end_write_token)
		#pragma region <Recover from an unbalanced write command 1372>
	{
		print_err(TEX_STRING("Unbalanced write command"));
		help2(TEX_STRING("On this page there's a \write with fewer real {'s than }'s."),
			TEX_STRING("I can't handle that very well; good luck."));
		error();
		do {
			get_token();
		} while (!(cur_tok == end_write_token));
	}
		#pragma endregion
	mode = (mode_type)old_mode; end_token_list();
	#pragma endregion

	old_setting = selector; j = write_stream(p);
	if (write_open[j]) selector = j;
	else {
		if (j == 17 && selector == term_and_log)
			selector = log_only;
		print_nl(TEX_STRING(""));
	}
	token_show(def_ref); print_ln(); flush_list(def_ref); selector = old_setting;
}

// 1373
void out_what(pointer p)
{
	small_number j;
	switch (subtype(p)) {
	case open_node:
	case write_node:
	case close_node:
		#pragma region <Do some work that has been queued up for write 1374>
		if (!doing_leaders) {
			j = write_stream(p);
			if (subtype(p) == write_node) write_out(p);
			else {
				if (write_open[j]) a_close(write_file[j]);
				if (subtype(p) == close_node) write_open[j] = false;
				else if (j < 16) {
					cur_name = open_name(p); cur_area = open_area(p); cur_ext = open_ext(p);
					if (cur_ext == TEX_STRING(""))
						cur_ext = TEX_STRING(".tex");
					pack_cur_name;
					while (!a_open_out(&write_file[j]))
						prompt_file_name(TEX_STRING("output file name"),
							TEX_STRING(".tex"));
					write_open[j] = true;
				}
			}
		}
		#pragma endregion
		break;
	case special_node:
		special_out(p);
		break;
	case language_node:
		//do_nothing
		break;

	default:
		confusion(TEX_STRING("ext4"));
		break;
	}
}


// 1348
void do_extension()
{
	//int i; 
	//int j;
	int k;
	pointer p;
	//pointer q;
	//pointer r;

	switch (cur_chr) {
	case open_node:
		#pragma region <Implement openout 1351>
		new_write_whatsit(open_node_size);
		scan_optional_equals();
		scan_file_name();
		open_name(tail) = cur_name; open_area(tail) = cur_area; open_ext(tail) = cur_ext;
		#pragma endregion
		break;
	case write_node:
		#pragma region <Implement write 1352>
		k = cur_cs; new_write_whatsit(write_node_size);
		cur_cs = k; p = scan_toks(false, false); write_tokens(tail) = def_ref;
		#pragma endregion
		break;
	case close_node:
		#pragma region <Implement closeout 1353>
		new_write_whatsit(write_node_size);
		write_tokens(tail) = null;
		#pragma endregion
		break;
	case special_node:
		#pragma region <Implement special 1354>
		new_whatsit(special_node, write_node_size); write_stream(tail) = null; p = scan_toks(false, true);
		write_tokens(tail) = def_ref;
		#pragma endregion
		break;
	case immediate_code:
		#pragma region <Implement immediate 1375>
		get_x_token();
		if (cur_cmd == extension && cur_chr <= close_node) {
			p = tail; do_extension();
			out_what(tail);
			flush_node_list(tail); tail = p; link(p) = null;
		}
		else
			back_input();
		#pragma endregion
		break;
	case set_language_code:
		#pragma region <Implement setlanguge 1377>
		if (abs(mode) != hmode)
			report_illegal_case();
		else {
			new_whatsit(language_node, small_node_size);
			scan_int();
			if (cur_val <= 0)
				clang = 0;
			else if (cur_val > 255)
				clang = 0;
			else
				clang = cur_val;
			what_lang(tail) = clang; what_lhm(tail) = norm_min(left_hyphen_min);
			what_rhm(tail) = norm_min(right_hyphen_min);
		}
		#pragma endregion
		break;

	default:
		confusion(TEX_STRING("ext1"));
		break;
	}
}

//1079
void begin_box(int box_context)
{
	pointer p, q;
	quarterword m;
	halfword k;
	eight_bits n;

	switch (cur_chr) {
	case box_code:
		scan_eight_bit_int();
		cur_box = box(cur_val);
		box(cur_val) = null;
		break;
	case copy_code:
		scan_eight_bit_int(); cur_box = copy_node_list(box(cur_val));
		break;
	case last_box_code:
		#pragma region <If the current list ends with a box node delete it from the list and make cur_box point to it; otherwise set cur_box = null 1080>
		cur_box = null;
		if (abs(mode) == mmode) {
			you_cant(); help1(TEX_STRING("Sorry; this \lastbox will be void."));
			error();
		}
		else if (mode == vmode && head == tail) {
			you_cant(); 
			help2(TEX_STRING("Sorry...I usually can't take things from the current page."),
				TEX_STRING("This \lastbox will therefore be void."));
			error();
		}
		else {
			if(!is_char_node(tail))
				if (type(tail) == hlist_node || type(tail) == vlist_node) 
					#pragma region <Remove the last box, unless its part of discretionary 1081>
				{
					q = head;
					do {
						p = q;
						if(!is_char_node(q))
							if (type(q) == disc_node) {
								for (m = 1; m <= replace_count(q); m++) p = link(p);

								if (p == tail) goto done;
							}
						q = link(p);
					} while (!(q == tail));
					cur_box = tail; shift_amount(cur_box) = 0; tail = p; link(p) = null;
				done:
					;
				}
					#pragma endregion
		}
		#pragma endregion
		break;
	case vsplit_code:
		#pragma region <Split off part of a vertical box, make cur_box point to it 1082>
		scan_eight_bit_int(); n = cur_val;
		if (!scan_keyword(TEX_STRING("to"))) {
			print_err(TEX_STRING("Missing `to' inserted"));
			help2(TEX_STRING("I'm working on `\vsplit<box number> to <dimen>';"),
				TEX_STRING("will look for the <dimen> next."));
			error();
		}
		scan_normal_dimen; cur_box = vsplit(n, cur_val);
		#pragma endregion
		break;
	default:
		#pragma region <Initiate the construction of an hbox or vbox, then return 1083>
		k = cur_chr - vtop_code; saved(0) = box_context;
		if (k == hmode)
			if (box_context < box_flag && abs(mode) == vmode) scan_spec(adjusted_hbox_group, true);
			else scan_spec(hbox_group, true);
		else {
			if (k == vmode) scan_spec(vbox_group, true);
			else {
				scan_spec(vtop_group, true); k = vmode;
			}
			normal_paragraph();
		}
		push_nest(); mode = (mode_type)-k;
		if (k == vmode) {
			prev_depth = ignore_depth;
			if (every_vbox != null) begin_token_list(every_vbox, every_vbox_text);
		}
		else {
			space_factor = 1000;
			if (every_hbox != null) begin_token_list(every_hbox, every_hbox_text);
		}
		return;
		#pragma endregion
		break;

	}
	box_end(box_context);
}

// 1070
void normal_paragraph()
{
	if (looseness != 0) eq_word_define(int_base + looseness_code, 0);
	if (hang_indent != 0) eq_word_define(dimen_base + hang_indent_code, 0);
	if (hang_after != 1) eq_word_define(int_base + hang_after_code, 1);
	if (par_shape_ptr != null) eq_define(par_shape_loc, shape_ref, null);
}

// 1091
// 1091
small_number norm_min(int h)
{
	if (h <= 0)
		return 1;
	else if (h >= 63)
		return 63;
	else
		return h;
}

void new_graf(bool indented)
{
	prev_graf = 0;
	if (mode == vmode || head != tail) tail_append(new_param_glue(par_skip_code));
	push_nest(); mode = hmode; space_factor = 1000; set_cur_lang; clang = cur_lang;
	prev_graf = (norm_min(left_hyphen_min) * 0100 + norm_min(right_hyphen_min)) * 0200000 + cur_lang;
	if (indented) {
		tail = new_null_box(); link(head) = tail; width(tail) = par_indent;
	}
	if (every_par != null) begin_token_list(every_par, every_par_text);
	if (nest_ptr == 1) build_page();
}

// 1093
void indent_in_hmode()
{
	pointer p, q;
	if (cur_chr > 0) {
		p = new_null_box(); width(p) = par_indent;
		if (abs(mode) == hmode) space_factor = 1000;
		else {
			q = new_noad(); math_type(nucleus(q)) = sub_box; info(nucleus(q)) = p; p = q;
		}
		tail_append(p);
	}
}

//791
bool fin_col()
{
	pointer p;
	pointer q, r;
	pointer s;
	pointer u;
	scaled w;
	glue_ord o;
	halfword n;

	if (cur_align == null) confusion(TEX_STRING("endv"));
	q = link(cur_align); if (q == null) confusion(TEX_STRING("endv"));
	if (align_state < 500000) fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
	p = link(q);
	#pragma region <If the preamble list has been traversed, check that the row has ended 792>
	if(p == null && extra_info(cur_align) < cr_code)
		if (cur_loop != null)
			#pragma region <Lengthen the preamble periodically 793>
		{
			link(q) = new_null_box(); p = link(q);
			info(p) = end_span; width(p) = null_flag; cur_loop = link(cur_loop);
			#pragma region <Copy the templates from node cur_loop into node p 794>
			q = hold_head; r = u_part(cur_loop);
			while (r != null) {
				link(q) = get_avail(); q = link(q); info(q) = info(r); r = link(r);
			}
			link(q) = null; u_part(p) = link(hold_head); q = hold_head; r = v_part(cur_loop);
			while (r != null) {
				link(q) = get_avail(); q = link(q); info(q) = info(r); r = link(r);
			}
			link(q) = null; v_part(p) = link(hold_head);
#pragma endregion

			cur_loop = link(cur_loop); link(p) = new_glue(glue_ptr(cur_loop));
		}
#pragma endregion
		else {
			print_err(TEX_STRING("Extra alignment tab has been changed to ")); print_esc(TEX_STRING("cr"));
			help3(TEX_STRING("You have given more \span or & marks than there were"),
				TEX_STRING("in the preamble to the \halign or \valign now in progress."),
				TEX_STRING("So I'll assume that you meant to type \cr instead."));
			extra_info(cur_align) = cr_code;
			error();
		}

	#pragma endregion

	if (extra_info(cur_align) != span_code) {
		unsave(); new_save_level(align_group);
		#pragma region <Package an unset box for the current column and record its width 796>
		{
			if (mode == -hmode) {
				adjust_tail = cur_tail; u = hpack(link(head), 0, additional); w = width(u); cur_tail = adjust_tail;
				adjust_tail = null;
			}
			else {
				u = vpackage(link(head), 0, additional, 0); w = height(u);
			}
			n = min_quarterword;
			if (cur_span != cur_align)
				#pragma region<Update width entry for spanned columns 798>
			{
				q = cur_span;
				do {
					incr(n); q = link(link(q));
				} while (!(q == cur_align));
				if (n > max_quarterword) confusion(TEX_STRING("256 spans"));
				q = cur_span;
				while (link(info(q)) < n) q = info(q);
				if (link(info(q)) > n) {
					s = get_node(span_node_size); info(s) = info(q); link(s) = n; info(q) = s; width(s) = w;
				}
				else if (width(info(q)) < w) width(info(q)) = w;
			}
				#pragma endregion

			else if (w > width(cur_align)) width(cur_align) = w;

			//overflow check
			if (n > 255) {
				printf("overflow assignment fin_col\n");
				exit(1);
			}
			//--------------------------
			type(u) = (quarterword)unset_node; span_count(u) = (quarterword)n;
			#pragma region <Determine the stretch order 659>
			if (total_stretch[filll] != 0) o = filll;
			else if (total_stretch[fill] != 0) o = fill;
			else if (total_stretch[fil] != 0) o = fil;
			else o = normal;
			#pragma endregion
			glue_order(u) = o; glue_stretch(u) = total_stretch[o];
			#pragma region <Determine the shrink order 665>
			if (total_shrink[filll] != 0) o = filll;
			else if (total_shrink[fill] != 0) o = fill;
			else if (total_shrink[fil] != 0) o = fil;
			else o = normal;
#pragma endregion
			glue_sign(u) = o; glue_shrink(u) = total_shrink[o];
			pop_nest(); link(tail) = u; tail = u;
		}
		#pragma endregion

		#pragma region <Copy the tabskip glue between columns 795>
		tail_append(new_glue(glue_ptr(link(cur_align)))); subtype(tail) = tab_skip_code + 1;
		#pragma endregion
		if (extra_info(cur_align) >= cr_code) {
			return true;
		}
		init_span(p);
	}
	align_state = 1000000;
	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
#pragma endregion

	cur_align = p; init_col();
	return false;
}

//799
void fin_row()
{
	pointer p;
	if (mode == -hmode) {
		p = hpack(link(head), 0, additional); pop_nest(); append_to_vlist(p);
		if (cur_head != cur_tail) {
			link(tail) = link(cur_head); tail = cur_tail;
		}
	}
	else {
		p = vpack(link(head), 0, additional); pop_nest(); link(tail) = p; tail = p; space_factor = 1000;
	}
	type(p) = unset_node; glue_stretch(p) = 0;
	if (every_cr != null) begin_token_list(every_cr, every_cr_text);
	align_peek();
}


// 1030
void main_control()
{
	int t;
	if (every_job != null)
		begin_token_list(every_job, every_job_text);
big_switch:
	get_x_token();
reswitch:
	#pragma region <Give diagnostic information, if requested 1031>
	if (interrupt != 0) {
		if (OK_to_interrupt) {
			back_input();
			check_interrupt;
			goto big_switch;
		}
	}
	//debug
	if (panicking)
		check_mem(false);
	//gubed
	if (tracing_commands > 0)
		show_cur_cmd_chr();
#pragma endregion

	switch (abs(mode) + cur_cmd) {
	case hmode + letter:
	case hmode + other_char:
	case hmode + char_given:
		goto main_loop;
		break;
	case hmode + char_num:
		scan_char_num();
		cur_chr = cur_val;
		goto main_loop;
		break;
	case hmode + no_boundary:
		get_x_token();
		if (cur_cmd == letter || cur_cmd == other_char || cur_cmd == char_given || cur_cmd == char_num)
			cancel_boundary = true;
		goto reswitch;
		break;
	case hmode + spacer:
		if (space_factor == 1000)
			goto append_normal_space;
		else
			app_space();
		break;
	case hmode + ex_space:
	case mmode + ex_space:
		goto append_normal_space;
		break;
		
	#pragma region <Cases of main_control that are not part of the inner loop 1045>
	case any_mode(relax):
	case vmode+spacer:
	case mmode+spacer:
	case mmode+no_boundary:
		break;
	case any_mode(ignore_spaces):
		#pragma region <Get the next non_blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion
		goto reswitch;
		break;
	case vmode+stop:
		if (its_all_over())
			return;
		break;

	#pragma region <Forbidden cases detected in main_control 1048>
	case vmode+vmove:
	case hmode+hmove:
	case mmode+hmove:
	case any_mode(last_item):
		// 1098
	case vmode+vadjust:
		//1111
	case vmode+ital_corr:
		//1144
	case non_math(eq_no):
	#pragma endregion

	case any_mode(mac_param):
		report_illegal_case();
		break;

	#pragma region <Math-only cases in non-math modes or vice versa 1046>
	case non_math(sup_mark):
	case non_math(sub_mark):
	case non_math(math_char_num):
	case non_math(math_given):
	case non_math(math_comp):
	case non_math(delim_num):
	case non_math(left_right):
	case non_math(above):
	case non_math(radical):
	case non_math(math_style):
	case non_math(math_choice):
	case non_math(vcenter):
	case non_math(non_script):
	case non_math(mkern):
	case non_math(limit_switch):
	case non_math(mskip):
	case non_math(math_accent):
	case mmode+endv:
	case mmode+par_end:
	case mmode+stop:
	case mmode+vskip:
	case mmode+un_vbox:
	case mmode+valign:
	case mmode+hrule:
		insert_dollar_sign();
		break;
#pragma endregion

	#pragma region <Cases of main_control that build boxes and lists 1056>
	case vmode+hrule:
	case hmode+vrule:
	case mmode+vrule:
		tail_append(scan_rule_spec());
		if (abs(mode) == vmode)
			prev_depth = ignore_depth;
		else if (abs(mode) == hmode)
			space_factor = 1000;
		break;
	// 1057
	case vmode+vskip:
	case hmode+hskip:
	case mmode+hskip:
	case mmode+mskip:
		append_glue();
		break;
	case any_mode(kern):
	case mmode+mkern:
		append_kern();
		break;

		//1063
	case non_math(left_brace):
		new_save_level(simple_group);
		break;
	case any_mode(begin_group):
		new_save_level(semi_simple_group);
		break;
	case any_mode(end_group):
		if (cur_group == semi_simple_group)
			unsave();
		else off_save();
		break;

		//1067
	case any_mode(right_brace):
		handle_right_brace();
		break;

		// 1073
	case vmode+hmove:
	case hmode+vmove:
	case mmode+vmove:
		t = cur_chr; scan_normal_dimen;
		if (t == 0)
			scan_box(cur_val);
		else
			scan_box(-cur_val);
		break;
	case any_mode(leader_ship):
		scan_box(leader_flag - a_leaders + cur_chr);
		break;
	case any_mode(make_box):
		begin_box(0);
		break;

		// 1090
	case vmode+start_par:
		new_graf(cur_chr > 0);
		break;
	case vmode+letter:
	case vmode+other_char:
	case vmode+char_num:
	case vmode+char_given:
	case vmode+math_shift:
	case vmode+un_hbox:
	case vmode+vrule:
	case vmode+accent:
	case vmode+discretionary:
	case vmode+hskip:
	case vmode+valign:
	case vmode+ex_space:
	case vmode+no_boundary:
		back_input();
		new_graf(true);
		break;

		// 1092
	case hmode+start_par:
	case mmode+start_par:
		indent_in_hmode();
		break;

		// 1094
	case vmode+par_end:
		normal_paragraph();
		if (mode > 0)
			build_page();
		break;
	case hmode+par_end:
		if (align_state < 0)
			off_save();
		end_graf();
		if (mode == vmode)
			build_page();
		break;
	case hmode+stop:
	case hmode+vskip:
	case hmode+hrule:
	case hmode+un_vbox:
	case hmode+halign:
		head_for_vmode();
		break;

		//1097
	case any_mode(insert):
	case hmode+vadjust:
	case mmode+vadjust:
		begin_insert_or_adjust();
		break;
	case any_mode(mark):
		make_mark();
		break;

		// 1102
	case any_mode(break_penalty):
		append_penalty();
		break;

	case any_mode(remove_item):
		delete_last();
		break;

		// 1109
	case vmode+un_vbox:
	case hmode+un_hbox:
	case mmode+un_hbox:
		unpackage();
		break;

		//1112
	case hmode+ital_corr:
		append_italic_correction();
		break;
	case mmode+ital_corr:
		tail_append(new_kern(0));
		break;

		//1116
	case hmode+discretionary:
	case mmode+discretionary:
		append_discretionary();
		break;

	case hmode+accent:
		make_accent();
		break;

		// 1126
	case any_mode(car_ret):
	case any_mode(tab_mark):
		align_error();
		break;
	case any_mode(no_align):
		no_align_error();
		break;
	case any_mode(omit):
		omit_error();
		break;

		//1130
	case vmode+halign:
	case hmode+valign:
		init_align();
		break;
	case mmode+halign:
		if (privileged())
			if (cur_group == math_shift_group)
				init_align();
			else
				off_save();
		break;
	case vmode+endv:
	case hmode+endv:
		do_endv();
		break;

		//1134
	case any_mode(end_cs_name):
		cs_error();
		break;

		// 1137
	case hmode+math_shift:
		init_math();
		break;

		// 1140
	case mmode+eq_no:
		if (privileged())
			if (cur_group == math_shift_group)
				start_eq_no();
			else off_save();

		break;

		// 1150
	case mmode+left_brace:
		tail_append(new_noad());
		back_input();
		scan_math(nucleus(tail));
		break;

		// 1154
	case mmode+letter:
	case mmode+other_char:
	case mmode+char_given:
		set_math_char(ho(math_code(cur_chr)));
		break;
	case mmode+char_num:
		scan_char_num();
		cur_chr = cur_val;
		set_math_char(ho(math_code(cur_chr)));
		break;
	case mmode+math_char_num:
		scan_fifteen_bit_int();
		set_math_char(cur_val);
		break;
	case mmode+math_given:
		set_math_char(cur_chr);
		break;
	case mmode+delim_num:
		scan_twenty_seven_bit_int();
		set_math_char(cur_val / 010000);
		break;

		// 1158
	case mmode+math_comp:
		// overflow check
		if (cur_chr > 255) {
			printf("Overflow assignment open_or_close_in\n");
			exit(1);
		}

		tail_append(new_noad()); type(tail) = (quarterword)cur_chr;
		scan_math(nucleus(tail));
		break;
	case mmode+limit_switch:
		math_limit_switch();
		break;

		// 1162
	case mmode+radical:
		math_radical();
		break;

		// 1164
	case mmode+accent:
	case mmode+math_accent:
		math_ac();
		break;

		// 1167
	case mmode+vcenter:
		scan_spec(vcenter_group, false);
		normal_paragraph();
		push_nest();
		mode = (mode_type)-vmode;
		prev_depth = ignore_depth;
		if (every_vbox != null)
			begin_token_list(every_vbox, every_vbox_text);
		break;

		// 1171
	case mmode+math_style:
		tail_append(new_style(cur_chr));
		break;
	case mmode+non_script:
		tail_append(new_glue(zero_glue)); subtype(tail) = cond_math_glue;
		break;
	case mmode+math_choice:
		append_choices();
		break;

		// 1175
	case mmode+sub_mark:
	case mmode+sup_mark:
		sub_sup();
		break;

		// 1180
	case mmode+above:
		math_fraction();
		break;

		// 1190
	case mmode+left_right:
		math_left_right();
		break;

		// 1193
	case mmode+math_shift:
		if (cur_group == math_shift_group)
			after_math();
		else
			off_save();
		break;
	#pragma endregion

	#pragma region <Cases of main_control that dont depend on mode 1210>
	case any_mode(toks_register):
	case any_mode(assign_toks):
	case any_mode(assign_int):
	case any_mode(assign_dimen):
	case any_mode(assign_glue):
	case any_mode(assign_mu_glue):
	case any_mode(assign_font_dimen):
	case any_mode(assign_font_int):
	case any_mode(set_aux):
	case any_mode(set_prev_graf):
	case any_mode(set_page_dimen):
	case any_mode(set_page_int):
	case any_mode(set_box_dimen):
	case any_mode(set_shape):
	case any_mode(def_code):
	case any_mode(def_family):
	case any_mode(set_font):
	case any_mode(def_font):
	case any_mode(_register):
	case any_mode(advance):
	case any_mode(multiply):
	case any_mode(divide):
	case any_mode(prefix):
	case any_mode(let):
	case any_mode(shorthand_def):
	case any_mode(read_to_cs):
	case any_mode(def):
	case any_mode(set_box):
	case any_mode(hyph_data):
	case any_mode(set_interaction):
		prefixed_command();
		break;

		// 1268
	case any_mode(after_assignment):
		get_token();
		after_token = cur_tok;
		break;

		// 1271
	case any_mode(after_group):
		get_token();
		save_for_after(cur_tok);
		break;

		//1274
	case any_mode(in_stream):
		open_or_close_in();
		break;

		// 1276
	case any_mode(message):
		issue_message();
		break;

		// 1285
	case any_mode(case_shift):
		shift_case();
		break;

		// 1290
	case any_mode(xray):
		show_whatever();
		break;

	#pragma endregion

	#pragma region <Cases of main_control that are for extensions fo TeX 1347>
	case any_mode(extension):
		do_extension();
		break;
#pragma endregion

	#pragma endregion

	}
	goto big_switch;

main_loop:

	#pragma region <Append character cur_chr and the following characters if any to the current hlist in the current font; goto reswitch when a non character has been reached 1034>
	adjust_space_factor;
	main_f = cur_font; bchar = font_bchar[main_f]; false_bchar = font_false_bchar[main_f];
	if (mode > 0)
		if (language != clang)
			fix_language();
	lig_stack = get_avail(); font(lig_stack) = main_f; cur_l = qi(cur_chr); 
	
	// overflow check
	if (cur_l > 255) {
		printf("Overflow assignment 1034\n");
		exit(1);
	}
	
	character(lig_stack) = (quarterword)cur_l;
	cur_q = tail;
	if (cancel_boundary) {
		cancel_boundary = false; main_k = non_address;
	}
	else main_k = bchar_label[main_f];
	if (main_k == non_address)
		goto main_loop_move_plus2;
	cur_r = cur_l; cur_l = non_char; goto main_lig_loop_plus1;

main_loop_wrapup:
	#pragma region <Make a ligature node, if ligature present; insert a null discretionary if appropriate 1035>

	wrapup(rt_hit);

	#pragma endregion

main_loop_move:
	#pragma region <If the cursor is immediately followed by the right boundary goto reswitch; .. 1036>
	if (lig_stack == null) goto reswitch;
	cur_q = tail; cur_l = character(lig_stack);
main_loop_move_plus1:
	if (!is_char_node(lig_stack)) goto main_loop_move_lig;

main_loop_move_plus2:
	if (cur_chr < font_bc[main_f] || cur_chr > font_ec[main_f]) {
		if (cur_chr > 255) {
			printf("overflow char warning\n");
			exit(1);
		}
		char_warning(main_f, (eight_bits)cur_chr); free_avail(lig_stack); goto big_switch;
	}
	main_i = char_info(main_f, cur_l);
	if (!char_exists(main_i)) {
		if (cur_chr > 255) {
			printf("overflow char warning\n");
			exit(1);
		}
		char_warning(main_f, (eight_bits)cur_chr); free_avail(lig_stack); goto big_switch;
	}
	link(tail) = lig_stack; tail = lig_stack;

	#pragma endregion
main_loop_lookahead:
	#pragma region <Look ahead for another character or leave lig_stack empty if theres none there 1038>
	get_next();
	if (cur_cmd == letter) goto main_loop_lookahead_plus1;
	if (cur_cmd == other_char) goto main_loop_lookahead_plus1;
	if (cur_cmd == char_given) goto main_loop_lookahead_plus1;
	x_token();
	if (cur_cmd == letter) goto main_loop_lookahead_plus1;
	if (cur_cmd == other_char) goto main_loop_lookahead_plus1;
	if (cur_cmd == char_given) goto main_loop_lookahead_plus1;
	if (cur_cmd == char_num) {
		scan_char_num(); cur_chr = cur_val; goto main_loop_lookahead_plus1;
	}
	if (cur_cmd == no_boundary) bchar = non_char;
	cur_r = bchar; lig_stack = null; goto main_lig_loop;
main_loop_lookahead_plus1:
	adjust_space_factor; lig_stack = get_avail(); font(lig_stack) = main_f;
	cur_r = qi(cur_chr);

	// overflow check
	if (cur_r > 255) {
		printf("Overflow assignment 1038\n");
		exit(1);
	}
	character(lig_stack) = (quarterword)cur_r;
	if (cur_r == false_bchar) cur_r = non_char;

#pragma endregion

main_lig_loop:
	#pragma region <If theres a ligature/kern command relevant to cur_l and cur_r adjust the text appropriatley exit to main_loop_wrapup 1039>
	if (char_tag(main_i) != lig_tag) goto main_loop_wrapup;
	if (cur_r == non_char) goto main_loop_wrapup;
	main_k = lig_kern_start(main_f, main_i); main_j = font_info[main_k].union_t.qqqq;
	if (skip_byte(main_j) <= stop_flag) goto main_lig_loop_plus2;
	main_k = lig_kern_restart(main_f, main_j);
main_lig_loop_plus1:
	main_j = font_info[main_k].union_t.qqqq;
main_lig_loop_plus2:
	if(next_char(main_j) == cur_r)
		if (skip_byte(main_j) <= stop_flag) 
			#pragma region <Do ligature or kern command returning to main_lig_loop or main_loop_wrapup or main_loop_move 1040>
		{
			
			if (op_byte(main_j) >= kern_flag) {
				wrapup(rt_hit); tail_append(new_kern(char_kern(main_f, main_j)));
				goto main_loop_move;
			}

			if (cur_l == non_char)
				lft_hit = true;
			else if (lig_stack == null)
				rt_hit = true;
			check_interrupt;


			switch (op_byte(main_j)) {
			case qi(1):
			case qi(5):
				cur_l = rem_byte(main_j);
				main_i = char_info(main_f, cur_l); ligature_present = true;
				break;
			case qi(2):
			case qi(6):
				cur_r = rem_byte(main_j);

				// overflow check
				if (cur_r > 255) {
					printf("Overflow assignment 1040\n");
					exit(1);
				}

				if (lig_stack == null)
				{
					lig_stack = new_lig_item((quarterword)cur_r); bchar = non_char;
				}
				else if (is_char_node(lig_stack)) {
					main_p = lig_stack; lig_stack = new_lig_item((quarterword)cur_r); lig_ptr(lig_stack) = main_p;
				}
				else character(lig_stack) = (quarterword)cur_r;
				break;

			case qi(3):
				cur_r = rem_byte(main_j);
				// overflow check
				if (cur_r > 255) {
					printf("Overflow assignment 1040\n");
					exit(1);
				}
				main_p = lig_stack; lig_stack = new_lig_item((quarterword)cur_r); link(lig_stack) = main_p;
				break;
			case qi(7):
			case qi(11):
				wrapup(false);
				cur_q = tail; cur_l = rem_byte(main_j); main_i = char_info(main_f, cur_l);
				ligature_present = true;
				break;
			default:
				cur_l = rem_byte(main_j); ligature_present = true;
				if (lig_stack == null)
					goto main_loop_wrapup;
				else goto main_loop_move_plus1;
				break;
			}
			if (op_byte(main_j) > qi(4))
				if (op_byte(main_j) != qi(7)) goto main_loop_wrapup;
			if (cur_l < non_char) goto main_lig_loop;
			main_k = bchar_label[main_f]; goto main_lig_loop_plus1;
		}
			#pragma endregion
	if (skip_byte(main_j) == qi(0)) incr(main_k);
	else {
		if (skip_byte(main_j) >= stop_flag) goto main_loop_wrapup;
		main_k += qo(skip_byte(main_j)) + 1;
	}
	goto main_lig_loop_plus1;

	#pragma endregion

main_loop_move_lig:
	#pragma region <Move the cursor past a pseudo ligature then goto main_loop_lookahead or main_lig_loop 1037>
	main_p = lig_ptr(lig_stack);
	if (main_p > null) tail_append(main_p);
	temp_ptr = lig_stack; lig_stack = link(temp_ptr); free_node(temp_ptr, small_node_size);
	main_i = char_info(main_f, cur_l); ligature_present = true;
	if (lig_stack == null)
		if (main_p > null) goto main_loop_lookahead;
		else cur_r = bchar;
	else cur_r = character(lig_stack);
	goto main_lig_loop;
	#pragma endregion

	#pragma endregion

append_normal_space:
	#pragma region <Append a normal inter-word space to the current list then goto big_switch 1041>
	if (space_skip == zero_glue) {
		#pragma region <Find the glue spec main_p for text spaces in the current font 1042>
		{
			main_p = font_glue[cur_font];
			if (main_p == null) {
				main_p = new_spec(zero_glue); main_k = param_base[cur_font] + space_code;
				width(main_p) = font_info[main_k].sc;
				stretch(main_p) = font_info[main_k + 1].sc;
				shrink(main_p) = font_info[main_k + 2].sc;
				font_glue[cur_font] = main_p;
			}
		}
		#pragma endregion
		temp_ptr = new_glue(main_p);
	}
	else temp_ptr = new_param_glue(space_skip_code);
	link(tail) = temp_ptr; tail = temp_ptr; goto big_switch;
	#pragma endregion

	return;
}

// 437
void scan_twenty_seven_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 0777777777) {
		print_err(TEX_STRING("Bad delimiter code"));
		help2(TEX_STRING("A numeric delimiter code must be between 0 and 2^{27}-1."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

// 688
pointer new_style(small_number s)
{
	pointer p;

	p = get_node(style_node_size); type(p) = style_node; subtype(p) = s;
	width(p) = 0;
	depth(p) = 0;
	return p;
}

//1131
void do_endv()
{
	base_ptr = input_ptr; input_stack[base_ptr] = cur_input;
	while (input_stack[base_ptr].index_field != v_template && input_stack[base_ptr].loc_field == null &&
		input_stack[base_ptr].state_field == token_list) decr(base_ptr);
	if (input_stack[base_ptr].index_field != v_template || input_stack[base_ptr].loc_field !=
		null || input_stack[base_ptr].state_field != token_list)
		fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
	if (cur_group == align_group) {
		end_graf();
		if (fin_col()) fin_row();
	}
	else off_save();
}

//1135
void cs_error()
{
	print_err(TEX_STRING("Extra "));
	print_esc(TEX_STRING("endcsname"));
	help1(TEX_STRING("I'm ignoring this, since I wasn't doing a \csname."));
	error();
}

//1138
void init_math()
{
	scaled w;
	scaled l;
	scaled s;
	pointer p;
	pointer q;
	internal_font_number f;
	int n;
	scaled v;
	scaled d;

	get_token();
	if (cur_cmd == math_shift && mode > 0)
		#pragma region <Go into display math mode 1145>
	{
		if (head == tail) {
			pop_nest(); w = -max_dimen;
		}
		else {
			line_break(display_widow_penalty);
			#pragma region <Calculate the natural width, w, by which the characters of teh final line extend ot teh right..1146>
			v = shift_amount(just_box) + 2 * quad(cur_font); w = -max_dimen; p = list_ptr(just_box);
			while (p != null) {
				#pragma region <Let d be the natural width of node p; if the node is visible.. 1147>
				reswitch:
						if (is_char_node(p)) {
							f = font(p); d = char_width(f, char_info(f, character(p))); goto found;
						}
						switch (type(p)) {
						case hlist_node:
						case vlist_node:
						case rule_node:
							d = width(p); goto found;
							break;
						case ligature_node:
							#pragma region <Make node p look like a char_node and goto reswitch 652>
							mem[lig_trick] = mem[lig_char(p)]; link(lig_trick) = link(p); p = lig_trick;
							goto reswitch;
							#pragma endregion
							break;
						case kern_node:
						case math_node:
							d = width(p);
							break;
						case glue_node:
							#pragma region <Let d be the natural width of this glue; if stretching or shrinking, .. 1148>
							q = glue_ptr(p); d = width(q);
							if (glue_sign(just_box) == stretching) {
								if (glue_order(just_box) == stretch_order(q) && stretch(q) != 0) v = max_dimen;
							}
							else if (glue_sign(just_box) == shrinking) {
								if (glue_order(just_box) == shrink_order(q) && shrink(q) != 0) v = max_dimen;
							}
							if (subtype(p) >= a_leaders) goto found;
#pragma endregion
							break;
						case whatsit_node:
							#pragma region <Let d be the width of the whatsit p 1361>
							d = 0;
#pragma endregion
							break;

						default: d = 0; break;
						}
				#pragma endregion
				if (v < max_dimen) v += d;
				goto not_found;
			found:
				if (v < max_dimen) {
					v += d; w = v;
				}
				else {
					w = max_dimen; goto done;
				}
			not_found:
				p = link(p);
			}
done:;
			#pragma endregion
		}
		#pragma region <Calculate the length, l, and the shift amount, s, of the display lines 1149>
		if(par_shape_ptr == null)
			if (hang_indent != 0 && (hang_after >= 0 && prev_graf + 2 > hang_after || prev_graf + 1 < -hang_after)) {
				l = hsize - abs(hang_indent);
				if (hang_indent > 0) s = hang_indent;
				else s = 0;
			}
			else {
				l = hsize; s = 0;
			}
		else {
			n = info(par_shape_ptr);
			if (prev_graf + 2 >= n) p = par_shape_ptr + 2 * n;
			else p = par_shape_ptr + 2 * (prev_graf + 2);
			s = mem[p - 1].sc; l = mem[p].sc;
		}
		#pragma endregion

		push_math(math_shift_group); mode = mmode; eq_word_define(int_base + cur_fam_code, -1);
		eq_word_define(dimen_base + pre_display_size_code, w);
		eq_word_define(dimen_base + display_width_code, l); eq_word_define(dimen_base + display_indent_code, s);
		if (every_display != null) begin_token_list(every_display, every_display_text);
		if (nest_ptr == 1) build_page();
	}
		#pragma endregion
	else {
		back_input();
		#pragma region <Go into ordinary math mode 1139>
		{
			push_math(math_shift_group); eq_word_define(int_base + cur_fam_code, -1);
			if (every_math != null) begin_token_list(every_math, every_math_text);
		}
#pragma endregion
	}
}

// 1142
void start_eq_no()
{
	saved(0) = cur_chr; incr(save_ptr);
	#pragma region <Go into ordinary math mode 1139>
	{
		push_math(math_shift_group); eq_word_define(int_base + cur_fam_code, -1);
		if (every_math != null) begin_token_list(every_math, every_math_text);
	}
#pragma endregion
}

// 1151
void scan_math(pointer p)
{
	int c;

restart:

	#pragma region <Get the next non-blank non-relax non-call token 404>
	do
	{
		get_x_token();
	} while (!(cur_cmd != spacer && cur_cmd != relax));
#pragma endregion

reswitch:

	switch (cur_cmd) {
	case letter:
	case other_char:
	case char_given:
		c = ho(math_code(cur_chr));
		if (c == 0100000) {
			#pragma region <Treat cur_chr as an active character 1152>
			{
				cur_cs = cur_chr + active_base; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs); x_token();
				back_input();
			}
#pragma endregion
			goto restart;
		}
		break;
	case char_num:
		scan_char_num(); cur_chr = cur_val; cur_cmd = char_given; goto reswitch;
		break;
	case math_char_num:
		scan_fifteen_bit_int(); c = cur_val;
		break;
	case math_given:
		c = cur_chr;
		break;
	case delim_num:
		scan_twenty_seven_bit_int(); c = cur_val / 010000;
		break;
	default:
		#pragma region <Scan a subformula enclosed in braces and return 1153>
		back_input(); scan_left_brace();
		saved(0) = p; incr(save_ptr); push_math(math_group); return;
#pragma endregion
		break;
	}
	math_type(p) = math_char; character(p) = qi(c % 256);
	if (c >= var_code && fam_in_range) fam(p) = cur_fam;
	else 
		fam(p) = (c / 256) % 16;


}

// 1155
void set_math_char(int c)
{
	pointer p;

	if (c >= 0100000)
		#pragma region <treat cur_chr as an active character 1152>
	{
		cur_cs = cur_chr + active_base; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs); x_token();
		back_input();
	}
		#pragma endregion
	else {
		p = new_noad(); math_type(nucleus(p)) = math_char;
		character(nucleus(p)) = qi(c % 256); fam(nucleus(p)) = (c / 256) % 16;
		if (c >= var_code) {
			if (fam_in_range) fam(nucleus(p)) = cur_fam;
			type(p) = ord_noad;
		}
		else type(p) = ord_noad + (c / 010000);
		link(tail) = p; tail = p;
	}
}

// 782
void get_preamble_token()
{
restart:
	get_token();
	while (cur_chr == span_code && cur_cmd == tab_mark) {
		get_token();
		if (cur_cmd > max_command) {
			expand(); get_token();
		}
	}
	if (cur_cmd == endv) fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
	if (cur_cmd == assign_glue && cur_chr == glue_base + tab_skip_code) {
		scan_optional_equals(); scan_glue(glue_val);
		if (global_defs > 0) geq_define(glue_base + tab_skip_code, glue_ref, cur_val);
		else eq_define(glue_base + tab_skip_code, glue_ref, cur_val);
		goto restart;
	}
}


// 774
void init_align()
{
	pointer save_cs_ptr;
	pointer p;

	save_cs_ptr = cur_cs;
	push_alignment(); align_state = -1000000;
	#pragma region <Check for improper alignment in displayed math 776>
	if (mode == mmode && (tail != head || incompleat_noad != null)) {
		print_err(TEX_STRING("Improper ")); print_esc(TEX_STRING("halign")); print(TEX_STRING(" inside $$'s"));
		help3(TEX_STRING("Displays can use special alignments (like \eqalignno)"),
			TEX_STRING("only if nothing but the alignment itself is between $$'s."),
			TEX_STRING("So I've deleted the formulas that preceded this alignment."));
		error();
		flush_math();
	}
#pragma endregion
	push_nest();
	#pragma region <Change current mode to -vmode for halign, -hmode for valign 775>
	if (mode == mmode) {
		mode = (mode_type)-vmode; prev_depth = nest[nest_ptr - 2].aux_field.sc;
	}
	else if (mode > 0)
		mode = (mode_type)-mode;

#pragma endregion
	scan_spec(align_group, false);
	#pragma region <Scan the preamble and record it in the preamble list 777>
	preamble = null; cur_align = align_head; cur_loop = null; scanner_status = aligning;
	warning_index = save_cs_ptr; align_state = -1000000;
	while (1) {
		#pragma region <Append the current tabskip glue to the preamble list 778>
		link(cur_align) = new_param_glue(tab_skip_code); cur_align = link(cur_align);
		#pragma endregion
		if (cur_cmd == car_ret) goto done;
		#pragma region <Scan preamble text until cur_cmd is tab_mark or car_ret, looking for changes in.. 779>

		#pragma region <Scan the template <u_j>, putting the resulting token list in hold_head 783>
		p = hold_head; link(p) = null;
		while (1) {
			get_preamble_token();
			if (cur_cmd == mac_param) goto done1;
			if (cur_cmd <= car_ret && cur_cmd >= tab_mark && align_state == -1000000)
				if (p == hold_head && cur_loop == null && cur_cmd == tab_mark) cur_loop = cur_align;
				else {
					print_err(TEX_STRING("Missing # inserted in alignment preamble"));
					help3(TEX_STRING("There should be exactly one # between &'s, when an"),
						TEX_STRING("\halign or \valign is being set up. In this case you had"),
						TEX_STRING("none, so I've put one in; maybe that will work."));
					back_error();
					goto done1;
				}
			else if (cur_cmd != spacer || p != hold_head) {
				link(p) = get_avail(); p = link(p); info(p) = cur_tok;
			}
		}
	done1:

#pragma endregion
		link(cur_align) = new_null_box(); cur_align = link(cur_align);
		info(cur_align) = end_span; width(cur_align) = null_flag; u_part(cur_align) = link(hold_head);
		#pragma region <Scan the template <v_j>, putting the resulting token list in hold_head 784>
		p = hold_head; link(p) = null;
		while (1) {
		mycontinue:
			get_preamble_token();
			if (cur_cmd <= car_ret && cur_cmd >= tab_mark && align_state == -1000000) goto done2;
			if (cur_cmd == mac_param) {
				print_err(TEX_STRING("Only one # is allowed per tab"));
				help3(TEX_STRING("There should be exactly one # between &'s, when an"),
					TEX_STRING("\halign or \valign is being set up. In this case you had"),
					TEX_STRING("more than one, so I'm ignoring all but the first."));
				error();
				goto mycontinue;
			}
			link(p) = get_avail(); p = link(p); info(p) = cur_tok;
		}
	done2:
		link(p) = get_avail(); p = link(p); info(p) = end_template_token;
#pragma endregion
		v_part(cur_align) = link(hold_head);

		#pragma endregion
	}
done:
	scanner_status = normal;
	#pragma endregion
	new_save_level(align_group);
	if (every_cr != null) begin_token_list(every_cr, every_cr_text);
	align_peek();
}

// 1376
void fix_language()
{
	ASCII_code l;
	if (language <= 0)
		l = 0;
	else if (language > 255) l = 0;
	else l = language;

	if (l != clang) {
		new_whatsit(language_node, small_node_size); what_lang(tail) = l; clang = l;
		what_lhm(tail) = norm_min(left_hyphen_min); what_rhm(tail) = norm_min(right_hyphen_min);
	}
}



// 1095
void head_for_vmode()
{
	if (mode < 0)
		if (cur_cmd != hrule) off_save();
		else {
			print_err(TEX_STRING("You can't use `"));
			print_esc(TEX_STRING("hrule"));
			print(TEX_STRING("' here except with leaders"));
			help2(TEX_STRING("To put a horizontal rule in an hbox or an alignment,"),
				TEX_STRING("you should use \leaders or \hrulefill (see The TeXbook)."));
			error();
		}
	else {
		back_input(); cur_tok = par_token; back_input(); token_type = inserted;
	}
}


// 1123
void make_accent()
{
	double s, t;
	pointer p, q, r;
	internal_font_number f;
	scaled a, h, x, w, delta;
	four_quarters i;

	scan_char_num(); f = cur_font; p = new_character(f, cur_val);
	if (p != null) {
		x = x_height(f); s = slant(f) / 65536.0f;
		a = char_width(f, char_info(f, character(p)));
		do_assignments();
		#pragma region <Create a character node q for the next character, but set q = null if problems arise 1124>
		q = null; f = cur_font;
		if (cur_cmd == letter || cur_cmd == other_char || cur_cmd == char_given) {
			// overflow check
			if (cur_chr > 255) {
				printf("Overflow assignment make_accent\n");
				exit(1);
			}
			q = new_character(f, (quarterword)cur_chr);
		}
		else if (cur_cmd == char_num) {
			scan_char_num(); q = new_character(f, cur_val);
		}
		else back_input();
		#pragma endregion
		if (q != null)
			#pragma region <Append the accent with appropriate kerns, then set p = q 1125>
		{
			t = slant(f) / 65536.0f; i = char_info(f, character(q)); w = char_width(f, i);
			h = char_height(f, height_depth(i));
			if (h != x) {
				p = hpack(p, 0, additional); shift_amount(p) = x - h;
			}
			delta = scaled(round((w - a) / 2.0f + h * t - x * s)); r = new_kern(delta); subtype(r) = acc_kern;
			link(tail) = r; link(r) = p; tail = new_kern(-a - delta); subtype(tail) = acc_kern; link(p) = tail;
			p = q;
		}
			#pragma endregion
		link(tail) = p; tail = p; space_factor = 1000;
	}
}

//1127
void align_error()
{
	if (abs(align_state) > 2)
		#pragma region <Express consternation over the fact that no alignment is in progress 1128>
	{
		print_err(TEX_STRING("Misplaced ")); print_cmd_chr(cur_cmd, cur_chr);
		if (cur_tok == tab_token + TEX_STRING("&")) {
			help6(TEX_STRING("I can't figure out why you would want to use a tab mark"),
				TEX_STRING("here. If you just want an ampersand, the remedy is"),
				TEX_STRING("simple: Just type `I\&' now. But if some right brace"),
				TEX_STRING("up above has ended a previous alignment prematurely,"),
				TEX_STRING("you're probably due for more error messages, and you"),
				TEX_STRING("might try typing `S' now just to see what is salvageable."));
		}
		else {
			help5(TEX_STRING("I can't figure out why you would want to use a tab mark"),
				TEX_STRING("or \cr or \span just now. If something like a right brace"),
				TEX_STRING("up above has ended a previous alignment prematurely,"),
				TEX_STRING("you're probably due for more error messages, and you"),
				TEX_STRING("might try typing `S' now just to see what is salvageable."));
		}
		error();
	}
#pragma endregion
	else {
		back_input();
		if (align_state < 0) {
			print_err(TEX_STRING("Missing { inserted")); incr(align_state); cur_tok = left_brace_token + TEX_STRING("{");
		}
		else {
			print_err(TEX_STRING("Missing } inserted")); decr(align_state); cur_tok = right_brace_token + TEX_STRING("}");
		}
		help3(TEX_STRING("I've put in what seems to be necessary to fix"),
			TEX_STRING("the current column of the current alignment."),
			TEX_STRING("Try to go on, since this might almost work."));
		ins_error();
	}
}

// 1129
void no_align_error()
{
	print_err(TEX_STRING("Misplaced "));
	print_esc(TEX_STRING("noalign"));
	help2(TEX_STRING("I expect to see \noalign only after the \cr of"),
		TEX_STRING("an alignment. Proceed, and I'll ignore this case."));
	error();
}

void omit_error()
{
	print_err(TEX_STRING("Misplaced ")); 
	print_esc(TEX_STRING("omit"));
	help2(TEX_STRING("I expect to see \omit only after tab marks or the \cr of"),
		TEX_STRING("an alignment. Proceed, and I'll ignore this case."));
	error();
}

// 1117
void append_discretionary()
{
	int c;
	tail_append(new_disc());
	if (cur_chr == 1) {
		c = hyphen_char[cur_font];
		if (c >= 0)
			if (c < 256) pre_break(tail) = new_character(cur_font, c);
	}
	else {
		incr(save_ptr); saved(-1) = 0; new_save_level(disc_group);
		scan_left_brace(); push_nest();
		mode = (mode_type)-hmode; space_factor = 1000;
	}
}

// 968
pointer prune_page_top(pointer p)
{
	pointer prev_p;
	pointer q;

	prev_p = temp_head; link(temp_head) = p;
	while(p!=null)
		switch (type(p)) {
		case hlist_node:
		case vlist_node:
		case rule_node:
			#pragma region <Insert glue for split_top_skip and set p = null 969>
			q = new_skip_param(split_top_skip_code); link(prev_p) = q; link(q) = p;
			if (width(temp_ptr) > height(p)) width(temp_ptr) -= height(p);
			else width(temp_ptr) = 0;
			p = null;
#pragma endregion
			break;
		case whatsit_node:
		case mark_node:
		case ins_node:
			prev_p = p; p = link(prev_p);
			break;
		case glue_node:
		case kern_node:
		case penalty_node:
			q = p; p = link(q); link(q) = null; link(prev_p) = p;
			flush_node_list(q);
			break;
		default:
			confusion(TEX_STRING("pruning"));
			break;
		}

	return link(temp_head);
}

// 1113
void append_italic_correction()
{
	pointer p;
	internal_font_number f;
	
	if (tail != head) {
		if (is_char_node(tail)) p = tail;
		else if (type(tail) == ligature_node) p = lig_char(tail);
		else return;
		f = font(p); tail_append(new_kern(char_italic(f, char_info(f, character(p)))));
		subtype(tail) = _explicit;
	}
}

// 815
void line_break(int final_widow_penalty)
{
	#pragma region <Local variables for line breaking 862>
	bool auto_breaking;
	pointer prev_p;
	pointer q, r, s, prev_s;
	internal_font_number f;

	//893
	small_number j;
	unsigned char c;

	#pragma endregion

	pack_begin_line = mode_line;

	#pragma region <Get ready to start line breaking 816>
	link(temp_head) = link(head);
	if (is_char_node(tail)) tail_append(new_penalty(inf_penalty));
	else if (type(tail) != glue_node) tail_append(new_penalty(inf_penalty));
	else {
		type(tail) = penalty_node; delete_glue_ref(glue_ptr(tail)); flush_node_list(leader_ptr(tail));
		penalty(tail) = inf_penalty;
	}
	link(tail) = new_param_glue(par_fill_skip_code); init_cur_lang = prev_graf % 0200000;
	init_l_hyf = prev_graf / 020000000; init_r_hyf = (prev_graf / 0200000) % 0100;
	pop_nest();

	//827
	no_shrink_error_yet = true;
	check_shrinkage(left_skip); check_shrinkage(right_skip);
	q = left_skip; r = right_skip; background[1] = width(q) + width(r);
	background[2] = 0; background[3] = 0; background[4] = 0; background[5] = 0;
	background[2 + stretch_order(q)] = stretch(q);
	background[2 + stretch_order(r)] += stretch(r);
	background[6] = shrink(q) + shrink(r);

	//834
	minimum_demerits = awful_bad; minimal_demerits[tight_fit] = awful_bad;
	minimal_demerits[decent_fit] = awful_bad; minimal_demerits[loose_fit] = awful_bad;
	minimal_demerits[very_loose_fit] = awful_bad;

	//848
	if(par_shape_ptr == null)
		if (hang_indent == 0) {
			last_special_line = 0; second_width = hsize; second_indent = 0;
		}
		else
			#pragma region <Set line length paramters in preparation for hanging indentation 849>
		{
			last_special_line = abs(hang_after);
			if (hang_after < 0) {
				first_width = hsize - abs(hang_indent);
				if (hang_indent >= 0) first_indent = hang_indent;
				else first_indent = 0;
				second_width = hsize; second_indent = 0;
			}
			else {
				first_width = hsize; first_indent = 0; second_width = hsize - abs(hang_indent);
				if (hang_indent >= 0) second_indent = hang_indent;
				else second_indent = 0;
			}
		}
			#pragma endregion
	else {
		last_special_line = info(par_shape_ptr) - 1;
		second_width = mem[par_shape_ptr + 2 * (last_special_line + 1)].sc;
		second_indent = mem[par_shape_ptr + 2 * last_special_line + 1].sc;
	}
	if (looseness == 0) easy_line = last_special_line;
	else easy_line = max_halfword;


	#pragma endregion

	#pragma region <Find optimal breakpoints 863>
	threshold = pretolerance;
	if (threshold >= 0) {
		//stat
		if (tracing_paragraphs > 0) {
			begin_diagnostic(); print_nl(TEX_STRING("@firstpass"));
		}
		//tats
		second_pass = false; final_pass = false;
	}
	else {
		threshold = tolerance; second_pass = true;
		final_pass = (emergency_stretch <= 0);
		//stat
		if (tracing_paragraphs > 0) begin_diagnostic();
		//tats
	}
	while (1) {
		if (threshold > inf_bad) threshold = inf_bad;
		if (second_pass)
			#pragma region <Initialize for hyphenating a paragraph 891>
		{
			//init
			if (trie_not_ready) init_trie();
			//tini
			cur_lang = init_cur_lang; l_hyf = init_l_hyf; r_hyf = init_r_hyf;
		}
			#pragma endregion

		#pragma region <Create an active breakpoint representing the beginning of the paragraph 864>
		q = get_node(active_node_size); type(q) = unhyphenated; fitness(q) = decent_fit; link(q) = last_active;
		break_node(q) = null; line_number(q) = prev_graf + 1; total_demerits(q) = 0; link(active) = q;
		do_all_six(store_background);
		passive = null; printed_node = temp_head; pass_number = 0; font_in_short_display = null_font;
		#pragma endregion

		cur_p = link(temp_head); auto_breaking = true;
		prev_p = cur_p;
		while (cur_p != null && link(active) != last_active)
			#pragma region <Call try_break if cur_p is a legal breakpoint;... 866>
		{
			if (is_char_node(cur_p))
				#pragma region <Advance cur_p to the node following the present string of characters 867>
			{
				prev_p = cur_p;
				do {
					f = font(cur_p); act_width += char_width(f, char_info(f, character(cur_p)));
					cur_p = link(cur_p);
				} while (!(!is_char_node(cur_p)));
			}
				#pragma endregion

			switch (type(cur_p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
				act_width += width(cur_p);
				break;
			case whatsit_node:
				#pragma region <Advance past a whatsit node in the line_break loop 1362>
				adv_past(cur_p);
				#pragma endregion
				break;
			case glue_node:
				#pragma region <If node cur_p is a legal breakpoint, call try_break ... 868>
				if (auto_breaking) {
					if (is_char_node(prev_p)) try_break(0, unhyphenated);
					else if (precedes_break(prev_p)) try_break(0, unhyphenated);
					else if (type(prev_p) == kern_node && subtype(prev_p) != _explicit) try_break(0, unhyphenated);
				}
				check_shrinkage(glue_ptr(cur_p)); q = glue_ptr(cur_p); act_width += width(q);
				active_width[2 + stretch_order(q)] += stretch(q);
				active_width[6] += shrink(q);
				#pragma endregion
				if(second_pass && auto_breaking)
					#pragma region <Try to hyphenate the following word 894>
				{ 
					prev_s = cur_p; s = link(prev_s);
					if (s != null) {
						#pragma region <Skip to node ha, or goto done1 if no hyphenaotn should be attempted 896>
						while (1) {
							if (is_char_node(s)) {
								c = qo(character(s)); hf = font(s);
							}
							else if (type(s) == ligature_node)
								if (lig_ptr(s) == null) goto mycontinue;
								else {
									q = lig_ptr(s); c = qo(character(q)); hf = font(q);
								}
							else if (type(s) == kern_node && subtype(s) == normal) goto mycontinue;
							else if (type(s) == whatsit_node) {
								#pragma region <Advance past a whatsit node in the pre-hyphenation loop 1363>
								adv_past(s);
#pragma endregion
								goto mycontinue;
							}
							else goto done1;
							if (lc_code(c) != 0)
								if (lc_code(c) == c || uc_hyph > 0) goto done2;
								else goto done1;
							mycontinue:
								prev_s = s; s = link(prev_s);
						}
					done2: hyf_char = hyphen_char[hf];
						if (hyf_char < 0) goto done1;
						if (hyf_char > 255) goto done1;
						ha = prev_s;
#pragma endregion
						if (l_hyf + r_hyf > 63) goto done1;
						#pragma region <Skip to node hb, putting letters into hu and hc 897>
						hn = 0;
						while (1) {
							if (is_char_node(s)) {
								if (font(s) != hf) goto done3;
								hyf_bchar = character(s); c = qo(hyf_bchar);
								if (lc_code(c) == 0) goto done3;
								if (hn == 63) goto done3;
								hb = s; incr(hn); hu[hn] = c; hc[hn] = lc_code(c); hyf_bchar = non_char;
							}
							else if (type(s) == ligature_node)
								#pragma region <Move the characters of a ligature node to hu and hc; but got done3... 898>
							{ 
								if (font(lig_char(s)) != hf) goto done3;
								j = hn; q = lig_ptr(s); if (q > null) hyf_bchar = character(q);
								while (q > null) {
									c = qo(character(q));
									if (lc_code(c) == 0) goto done3;
									if (j == 63) goto done3;
									incr(j); hu[j] = c; hc[j] = lc_code(c);
									q = link(q);
								}
								hb = s; hn = j;
								if (myodd(subtype(s))) hyf_bchar = font_bchar[hf];
								else hyf_bchar = non_char;
							}
								#pragma endregion
							else if (type(s) == kern_node && subtype(s) == normal) {
								hb = s; hyf_bchar = font_bchar[hf];
							}
							else goto done3;
							s = link(s);
						}
						done3:
#pragma endregion
						#pragma region <Check that the nodes following hb permit hyphenation and that at least l_hyf... 899>
						if (hn < l_hyf + r_hyf) goto done1;
						while (1) {
							if(!is_char_node(s))
								switch (type(s)) {
								case ligature_node:
									//do_nothing
									break;
								case kern_node:
									if (subtype(s) != normal) goto done4;
									break;
								case whatsit_node:
								case glue_node:
								case penalty_node:
								case ins_node:
								case adjust_node:
								case mark_node:
									goto done4;
									break;
								default:
									goto done1;
									break;
								}
							s = link(s);
						}
					done4:
#pragma endregion
						hyphenate();
					}
				done1:
					;
				}
#pragma endregion
				break;
			case kern_node:
				if (subtype(cur_p) == _explicit) kern_break;
				else act_width += width(cur_p);
				break;
			case ligature_node:
				f = font(lig_char(cur_p));
				act_width += char_width(f, char_info(f, character(lig_char(cur_p))));
				break;

			case disc_node:
				#pragma region <Try to break after a discretionary fragment, then goto done5 869>
				s = pre_break(cur_p); disc_width = 0;
				if (s == null) try_break(ex_hyphen_penalty, hyphenated);
				else {
					do {
						#pragma region <Add the width of node s to disc_width 870>
						if (is_char_node(s)) {
							f = font(s); disc_width += char_width(f, char_info(f, character(s)));
						}
						else
							switch (type(s)) {
							case ligature_node:
								f = font(lig_char(s));
								disc_width += char_width(f, char_info(f, character(lig_char(s))));
								break;
							case hlist_node:
							case vlist_node:
							case rule_node:
							case kern_node:
								disc_width += width(s);
								break;

							default:
								confusion(TEX_STRING("disc3"));
								break;
							}
						
						#pragma endregion
						s = link(s);
					} while (!(s == null));
					act_width += disc_width; try_break(hyphen_penalty, hyphenated);
					act_width -= disc_width;
				}
				r = replace_count(cur_p); s = link(cur_p);
				while (r > 0) {
					#pragma region <Add the width of node s to act_width 871>
					if (is_char_node(s)) {
						f = font(s); act_width += char_width(f, char_info(f, character(s)));
					}
					else switch (type(s)) {
					case ligature_node:
						f = font(lig_char(s));
						act_width += char_width(f, char_info(f, character(lig_char(s))));
						break;
					case hlist_node:
					case vlist_node:
					case rule_node:
					case kern_node:
						act_width += width(s);
						break;

					default:
						confusion(TEX_STRING("disc4"));
						break;
					}
					#pragma endregion
					decr(r); s = link(s);
				}
				prev_p = cur_p; cur_p = s; goto done5;
				#pragma endregion
				break;
			case math_node:
				auto_breaking = (subtype(cur_p) == after); kern_break;
				break;
			case penalty_node:
				try_break(penalty(cur_p), unhyphenated);
				break;
			case mark_node:
			case ins_node:
			case adjust_node:
				//do_nothing
				break;

			default:
				confusion(TEX_STRING("paragraph"));
				break;
			}
			prev_p = cur_p; cur_p = link(cur_p);
		done5:
			;
		}
			#pragma endregion

		if (cur_p == null)
			#pragma region <Try the final line break at the end of the paragraph, ... 873>
		{
			try_break(eject_penalty, hyphenated);
			if (link(active) != last_active) {
				#pragma region <Find an active node with fewest demerits 874>
				r = link(active); fewest_demerits = awful_bad;
				do {
					if(type(r) != delta_node)
						if (total_demerits(r) < fewest_demerits) {
							fewest_demerits = total_demerits(r); best_bet = r;
						}
					r = link(r);
				} while (!(r == last_active));
				best_line = line_number(best_bet);
				#pragma endregion
				if (looseness == 0) goto done;
				#pragma region <Find the best active node for the desired looseness 875>
				r = link(active); actual_looseness = 0;
				do {
					if (type(r) != delta_node) {
						line_diff = line_number(r) - best_line;
						if (line_diff < actual_looseness && looseness <= line_diff ||
							line_diff > actual_looseness && looseness >= line_diff) {
							best_bet = r; actual_looseness = line_diff; fewest_demerits = total_demerits(r);
						}
						else if (line_diff == actual_looseness && total_demerits(r) < fewest_demerits) {
							best_bet = r; fewest_demerits = total_demerits(r);
						}
					}
					r = link(r);
				} while (!(r == last_active));
				best_line = line_number(best_bet);
				#pragma endregion
				if (actual_looseness == looseness || final_pass) goto done;
			}
		}
			#pragma endregion

		#pragma region <Clean up the memory by removing the break nodes 865>
		q = link(active);
		while (q != last_active) {
			cur_p = link(q);
			if (type(q) == delta_node) free_node(q, delta_node_size);
			else free_node(q, active_node_size);
			q = cur_p;
		}
		q = passive;
		while (q != null) {
			cur_p = link(q); free_node(q, passive_node_size); q = cur_p;
		}
		#pragma endregion

		if (!second_pass) {
			//stat
			if (tracing_paragraphs > 0) print_nl(TEX_STRING("@secondpass"));
			//tats
			threshold = tolerance; second_pass = true; final_pass = (emergency_stretch <= 0);
		}
		else {
			//stat
			if (tracing_paragraphs > 0) print_nl(TEX_STRING("@emergencypass"));
			//tats
			background[2] += emergency_stretch; final_pass = true;
		}
	}
done:
	//stat
	if (tracing_paragraphs > 0) {
		end_diagnostic(true); normalize_selector();
	}
	//tats
	#pragma endregion

	#pragma region <Break the paragraph at the chosen breakpoins, justify the resulting lines to the correct widths... 876>

	post_line_break(final_widow_penalty);

	#pragma endregion

	#pragma region <Clean up memory by removing the break nodes 865>
	q = link(active);
	while (q != last_active) {
		cur_p = link(q);
		if (type(q) == delta_node) free_node(q, delta_node_size);
		else free_node(q, active_node_size);
		q = cur_p;
	}
	q = passive;
	while (q != null) {
		cur_p = link(q); free_node(q, passive_node_size); q = cur_p;
	}

	#pragma endregion

	pack_begin_line = 0;

}


// 826
pointer finite_shrink(pointer p)
{
	pointer q;
	if (no_shrink_error_yet) {
		no_shrink_error_yet = false;
		print_err(TEX_STRING("Infinite glue shrinkage found in a paragraph"));
		help5(TEX_STRING("The paragraph just ended includes some glue that has"),
			TEX_STRING("infinite shrinkability, e.g., `\hskip 0pt minus 1fil'."),
			TEX_STRING("Such glue doesn't belong there---it allows a paragraph"),
			TEX_STRING("of any length to fit on one line. But it's safe to proceed,"),
			TEX_STRING("since the offensive shrinkability has been made finite."));
		error();
	}
	q = new_spec(p); shrink_order(q) = normal; delete_glue_ref(p);
	return q;
}

//877
void post_line_break(int final_widow_penalty)
{
	pointer q, r, s;
	bool disc_break;
	bool post_disc_break;
	scaled cur_width;
	scaled cur_indent;
	quarterword t;
	int pen;
	halfword cur_line;

	#pragma region <Reverse the links of the relevant passive nodes, setting cur_p to the first breakpoint 878>
	q = break_node(best_bet); cur_p = null;
	do {
		r = q; q = prev_break(q); next_break(r) = cur_p; cur_p = r;
	} while (!(q == null));
	#pragma endregion
	cur_line = prev_graf + 1;
	do {
		#pragma region <Justify the line ending at breakpoint cur_p, and append it to the current vertical list.. 880>

		#pragma region <Modify the end of the line to reflect the nature of the break and to include .. 881>
		q = cur_break(cur_p); disc_break = false; post_disc_break = false;
		if(q!=null)
			if (type(q) == glue_node) {
				delete_glue_ref(glue_ptr(q)); glue_ptr(q) = right_skip; subtype(q) = right_skip_code + 1;
				add_glue_ref(right_skip); goto done;
			}
			else {
				if(type(q) == disc_node)
					#pragma region <Change discretionary to compulsory and set disc_break=true 882>
				{
					t = replace_count(q);

					#pragma region <Destroy the t nodes following q, and make r point to the following node 883>
					if (t == 0) r = link(q);
					else {
						r = q;
						while (t > 1) {
							r = link(r); decr(t);
						}
						s = link(r); r = link(s); link(s) = null; flush_node_list(link(q)); replace_count(q) = 0;
					}
					#pragma endregion
					if (post_break(q) != null)
						#pragma region <Transplant the post-break list 884>
					{
						s = post_break(q);
						while (link(s) != null) s = link(s);
						link(s) = r; r = post_break(q); post_break(q) = null; post_disc_break = true;
					}
						#pragma endregion
					if (pre_break(q) != null)
						#pragma region <Transplant the pre-break list 885>
					{
						s = pre_break(q); link(q) = s;
						while (link(s) != null) s = link(s);
						pre_break(q) = null; q = s;
					}
						#pragma endregion
					link(q) = r; disc_break = true;
				}
					#pragma endregion
				else if (type(q) == math_node || type(q) == kern_node) width(q) = 0;
			}
		else {
			q = temp_head;
			while (link(q) != null) q = link(q);
		}

		#pragma region <Put the rightskip glue after node q 886>
		r = new_param_glue(right_skip_code); link(r) = link(q); link(q) = r; q = r;
		#pragma endregion
		done:


#pragma endregion

		#pragma region <Put the leftskip glue at the left and detach this line 887>
			r = link(q); link(q) = null; q = link(temp_head); link(temp_head) = r;
			if (left_skip != zero_glue) {
				r = new_param_glue(left_skip_code); link(r) = q; q = r;
			}
		#pragma endregion


		#pragma region <Call the packaging subroutine, setting just_box to the justified box 889>
			if (cur_line > last_special_line) {
				cur_width = second_width; cur_indent = second_indent;
			}
			else if (par_shape_ptr == null) {
				cur_width = first_width; cur_indent = first_indent;
			}
			else {
				cur_width = mem[par_shape_ptr + 2 * cur_line].sc;
				cur_indent = mem[par_shape_ptr + 2 * cur_line - 1].sc;
			}
			adjust_tail = adjust_head; just_box = hpack(q, cur_width, exactly); shift_amount(just_box) = cur_indent;
		#pragma endregion

		#pragma region <Append the new box to the current vertical list, followed by the list of special nodes .. 888>
			append_to_vlist(just_box);
			if (adjust_head != adjust_tail) {
				link(tail) = link(adjust_head); tail = adjust_tail;
			}
			adjust_tail = null;
		#pragma endregion

		#pragma region <Append a penalty node, if a nonzero penalty is appropriate 890>
			if (cur_line + 1 != best_line) {
				pen = inter_line_penalty;
				if (cur_line == prev_graf + 1) pen += club_penalty;
				if (cur_line + 2 == best_line) pen += final_widow_penalty;
				if (disc_break) pen += broken_penalty;
				if (pen != 0) {
					r = new_penalty(pen); link(tail) = r; tail = r;
				}
			}
		#pragma endregion


		#pragma endregion
		incr(cur_line); cur_p = next_break(cur_p);
		if(cur_p!=null)
			if (!post_disc_break)
				#pragma region <Prune unwanted nodes at the beginning of the next line 879>
			{
				r = temp_head;
				while (1) {
					q = link(r);
					if (q == cur_break(cur_p)) goto done1;
					if (is_char_node(q)) goto done1;
					if (non_discardable(q)) goto done1;
					if (type(q) == kern_node)
						if (subtype(q) != _explicit) goto done1;
					r = q;
				}
			done1:
				if (r != temp_head) {
					link(r) = null; flush_node_list(link(temp_head)); link(temp_head) = q;
				}
			}
				#pragma endregion
	} while (!(cur_p == null));
	if (cur_line != best_line || link(temp_head) != null)
		confusion(TEX_STRING("line breaking"));
	prev_graf = best_line - 1;
}

// 906
small_number reconstitute(small_number j, small_number n, halfword bchar, halfword hchar)
{
	pointer p;
	pointer t;
	four_quarters q;
	halfword cur_rh;
	halfword test_char;
	scaled w;
	font_index k;

	hyphen_passed = 0; t = hold_head; w = 0; link(hold_head) = null;

	#pragma region <Set up data structures with the cursor following position j 908>
	cur_l = qi(hu[j]); cur_q = t;
	if (j == 0) {
		ligature_present = init_lig; p = init_list;
		if (ligature_present) lft_hit = init_lft;
		while (p > null) {
			append_charnode_to_t(character(p)); p = link(p);
		}
	}
	else if (cur_l < non_char) append_charnode_to_t(quarterword(cur_l));
	lig_stack = null; set_cur_r;
#pragma endregion

mycontinue:
	#pragma region <If theres a ligature or constant.. 909>
	if (cur_l == non_char) {
		k = bchar_label[hf];
		if (k == non_address) goto done; else q = font_info[k].union_t.qqqq;
	}
	else {
		q = char_info(hf, cur_l);
		if (char_tag(q) != lig_tag) goto done;
		k = lig_kern_start(hf, q); q = font_info[k].union_t.qqqq;
		if (skip_byte(q) > stop_flag) {
			k = lig_kern_restart(hf, q); q = font_info[k].union_t.qqqq;
		}
	}
	if (cur_rh < non_char) test_char = cur_rh; else test_char = cur_r;
	while (1)
	{
		if(next_char(q) == test_char)
			if(skip_byte(q)<= stop_flag)
				if (cur_rh < non_char) {
					hyphen_passed = j; hchar = non_char; cur_rh = non_char; goto mycontinue;
				}
				else {
					if(hchar<non_char)
						if (myodd(hyf[j])) {
							hyphen_passed = j; hchar = non_char;
						}
					if (op_byte(q) < kern_flag)
						#pragma region <Carry out a ligature replacement, updating the cursor structure ... 911
					{
						if (cur_l == non_char) lft_hit = true;
						if (j == n)
							if (lig_stack == null) rt_hit = true;
						check_interrupt;
						switch (op_byte(q)) {
						case qi(1):
						case qi(5):
							cur_l = rem_byte(q);
							ligature_present = true;
							break;
						case qi(2):
						case qi(6):
							cur_r = rem_byte(q);

							// overflow check
							if (cur_r > 255) {
								printf("Overflow assignment 911\n");
								exit(1);
							}
							if (lig_stack > null) character(lig_stack) = (quarterword)cur_r;
							else {
								lig_stack = new_lig_item((quarterword)cur_r);
								if (j == n) bchar = non_char;
								else {
									p = get_avail(); lig_ptr(lig_stack) = p; 

									if (qi(hu[j + 1]) > 255) {
										printf("overflow 911\n");
										exit(1);
									}
									character(p) = (quarterword)qi(hu[j + 1]); 
									font(p) = hf;
								}
							}
							break;
						case qi(3):
							cur_r = rem_byte(q);
							// overflow check
							if (cur_r > 255) {
								printf("Overflow assignment 911\n");
								exit(1);
							}
							p = lig_stack; lig_stack = new_lig_item((quarterword)cur_r); link(lig_stack) = p;
							break;
						case qi(7):
						case qi(11):
							wrap_lig(false);
							cur_q = t; cur_l = rem_byte(q); ligature_present = true;
							break;
						default:
							cur_l = rem_byte(q); ligature_present = true;
							if (lig_stack > null) pop_lig_stack;
							else if (j == n) goto done;
							else {
								// overflow check
								if (cur_r > 255) {
									printf("Overflow assignment open_or_close_in\n");
									exit(1);
								}
								append_charnode_to_t(quarterword(cur_r)); incr(j); set_cur_r;
							}
							break;
						}
						if (op_byte(q) > qi(4))
							if (op_byte(q) != qi(7)) goto done;
						goto mycontinue;
						
					}
						#pragma endregion
					w = char_kern(hf, q); goto done;
				}
				if (skip_byte(q) >= stop_flag)
					if (cur_rh == non_char) goto done;
					else {
						cur_rh = non_char; goto mycontinue;
					}
					k = k + qo(skip_byte(q)) + 1; q = font_info[k].union_t.qqqq;
	}
done:

	#pragma endregion

	#pragma region <Append a ligature and/or kern to the translation; ... 910>
	wrap_lig(rt_hit);
	if (w != 0) {
		link(t) = new_kern(w); t = link(t); w = 0;
	}
	if (lig_stack > null) {
		cur_q = t; cur_l = character(lig_stack); ligature_present = true; pop_lig_stack;
		goto mycontinue;
	}
	#pragma endregion

	return j;
}

// 895
void hyphenate()
{
	#pragma region <Local variables for hyphenation 901>
	unsigned char i, j, l; //0..65
	pointer q, r, s;
	halfword bchar;

	//912
	pointer major_tail, minor_tail;
	ASCII_code c;
	unsigned char c_loc; // 0..63
	int r_count;
	pointer hyf_node;

	// 922
	trie_pointer z;
	int v;

	//929
	hyph_pointer h;
	str_number k;
	pool_pointer u;


	#pragma endregion

	#pragma region <Find hyphen locations for the word in hc, or return 923>
	for (j = 0; j <= hn; j++) hyf[j] = 0;
	#pragma region <Look for the word hc[1..hn] in the exceptoin table and goto found ...930>
	h = hc[1]; incr(hn); hc[hn] = cur_lang;
	for (j = 2; j <= hn; j++) h = (h + h + hc[j]) % hyph_size;
	while (1) {
		#pragma region <If the string hyph_word[h] is less than ... goto found 931>
		k = hyph_word[h];
		if (k == 0) goto not_found;
		if (length(k) < hn) goto not_found;
		if (length(k) == hn) {
			j = 1; u = str_start[k];
			do {
				if (so(str_pool[u]) < hc[j]) goto not_found;
				if (so(str_pool[u]) > hc[j]) goto done;
				incr(j); incr(u);
			} while (!(j > hn));
			#pragma region <Insert hyphens as specified in hyph_list[h] 932>
			s = hyph_list[h];
			while (s != null) {
				hyf[info(s)] = 1; s = link(s);
			}
#pragma endregion
			decr(hn); goto found;

		}
	done:

#pragma endregion
		if (h > 0) decr(h); else h = hyph_size;
	}
not_found:
	decr(hn);
#pragma endregion
	if (trie_char(cur_lang + 1) != qi(cur_lang)) goto myexit;
	hc[0] = 0; hc[hn + 1] = 0; hc[hn + 2] = 256;
	for (j = 0; j <= hn - r_hyf + 1; j++) {
		z = trie_link(cur_lang + 1) + hc[j]; l = j;
		while (hc[l] == qo(trie_char(z))) {
			if (trie_op(z) != min_quarterword)
			#pragma region <Store maximum values in teh hyf table 924>
			{
				v = trie_op(z);
				do {
					v = v + op_start[cur_lang]; i = l - hyf_distance[v];
					if (hyf_num[v] > hyf[i]) hyf[i] = hyf_num[v];
					v = hyf_next[v];
				} while (!(v == min_quarterword));
			}
			#pragma endregion
			incr(l); z = trie_link(z) + hc[l];
		}
	}
found:
	for (j = 0; j <= l_hyf - 1; j++) hyf[j] = 0;
	for (j = 0; j <= r_hyf - 1; j++) hyf[hn - j] = 0;

#pragma endregion


	#pragma region <If no hyphens were found, return 902>
	for (j = l_hyf; j <= hn - r_hyf; j++)
		if (myodd(hyf[j])) goto found1;
	goto myexit;
found1:

#pragma endregion

	#pragma region <Replace nodes ha..hb by a sequence of nodes that includes the discretionary hyphens 903>
	q = link(hb); link(hb) = null; r = link(ha); link(ha) = null; bchar = hyf_bchar;
	if (is_char_node(ha))
		if (font(ha) != hf) goto found2;
		else {
			init_list = ha; init_lig = false; hu[0] = qo(character(ha));
		}
	else if (type(ha) == ligature_node)
		if (font(lig_char(ha)) != hf) goto found2;
		else {
			init_list = lig_ptr(ha); init_lig = true; init_lft = (subtype(ha) > 1);
			hu[0] = qo(character(lig_char(ha)));
			if(init_list==null)
				if (init_lft) {
					hu[0] = 256; init_lig = false;
				}
			free_node(ha, small_node_size);
		}
	else {
		if (!is_char_node(r))
			if (type(r) == ligature_node)
				if (subtype(r) > 1) goto found2;
		j = 1; s = ha; init_list = null; goto common_ending;
	}
	s = cur_p;
	while (link(s) != ha) s = link(s);
	j = 0; goto common_ending;
found2:
	s = ha; j = 0; hu[0] = 256; init_lig = false; init_list = null;
common_ending:
	flush_node_list(r);
#pragma region <Reconstitute nodes for the hyphenated word, inserting discretionary hyphens 913>
	do {
		l = j; j = reconstitute(j, hn, bchar, qi(hyf_char)) + 1;
		if (hyphen_passed == 0) {
			link(s) = link(hold_head);
			while (link(s) > null) s = link(s);
			if (myodd(hyf[j - 1])) {
				l = j; hyphen_passed = j - 1; link(hold_head) = null;
			}
		}
		if (hyphen_passed > 0)
#pragma region < Create and append a discretionary node as an alternative... 914>

			do {
				r = get_node(small_node_size); link(r) = link(hold_head); type(r) = disc_node; major_tail = r;
				r_count = 0;
				while (link(major_tail) > null) advance_major_tail;
				i = hyphen_passed; hyf[i] = 0;
#pragma region <Put the characters hu[l..i] and a hyphen into pre_break(r) 915>
				minor_tail = null; pre_break(r) = null; hyf_node = new_character(hf, hyf_char);
				if (hyf_node != null) {
					incr(i); c = hu[i]; hu[i] = hyf_char; free_avail(hyf_node);
				}
				while (l <= i) {
					l = reconstitute(l, i, font_bchar[hf], non_char) + 1;
					if (link(hold_head) > null) {
						if (minor_tail == null) pre_break(r) = link(hold_head);
						else link(minor_tail) = link(hold_head);
						minor_tail = link(hold_head);
						while (link(minor_tail) > null) minor_tail = link(minor_tail);
					}
				}
				if (hyf_node != null) {
					hu[i] = c;
					l = i; decr(i);
				}
#pragma endregion
#pragma region <Put the characters hu[i+1..] into post_break(r)... 916>
				minor_tail = null; post_break(r) = null; c_loc = 0;
				if (bchar_label[hf] != non_address) {
					decr(l); c = hu[l]; c_loc = l; hu[l] = 256;
				}
				while (l < j) {
					do {
						l = reconstitute(l, hn, bchar, non_char) + 1;
						if (c_loc > 0) {
							hu[c_loc] = c; c_loc = 0;
						}
						if (link(hold_head) > null) {
							if (minor_tail == null) post_break(r) = link(hold_head);
							else link(minor_tail) = link(hold_head);
							minor_tail = link(hold_head);
							while (link(minor_tail) > null) minor_tail = link(minor_tail);
						}
							
					} while (!(l >= j));
					while (l > j)
#pragma region <Append characters of hu[j..] to major_tail advancing j 917>
					{
						j = reconstitute(j, hn, bchar, non_char) + 1;
						link(major_tail) = link(hold_head);
						while (link(major_tail) > null) advance_major_tail;
					}
#pragma endregion
				}
#pragma endregion
#pragma region <Move pointer s to the end of teh current list, and set replace_count(r) approp... 918>
				if (r_count > 127) {
					link(s) = link(r); link(r) = null; flush_node_list(r);
				}
				else {
					link(s) = r; replace_count(r) = r_count;
				}
				s = major_tail;
#pragma endregion
				hyphen_passed = j - 1; link(hold_head) = null;
			} while (!(!myodd(hyf[j - 1])));

#pragma endregion
	} while (!(j > hn));
	link(s) = q;
#pragma endregion
	flush_list(init_list);
#pragma endregion
	myexit:
		  ;
}

// 1096
void end_graf()
{
	if (mode == hmode)
	{
		if (head == tail) pop_nest();
		else line_break(widow_penalty);
		normal_paragraph(); error_count = 0;
	}
}

// 1099
void begin_insert_or_adjust()
{
	if (cur_cmd == vadjust) cur_val = 255;
	else {
		scan_eight_bit_int();
		if (cur_val == 255) {
			print_err(TEX_STRING("You can't ")); 
			print_esc(TEX_STRING("insert")); print_int(255);
			help1(TEX_STRING("I'm changing to \insert0; box 255 is special."));
			error();
			cur_val = 0;
		}
	}
	saved(0) = cur_val; incr(save_ptr); new_save_level(insert_group); scan_left_brace(); normal_paragraph();
	push_nest(); mode = (mode_type)-vmode; prev_depth = ignore_depth;
}

//1101
void make_mark()
{
	pointer p;
	p = scan_toks(false, true); p = get_node(small_node_size); type(p) = mark_node;
	subtype(p) = 0;
	mark_ptr(p) = def_ref; link(tail) = p; tail = p;
}

//1103
void append_penalty()
{
	scan_int(); tail_append(new_penalty(cur_val));
	if (mode == vmode) build_page();
}

//1105
void delete_last()
{
	pointer p, q;
	quarterword m;
	if (mode == vmode && tail == head) 
		#pragma region <Apologize for inability to do the operation now, unless unskip follows non-glue 1106>
	{

		if (cur_chr != glue_node || last_glue != max_halfword) {
			you_cant();
			help2(TEX_STRING("Sorry...I usually can't take things from the current page."),
				TEX_STRING("Try `I\vskip-\lastskip' instead."));
			if (cur_chr == kern_node)  help_line[0] = TEX_STRING("Try `I\kern-\lastkern' instead.");
			else if (cur_chr != glue_node)
				help_line[0] = TEX_STRING("Perhaps you can make the output routine do it.");
			error();
		}
	}
#pragma endregion
	else {
		if(!is_char_node(tail))
			if (type(tail) == cur_chr) {
				q = head;
				do {
					p = q;
					if(!is_char_node(q))
						if (type(q) == disc_node) {
							for (m = 1; m <= replace_count(q); m++) p = link(p);
							if (p == tail)
								return;
						}
					q = link(p);
				} while (!(q == tail));
				link(p) = null; flush_node_list(tail); tail = p;
			}
	}
}

//1110
void unpackage()
{
	pointer p;
	int c; // box_code..copy_code, 0..1

	c = cur_chr; scan_eight_bit_int(); p = box(cur_val);
	if (p == null)
		return;
	if (abs(mode) == mmode || abs(mode) == vmode && type(p) != vlist_node ||
		abs(mode) == hmode && type(p) != hlist_node) {
		print_err(TEX_STRING("Incompatible list can't be unboxed"));
		help3(TEX_STRING("Sorry, Pandora. (You sneaky devil.)"),
			TEX_STRING("I refuse to unbox an \hbox in vertical mode or vice versa."),
			TEX_STRING("And I can't open any boxes in math mode."));
		error();
		return;
	}
	if (c == copy_code) link(tail) = copy_node_list(list_ptr(p));
	else {
		link(tail) = list_ptr(p); box(cur_val) = null; free_node(p, box_node_size);
	}
	while (link(tail) != null) tail = link(tail);
}

// 1043
void app_space()
{
	pointer q;
	if (space_factor >= 2000 && xspace_skip != zero_glue)
		q = new_param_glue(xspace_skip_code);
	else {
		if (space_skip != zero_glue)
			main_p = space_skip;
		else
			#pragma region <Find the glue specification, main_p, for text spaces in teh current font 1042>
		{
			main_p = font_glue[cur_font];
			if (main_p == null) {
				main_p = new_spec(zero_glue); main_k = param_base[cur_font] + space_code;
				width(main_p) = font_info[main_k].sc;
				stretch(main_p) = font_info[main_k + 1].sc;
				shrink(main_p) = font_info[main_k + 2].sc;
				font_glue[cur_font] = main_p;
			}
		}
#pragma endregion
		main_p = new_spec(main_p);
		#pragma region <Modify the glue specification in main_p according to the space factor 1044>
		if (space_factor >= 2000)
			width(main_p) = width(main_p) + extra_space(cur_font);
		stretch(main_p) = xn_over_d(stretch(main_p), space_factor, 1000);
		shrink(main_p) = xn_over_d(shrink(main_p), 1000, space_factor);
#pragma endregion
		q = new_glue(main_p); glue_ref_count(main_p) = null;
	}
	link(tail) = q; tail = q;
}

// 1243
void alter_aux()
{
	halfword c;
	if (cur_chr != abs(mode))
		report_illegal_case();
	else {
		c = cur_chr; scan_optional_equals();
		if (c == vmode) {
			scan_normal_dimen;
			prev_depth = cur_val;
		}
		else {
			scan_int();
			if (cur_val <= 0 || cur_val > 32767) {
				print_err(TEX_STRING("Bad space factor"));
				help1(TEX_STRING("I allow only values in the range 1..32767 here."));
				int_error(cur_val);
			}
			else
				space_factor = cur_val;
		}
	}
}
// 1244
void alter_prev_graf()
{
	unsigned int p;
	nest[nest_ptr] = cur_list; p = nest_ptr;
	while (abs(nest[p].mode_field) != vmode)
		decr(p);
	scan_optional_equals();
	scan_int();
	if (cur_val < 0) {
		print_err(TEX_STRING("Bad "));
		print_esc(TEX_STRING("prevgraf"));
		help1(TEX_STRING("I allow only nonnegative values here."));
		int_error(cur_val);
	}
	else {
		nest[p].pg_field = cur_val;
		cur_list = nest[nest_ptr];
	}
}

// 1245
void alter_page_so_far()
{
	int c; // 0..7
	c = cur_chr;
	scan_optional_equals();
	scan_normal_dimen;
	page_so_far[c] = cur_val;
}

//1246
void alter_integer()
{
	int c; // 0..1
	c = cur_chr;
	scan_optional_equals();
	scan_int();
	if (c == 0)
		dead_cycles = cur_val;
	else
		insert_penalties = cur_val;
}

// 1247
void alter_box_dimen()
{
	small_number c;
	eight_bits b;
	c = cur_chr; scan_eight_bit_int(); b = cur_val; scan_optional_equals(); scan_normal_dimen;
	if (box(b) != null) mem[box(b) + c].sc = cur_val;
}

// 1336
//init
void init_prim()
{
	no_new_control_sequence = false;

	#pragma region <Put each of tex primitives into the hash table 226>
	primitive(TEX_STRING("lineskip"), assign_glue, glue_base + line_skip_code);
	primitive(TEX_STRING("baselineskip"), assign_glue, glue_base + baseline_skip_code);
	primitive(TEX_STRING("parskip"), assign_glue, glue_base + par_skip_code);
	primitive(TEX_STRING("abovedisplayskip"), assign_glue, glue_base + above_display_skip_code);
	primitive(TEX_STRING("belowdisplayskip"), assign_glue, glue_base + below_display_skip_code);
	primitive(TEX_STRING("abovedisplayshortskip"), assign_glue, glue_base + above_display_short_skip_code);
	primitive(TEX_STRING("belowdisplayshortskip"), assign_glue, glue_base + below_display_short_skip_code);
	primitive(TEX_STRING("leftskip"), assign_glue, glue_base + left_skip_code);
	primitive(TEX_STRING("rightskip"), assign_glue, glue_base + right_skip_code);
	primitive(TEX_STRING("topskip"), assign_glue, glue_base + top_skip_code);
	primitive(TEX_STRING("splittopskip"), assign_glue, glue_base + split_top_skip_code);
	primitive(TEX_STRING("tabskip"), assign_glue, glue_base + tab_skip_code);
	primitive(TEX_STRING("spaceskip"), assign_glue, glue_base + space_skip_code);
	primitive(TEX_STRING("xspaceskip"), assign_glue, glue_base + xspace_skip_code);
	primitive(TEX_STRING("parfillskip"), assign_glue, glue_base + par_fill_skip_code);
	primitive(TEX_STRING("thinmuskip"), assign_mu_glue, glue_base + thin_mu_skip_code);
	primitive(TEX_STRING("medmuskip"), assign_mu_glue, glue_base + med_mu_skip_code);
	primitive(TEX_STRING("thickmuskip"), assign_mu_glue, glue_base + thick_mu_skip_code);

	// 230
	primitive(TEX_STRING("output"), assign_toks, output_routine_loc);
	primitive(TEX_STRING("everypar"), assign_toks, every_par_loc);
	primitive(TEX_STRING("everymath"), assign_toks, every_math_loc);
	primitive(TEX_STRING("everydisplay"), assign_toks, every_display_loc);
	primitive(TEX_STRING("everyhbox"), assign_toks, every_hbox_loc);
	primitive(TEX_STRING("everyvbox"), assign_toks, every_vbox_loc);
	primitive(TEX_STRING("everyjob"), assign_toks, every_job_loc);
	primitive(TEX_STRING("everycr"), assign_toks, every_cr_loc);
	primitive(TEX_STRING("errhelp"), assign_toks, err_help_loc);

	//238
	primitive(TEX_STRING("pretolerance"), assign_int, int_base + pretolerance_code);
	primitive(TEX_STRING("tolerance"), assign_int, int_base + tolerance_code);
	primitive(TEX_STRING("linepenalty"), assign_int, int_base + line_penalty_code);
	primitive(TEX_STRING("hyphenpenalty"), assign_int, int_base + hyphen_penalty_code);
	primitive(TEX_STRING("exhyphenpenalty"), assign_int, int_base + ex_hyphen_penalty_code);
	primitive(TEX_STRING("clubpenalty"), assign_int, int_base + club_penalty_code);
	primitive(TEX_STRING("widowpenalty"), assign_int, int_base + widow_penalty_code);
	primitive(TEX_STRING("displaywidowpenalty"), assign_int, int_base + display_widow_penalty_code);
	primitive(TEX_STRING("brokenpenalty"), assign_int, int_base + broken_penalty_code);
	primitive(TEX_STRING("binoppenalty"), assign_int, int_base + bin_op_penalty_code);
	primitive(TEX_STRING("relpenalty"), assign_int, int_base + rel_penalty_code);
	primitive(TEX_STRING("predisplaypenalty"), assign_int, int_base + pre_display_penalty_code);
	primitive(TEX_STRING("postdisplaypenalty"), assign_int, int_base + post_display_penalty_code);
	primitive(TEX_STRING("interlinepenalty"), assign_int, int_base + inter_line_penalty_code);
	primitive(TEX_STRING("doublehyphendemerits"), assign_int, int_base + double_hyphen_demerits_code);
	primitive(TEX_STRING("finalhyphendemerits"), assign_int, int_base + final_hyphen_demerits_code);
	primitive(TEX_STRING("adjdemerits"), assign_int, int_base + adj_demerits_code);
	primitive(TEX_STRING("mag"), assign_int, int_base + mag_code);
	primitive(TEX_STRING("delimiterfactor"), assign_int, int_base + delimiter_factor_code);
	primitive(TEX_STRING("looseness"), assign_int, int_base + looseness_code);
	primitive(TEX_STRING("time"), assign_int, int_base + time_code);
	primitive(TEX_STRING("day"), assign_int, int_base + day_code);
	primitive(TEX_STRING("month"), assign_int, int_base + month_code);
	primitive(TEX_STRING("year"), assign_int, int_base + year_code);
	primitive(TEX_STRING("showboxbreadth"), assign_int, int_base + show_box_breadth_code);
	primitive(TEX_STRING("showboxdepth"), assign_int, int_base + show_box_depth_code);
	primitive(TEX_STRING("hbadness"), assign_int, int_base + hbadness_code);
	primitive(TEX_STRING("vbadness"), assign_int, int_base + vbadness_code);
	primitive(TEX_STRING("pausing"), assign_int, int_base + pausing_code);
	primitive(TEX_STRING("tracingonline"), assign_int, int_base + tracing_online_code);
	primitive(TEX_STRING("tracingmacros"), assign_int, int_base + tracing_macros_code);
	primitive(TEX_STRING("tracingstats"), assign_int, int_base + tracing_stats_code);
	primitive(TEX_STRING("tracingparagraphs"), assign_int, int_base + tracing_paragraphs_code);
	primitive(TEX_STRING("tracingpages"), assign_int, int_base + tracing_pages_code);
	primitive(TEX_STRING("tracingoutput"), assign_int, int_base + tracing_output_code);
	primitive(TEX_STRING("tracinglostchars"), assign_int, int_base + tracing_lost_chars_code);
	primitive(TEX_STRING("tracingcommands"), assign_int, int_base + tracing_commands_code);
	primitive(TEX_STRING("tracingrestores"), assign_int, int_base + tracing_restores_code);
	primitive(TEX_STRING("uchyph"), assign_int, int_base + uc_hyph_code);
	primitive(TEX_STRING("outputpenalty"), assign_int, int_base + output_penalty_code);
	primitive(TEX_STRING("maxdeadcycles"), assign_int, int_base + max_dead_cycles_code);
	primitive(TEX_STRING("hangafter"), assign_int, int_base + hang_after_code);
	primitive(TEX_STRING("floatingpenalty"), assign_int, int_base + floating_penalty_code);
	primitive(TEX_STRING("globaldefs"), assign_int, int_base + global_defs_code);
	primitive(TEX_STRING("fam"), assign_int, int_base + cur_fam_code);
	primitive(TEX_STRING("escapechar"), assign_int, int_base + escape_char_code);
	primitive(TEX_STRING("defaulthyphenchar"), assign_int, int_base + default_hyphen_char_code);
	primitive(TEX_STRING("defaultskewchar"), assign_int, int_base + default_skew_char_code);
	primitive(TEX_STRING("endlinechar"), assign_int, int_base + end_line_char_code);
	primitive(TEX_STRING("newlinechar"), assign_int, int_base + new_line_char_code);
	primitive(TEX_STRING("language"), assign_int, int_base + language_code);
	primitive(TEX_STRING("lefthyphenmin"), assign_int, int_base + left_hyphen_min_code);
	primitive(TEX_STRING("righthyphenmin"), assign_int, int_base + right_hyphen_min_code);
	primitive(TEX_STRING("holdinginserts"), assign_int, int_base + holding_inserts_code);
	primitive(TEX_STRING("errorcontextlines"), assign_int, int_base + error_context_lines_code);

	//248
	primitive(TEX_STRING("parindent"), assign_dimen, dimen_base + par_indent_code);
	primitive(TEX_STRING("mathsurround"), assign_dimen, dimen_base + math_surround_code);
	primitive(TEX_STRING("lineskiplimit"), assign_dimen, dimen_base + line_skip_limit_code);
	primitive(TEX_STRING("hsize"), assign_dimen, dimen_base + hsize_code);
	primitive(TEX_STRING("vsize"), assign_dimen, dimen_base + vsize_code);
	primitive(TEX_STRING("maxdepth"), assign_dimen, dimen_base + max_depth_code);
	primitive(TEX_STRING("splitmaxdepth"), assign_dimen, dimen_base + split_max_depth_code);
	primitive(TEX_STRING("boxmaxdepth"), assign_dimen, dimen_base + box_max_depth_code);
	primitive(TEX_STRING("hfuzz"), assign_dimen, dimen_base + hfuzz_code);
	primitive(TEX_STRING("vfuzz"), assign_dimen, dimen_base + vfuzz_code);
	primitive(TEX_STRING("delimitershortfall"), assign_dimen, dimen_base + delimiter_shortfall_code);
	primitive(TEX_STRING("nulldelimiterspace"), assign_dimen, dimen_base + null_delimiter_space_code);
	primitive(TEX_STRING("scriptspace"), assign_dimen, dimen_base + script_space_code);
	primitive(TEX_STRING("predisplaysize"), assign_dimen, dimen_base + pre_display_size_code);
	primitive(TEX_STRING("displaywidth"), assign_dimen, dimen_base + display_width_code);
	primitive(TEX_STRING("displayindent"), assign_dimen, dimen_base + display_indent_code);
	primitive(TEX_STRING("overfullrule"), assign_dimen, dimen_base + overfull_rule_code);
	primitive(TEX_STRING("hangindent"), assign_dimen, dimen_base + hang_indent_code);
	primitive(TEX_STRING("hoffset"), assign_dimen, dimen_base + h_offset_code);
	primitive(TEX_STRING("voffset"), assign_dimen, dimen_base + v_offset_code);
	primitive(TEX_STRING("emergencystretch"), assign_dimen, dimen_base + emergency_stretch_code);

	//265
	primitive(TEX_STRING(" "), ex_space, 0);
	primitive(TEX_STRING("/"), ital_corr, 0);
	primitive(TEX_STRING("accent"), accent, 0);
	primitive(TEX_STRING("advance"), advance, 0);
	primitive(TEX_STRING("afterassignment"), after_assignment, 0);
	primitive(TEX_STRING("aftergroup"), after_group, 0);
	primitive(TEX_STRING("begingroup"), begin_group, 0);
	primitive(TEX_STRING("char"), char_num, 0);
	primitive(TEX_STRING("csname"), cs_name, 0);
	primitive(TEX_STRING("delimiter"), delim_num, 0);
	primitive(TEX_STRING("divide"), divide, 0);
	primitive(TEX_STRING("endcsname"), end_cs_name, 0);
	primitive(TEX_STRING("endgroup"), end_group, 0);
	text(frozen_end_group) = TEX_STRING("endgroup");
	eqtb[frozen_end_group] = eqtb[cur_val];
	primitive(TEX_STRING("expandafter"), expand_after, 0);
	primitive(TEX_STRING("font"), def_font, 0);
	primitive(TEX_STRING("fontdimen"), assign_font_dimen, 0);
	primitive(TEX_STRING("halign"), halign, 0);
	primitive(TEX_STRING("hrule"), hrule, 0);
	primitive(TEX_STRING("ignorespaces"), ignore_spaces, 0);
	primitive(TEX_STRING("insert"), insert, 0);
	primitive(TEX_STRING("mark"), mark, 0);
	primitive(TEX_STRING("mathaccent"), math_accent, 0);
	primitive(TEX_STRING("mathchar"), math_char_num, 0);
	primitive(TEX_STRING("mathchoice"), math_choice, 0);
	primitive(TEX_STRING("multiply"), multiply, 0);
	primitive(TEX_STRING("noalign"), no_align, 0);
	primitive(TEX_STRING("noboundary"), no_boundary, 0);
	primitive(TEX_STRING("noexpand"), no_expand, 0);
	primitive(TEX_STRING("nonscript"), non_script, 0);
	primitive(TEX_STRING("omit"), omit, 0);
	primitive(TEX_STRING("parshape"), set_shape, 0);
	primitive(TEX_STRING("penalty"), break_penalty, 0);
	primitive(TEX_STRING("prevgraf"), set_prev_graf, 0);
	primitive(TEX_STRING("radical"), radical, 0);
	primitive(TEX_STRING("read"), read_to_cs, 0);
	primitive(TEX_STRING("relax"), relax, 256);
	text(frozen_relax)  = TEX_STRING("relax"); eqtb[frozen_relax] = eqtb[cur_val];
	primitive(TEX_STRING("setbox"), set_box, 0);
	primitive(TEX_STRING("the"), the, 0);
	primitive(TEX_STRING("toks"), toks_register, 0);
	primitive(TEX_STRING("vadjust"), vadjust, 0);
	primitive(TEX_STRING("valign"), valign, 0);
	primitive(TEX_STRING("vcenter"), vcenter, 0);
	primitive(TEX_STRING("vrule"), vrule, 0);

	// 334
	primitive(TEX_STRING("par"), par_end, 256);
	par_loc = cur_val;
	par_token = cs_token_flag + par_loc;

	// 376
	primitive(TEX_STRING("input"), input, 0);
	primitive(TEX_STRING("endinput"), input, 1);

	// 383
	primitive(TEX_STRING("topmark"), top_bot_mark, top_mark_code);
	primitive(TEX_STRING("firstmark"), top_bot_mark, first_mark_code);
	primitive(TEX_STRING("botmark"), top_bot_mark, bot_mark_code);
	primitive(TEX_STRING("splitfirstmark"), top_bot_mark, split_first_mark_code);
	primitive(TEX_STRING("splitbotmark"), top_bot_mark, split_bot_mark_code);

	// 411
	primitive(TEX_STRING("count"), _register, int_val);
	primitive(TEX_STRING("dimen"), _register, dimen_val);
	primitive(TEX_STRING("skip"), _register, glue_val);
	primitive(TEX_STRING("muskip"), _register, mu_val);

	// 416
	primitive(TEX_STRING("spacefactor"), set_aux, hmode);
	primitive(TEX_STRING("prevdepth"), set_aux, vmode);
	primitive(TEX_STRING("deadcycles"), set_page_int, 0);
	primitive(TEX_STRING("insertpenalties"), set_page_int, 1);
	primitive(TEX_STRING("wd"), set_box_dimen, width_offset);
	primitive(TEX_STRING("ht"), set_box_dimen, height_offset);
	primitive(TEX_STRING("dp"), set_box_dimen, depth_offset);
	primitive(TEX_STRING("lastpenalty"), last_item, int_val);
	primitive(TEX_STRING("lastkern"), last_item, dimen_val);
	primitive(TEX_STRING("lastskip"), last_item, glue_val);
	primitive(TEX_STRING("inputlineno"), last_item, input_line_no_code);
	primitive(TEX_STRING("badness"), last_item, badness_code);

	// 468
	primitive(TEX_STRING("number"), convert, number_code);
	primitive(TEX_STRING("romannumeral"), convert, roman_numeral_code);
	primitive(TEX_STRING("string"), convert, string_code);
	primitive(TEX_STRING("meaning"), convert, meaning_code);
	primitive(TEX_STRING("fontname"), convert, font_name_code);
	primitive(TEX_STRING("jobname"), convert, job_name_code);

	// 487
	primitive(TEX_STRING("if"), if_test, if_char_code);
	primitive(TEX_STRING("ifcat"), if_test, if_cat_code);
	primitive(TEX_STRING("ifnum"), if_test, if_int_code);
	primitive(TEX_STRING("ifdim"), if_test, if_dim_code);
	primitive(TEX_STRING("ifodd"), if_test, if_odd_code);
	primitive(TEX_STRING("ifvmode"), if_test, if_vmode_code);
	primitive(TEX_STRING("ifhmode"), if_test, if_hmode_code);
	primitive(TEX_STRING("ifmmode"), if_test, if_mmode_code);
	primitive(TEX_STRING("ifinner"), if_test, if_inner_code);
	primitive(TEX_STRING("ifvoid"), if_test, if_void_code);
	primitive(TEX_STRING("ifhbox"), if_test, if_hbox_code);
	primitive(TEX_STRING("ifvbox"), if_test, if_vbox_code);
	primitive(TEX_STRING("ifx"), if_test, ifx_code);
	primitive(TEX_STRING("ifeof"), if_test, if_eof_code);
	primitive(TEX_STRING("iftrue"), if_test, if_true_code);
	primitive(TEX_STRING("iffalse"), if_test, if_false_code);
	primitive(TEX_STRING("ifcase"), if_test, if_case_code);

	// 491
	primitive(TEX_STRING("fi"), fi_or_else, fi_code);
	text(frozen_fi) = TEX_STRING("fi");
	eqtb[frozen_fi] = eqtb[cur_val];
	primitive(TEX_STRING("or"), fi_or_else, or_code);
	primitive(TEX_STRING("else"), fi_or_else, else_code);

	// 553
	primitive(TEX_STRING("nullfont"), set_font, null_font);
	text(frozen_null_font) = TEX_STRING("nullfont");
	eqtb[frozen_null_font] = eqtb[cur_val];

	// 780
	primitive(TEX_STRING("span"), tab_mark, span_code);
	primitive(TEX_STRING("cr"), car_ret, cr_code);
	text(frozen_cr) = TEX_STRING("cr");
	eqtb[frozen_cr] = eqtb[cur_val];
	primitive(TEX_STRING("crcr"), car_ret, cr_cr_code);
	text(frozen_end_template) = TEX_STRING("endtemplate");
	text(frozen_endv) = TEX_STRING("endtemplate");
	eq_type(frozen_endv) = endv;
	equiv(frozen_endv) = null_list;
	eq_level(frozen_endv) = level_one;
	eqtb[frozen_end_template] = eqtb[frozen_endv];
	eq_type(frozen_end_template) = end_template;

	// 983
	primitive(TEX_STRING("pagegoal"), set_page_dimen, 0);
	primitive(TEX_STRING("pagetotal"), set_page_dimen, 1);
	primitive(TEX_STRING("pagestretch"), set_page_dimen, 2);
	primitive(TEX_STRING("pagefilstretch"), set_page_dimen, 3);
	primitive(TEX_STRING("pagefillstretch"), set_page_dimen, 4);
	primitive(TEX_STRING("pagefilllstretch"), set_page_dimen, 5);
	primitive(TEX_STRING("pageshrink"), set_page_dimen, 6);
	primitive(TEX_STRING("pagedepth"), set_page_dimen, 7);

	// 1052
	primitive(TEX_STRING("end"), stop, 0);
	primitive(TEX_STRING("dump"), stop, 1);

	// 1058
	primitive(TEX_STRING("hskip"), hskip, skip_code);
	primitive(TEX_STRING("hfil"), hskip, fil_code);
	primitive(TEX_STRING("hfill"), hskip, fill_code);
	primitive(TEX_STRING("hss"), hskip, ss_code);
	primitive(TEX_STRING("hfilneg"), hskip, fil_neg_code);
	primitive(TEX_STRING("vskip"), vskip, skip_code);
	primitive(TEX_STRING("vfil"), vskip, fil_code);
	primitive(TEX_STRING("vfill"), vskip, fill_code);
	primitive(TEX_STRING("vss"), vskip, ss_code);
	primitive(TEX_STRING("vfilneg"), vskip, fil_neg_code);
	primitive(TEX_STRING("mskip"), mskip, mskip_code);
	primitive(TEX_STRING("kern"), kern, _explicit);
	primitive(TEX_STRING("mkern"), mkern, mu_glue);

	// 1071
	primitive(TEX_STRING("moveleft"), hmove, 1);
	primitive(TEX_STRING("moveright"), hmove, 0);
	primitive(TEX_STRING("raise"), vmove, 1);
	primitive(TEX_STRING("lower"), vmove, 0);
	primitive(TEX_STRING("box"), make_box, box_code);
	primitive(TEX_STRING("copy"), make_box, copy_code);
	primitive(TEX_STRING("lastbox"), make_box, last_box_code);
	primitive(TEX_STRING("vsplit"), make_box, vsplit_code);
	primitive(TEX_STRING("vtop"), make_box, vtop_code);
	primitive(TEX_STRING("vbox"), make_box, vtop_code + vmode);
	primitive(TEX_STRING("hbox"), make_box, vtop_code + hmode);
	primitive(TEX_STRING("shipout"), leader_ship, a_leaders - 1);
	primitive(TEX_STRING("leaders"), leader_ship, a_leaders);
	primitive(TEX_STRING("cleaders"), leader_ship, c_leaders);
	primitive(TEX_STRING("xleaders"), leader_ship, x_leaders);
		
	// 1088
	primitive(TEX_STRING("indent"), start_par, 1);
	primitive(TEX_STRING("noindent"), start_par, 0);

	// 1107
	primitive(TEX_STRING("unpenalty"), remove_item, penalty_node);
	primitive(TEX_STRING("unkern"), remove_item, kern_node);
	primitive(TEX_STRING("unskip"), remove_item, glue_node);
	primitive(TEX_STRING("unhbox"), un_hbox, box_code);
	primitive(TEX_STRING("unhcopy"), un_hbox, copy_code);
	primitive(TEX_STRING("unvbox"), un_vbox, box_code);
	primitive(TEX_STRING("unvcopy"), un_vbox, copy_code);

	// 1114
	primitive(TEX_STRING("-"), discretionary, 1);
	primitive(TEX_STRING("discretionary"), discretionary, 0);


	// 1141
	primitive(TEX_STRING("eqno"), eq_no, 0);
	primitive(TEX_STRING("leqno"), eq_no, 1);

	// 1156
	primitive(TEX_STRING("mathord"), math_comp, ord_noad);
	primitive(TEX_STRING("mathop"), math_comp, op_noad);
	primitive(TEX_STRING("mathbin"), math_comp, bin_noad);
	primitive(TEX_STRING("mathrel"), math_comp, rel_noad);
	primitive(TEX_STRING("mathopen"), math_comp, open_noad);
	primitive(TEX_STRING("mathclose"), math_comp, close_noad);
	primitive(TEX_STRING("mathpunct"), math_comp, punct_noad);
	primitive(TEX_STRING("mathinner"), math_comp, inner_noad);
	primitive(TEX_STRING("underline"), math_comp, under_noad);
	primitive(TEX_STRING("overline"), math_comp, over_noad);
	primitive(TEX_STRING("displaylimits"), limit_switch, normal);
	primitive(TEX_STRING("limits"), limit_switch, limits);
	primitive(TEX_STRING("nolimits"), limit_switch, no_limits);

	// 1168
	primitive(TEX_STRING("displaystyle"), math_style, display_style);
	primitive(TEX_STRING("textstyle"), math_style, text_style);
	primitive(TEX_STRING("scriptstyle"), math_style, script_style);
	primitive(TEX_STRING("scriptscriptstyle"), math_style, script_script_style);

	// 1178
	primitive(TEX_STRING("above"), above, above_code);
	primitive(TEX_STRING("over"), above, over_code);
	primitive(TEX_STRING("atop"), above, atop_code);
	primitive(TEX_STRING("abovewithdelims"), above, delimited_code + above_code);
	primitive(TEX_STRING("overwithdelims"), above, delimited_code + over_code);
	primitive(TEX_STRING("atopwithdelims"), above, delimited_code + atop_code);

	// 1188
	primitive(TEX_STRING("left"), left_right, left_noad);
	primitive(TEX_STRING("right"), left_right, right_noad);
	text(frozen_right) = TEX_STRING("right");
	eqtb[frozen_right] = eqtb[cur_val];

	//1208
	primitive(TEX_STRING("long"), prefix, 1);
	primitive(TEX_STRING("outer"), prefix, 2);
	primitive(TEX_STRING("global"), prefix, 4);
	primitive(TEX_STRING("def"), def, 0);
	primitive(TEX_STRING("gdef"), def, 1);
	primitive(TEX_STRING("edef"), def, 2);
	primitive(TEX_STRING("xdef"), def, 3);

	// 1218
	primitive(TEX_STRING("let"), let, normal);
	primitive(TEX_STRING("futurelet"), let, normal + 1);

	//1222
	primitive(TEX_STRING("chardef"), shorthand_def, char_def_code);
	primitive(TEX_STRING("mathchardef"), shorthand_def, math_char_def_code);
	primitive(TEX_STRING("countdef"), shorthand_def, count_def_code);
	primitive(TEX_STRING("dimendef"), shorthand_def, dimen_def_code);
	primitive(TEX_STRING("skipdef"), shorthand_def, skip_def_code);
	primitive(TEX_STRING("muskipdef"), shorthand_def, mu_skip_def_code);
	primitive(TEX_STRING("toksdef"), shorthand_def, toks_def_code);

	// 1230
	primitive(TEX_STRING("catcode"), def_code, cat_code_base);
	primitive(TEX_STRING("lccode"), def_code, lc_code_base);
	primitive(TEX_STRING("sfcode"), def_code, sf_code_base);
	primitive(TEX_STRING("textfont"), def_family, math_font_base);
	primitive(TEX_STRING("scriptfont"), def_family, math_font_base+script_size);
	primitive(TEX_STRING("scriptscriptfont"), def_family, math_font_base + script_script_size);
	primitive(TEX_STRING("mathcode"), def_code, math_code_base);
	primitive(TEX_STRING("uccode"), def_code, uc_code_base);
	primitive(TEX_STRING("delcode"), def_code, del_code_base);

	// 1249
	primitive(TEX_STRING("hyphenation"), hyph_data, 0);
	primitive(TEX_STRING("patterns"), hyph_data, 1);

	// 1254
	primitive(TEX_STRING("hyphenchar"), assign_font_int, 0);
	primitive(TEX_STRING("skewchar"), assign_font_int, 1);

	// 1262
	primitive(TEX_STRING("batchmode"), set_interaction, batch_mode);
	primitive(TEX_STRING("nonstopmode"), set_interaction, nonstop_mode);
	primitive(TEX_STRING("scrollmode"), set_interaction, scroll_mode);
	primitive(TEX_STRING("errorstopmode"), set_interaction, error_stop_mode);

	// 1272
	primitive(TEX_STRING("openin"), in_stream, 1);
	primitive(TEX_STRING("closein"), in_stream, 0);

	// 1277
	primitive(TEX_STRING("message"), message, 0);
	primitive(TEX_STRING("errmessage"), message, 1);

	// 1286
	primitive(TEX_STRING("lowercase"), case_shift, lc_code_base);
	primitive(TEX_STRING("uppercase"), case_shift, uc_code_base);

	// 1291
	primitive(TEX_STRING("show"), xray, show_code);
	primitive(TEX_STRING("showbox"), xray, show_box_code);
	primitive(TEX_STRING("showthe"), xray, show_the_code);
	primitive(TEX_STRING("showlists"), xray, show_lists);

	// 1344
	primitive(TEX_STRING("openout"), extension, open_node);
	primitive(TEX_STRING("write"), extension, write_node); write_loc = cur_val;
	primitive(TEX_STRING("closeout"), extension, close_node);
	primitive(TEX_STRING("special"), extension, special_node);
	primitive(TEX_STRING("immediate"), extension, immediate_code);
	primitive(TEX_STRING("setlanguage"), extension, set_language_code);

#pragma endregion

	no_new_control_sequence = true;
}
//tini


// these are macros in tex.web but I use functions instead
// 1305

void dump_wd(memory_word memword)
{
	fwrite(&memword, sizeof memword, 1, fmt_file);
}

void dump_int(int n)
{
	fwrite(&n, sizeof n, 1, fmt_file);
}

void dump_hh(two_halves halves)
{
	fwrite(&halves, sizeof halves, 1, fmt_file);
}

void dump_qqqq(four_quarters fq)
{
	fwrite(&fq, sizeof fq, 1, fmt_file);
}

// 1306
void undump_wd(memory_word *memword)
{
	fread(memword, sizeof *memword, 1, fmt_file);
}

void undump_int(int *anint)
{
	fread(anint, sizeof *anint, 1, fmt_file);
}


void undump_hh(two_halves *hh)
{
	fread(hh, sizeof *hh, 1, fmt_file);
}


void undump_qqqq(four_quarters *qqqq)
{
	fread(qqqq, sizeof *qqqq, 1, fmt_file);
}


// 948
trie_pointer trie_node(trie_pointer p)
{
	trie_pointer h;
	trie_pointer q;
	trie_pointer retval;
	h = abs(trie_c[p] + 1009 * trie_o[p] + 2718 * trie_l[p] + 3142 * trie_r[p]) % trie_size;
	while (1) {
		q = trie_hash[h];
		if (q == 0) {
			trie_hash[h] = p; retval = p; return retval;
		}
		if (trie_c[q] == trie_c[p] && trie_o[q] == trie_o[p] && trie_l[q] == trie_l[p] && trie_r[q] == trie_r[p]) {
			retval = q; return retval;
		}
		if (h > 0) decr(h); else h = trie_size;
	}
}


// 949
trie_pointer compress_trie(trie_pointer p)
{
	trie_pointer retval;
	if (p == 0) retval = 0;
	else {
		trie_l[p] = compress_trie(trie_l[p]); trie_r[p] = compress_trie(trie_r[p]);
		retval = trie_node(p);
	}
	return retval;
}


// 953
void first_fit(trie_pointer p)
{
	trie_pointer h;
	trie_pointer z;
	trie_pointer q;
	ASCII_code c;
	trie_pointer l, r;
	unsigned int ll;

	c = so(trie_c[p]); z = trie_min[c];
	while (1) {
		h = z - c;
		#pragma region Ensure that trie_max >= h+256 954>
		if (trie_max < h + 256) {
			if (trie_size <= h + 256) overflow(TEX_STRING("pattern memory"), trie_size);
			do {
				incr(trie_max); trie_taken[trie_max] = false; trie_link(trie_max) = trie_max + 1;
				trie_back(trie_max) = trie_max - 1;
			} while (!(trie_max == h + 256));
		}
#pragma endregion
		if (trie_taken[h]) goto not_found;
		#pragma region <If all characters of the family fit relative to h, then goto found otherwise goto not_found 955>
		q = trie_r[p];
		while (q > 0) {
			if (trie_link(h + so(trie_c[q])) == 0) goto not_found;
			q = trie_r[q];
		}
		goto found;
#pragma endregion

	not_found:
		z = trie_link(z);
	}
found:
	#pragma region <Pack the family into trie relative to h 956>
	trie_taken[h] = true; trie_ref[p] = h; q = p;
	do {
		z = h + so(trie_c[q]); l = trie_back(z); r = trie_link(z); trie_back(r) = l; trie_link(l) = r;
		trie_link(z) = 0;
		if (l < 256) {
			if (z < 256) ll = z;
			else ll = 256;
			do {
				trie_min[l] = r; incr(l);
			} while (!(l == ll));
		}
		q = trie_r[q];
	} while (!(q == 0));
	#pragma endregion
}

// 957
void trie_pack(trie_pointer p)
{
	trie_pointer q;
	do {
		q = trie_l[p];
		if (q > 0 && trie_ref[q] == 0) {
			first_fit(q); trie_pack(q);
		}
		p = trie_r[p];
	} while (!(p == 0));
}


void trie_fix(trie_pointer p)
{
	trie_pointer q;
	ASCII_code c;
	trie_pointer z;
	z = trie_ref[p];
	do {
		q = trie_l[p]; c = so(trie_c[p]); trie_link(z + c) = trie_ref[q]; trie_char(z + c) = qi(c);
		trie_op(z + c) = trie_o[p];
		if (q > 0) trie_fix(q);
		p = trie_r[p];
	} while (!(p == 0));
}

// 966
void init_trie()
{
	trie_pointer p;
	int j, k, t;
	trie_pointer r, s;
	two_halves h;

	#pragma region <Get ready to compress the trie 952>

	#pragma region <Sort the hyphenation op tables into proper order 945>
	op_start[0] = -min_quarterword;
	for (j = 1; j <= 255; j++) op_start[j] = op_start[j - 1] + qo(trie_used[j - 1]);
	for (j = 1; j <= trie_op_ptr; j++) trie_op_hash[j] = op_start[trie_op_lang[j]] + trie_op_val[j];
	for (j = 1; j <= trie_op_ptr; j++)
		while (trie_op_hash[j] > (unsigned)j) {
			k = trie_op_hash[j];
			t = hyf_distance[k]; hyf_distance[k] = hyf_distance[j]; hyf_distance[j] = t;
			t = hyf_num[k]; hyf_num[k] = hyf_num[j]; hyf_num[j] = t;
			t = hyf_next[k]; hyf_next[k] = hyf_next[j]; hyf_next[j] = t;
			trie_op_hash[j] = trie_op_hash[k]; trie_op_hash[k] = k;
		}
	#pragma endregion

	for (p = 0; p <= trie_size; p++) trie_hash[p] = 0;
	trie_root = compress_trie(trie_root);
	for (p = 0; p <= trie_ptr; p++) trie_ref[p] = 0;
	for (p = 0; p <= 255; p++) trie_min[p] = p + 1;
	trie_link(0) = 1; trie_max = 0;
	#pragma endregion

	if (trie_root != 0) {
		first_fit(trie_root); trie_pack(trie_root);
	}
	#pragma region <Move the data into trie 958>
	h.rh = 0; h.union_t.struct_t.b0 = min_quarterword; h.union_t.struct_t.b1 = min_quarterword;
	if (trie_root == 0) {
		for (r = 0; r <= 256; r++) trie[r] = h;
		trie_max = 256;
	}
	else {
		trie_fix(trie_root);
		r = 0;
		do {
			s = trie_link(r); trie[r] = h; r = s;
		} while (!(r > trie_max));
	}
	trie_char(0) = qi(TEX_STRING("?"));
	#pragma endregion



	trie_not_ready = false;
}


// 1302

//init
void store_fmt_file()
{
	int j, k, l;
	pointer p, q;
	int x;
	four_quarters w;

	#pragma region <If dumping is not allowed abort 1304>
	if (save_ptr != 0) {
		print_err(TEX_STRING("You can't dump inside a group"));
		help1(TEX_STRING("`{...\dump}' is a no-no."));
		succumb;
	}
	#pragma endregion

	#pragma region <Create the format_ident, open the format file and inform the user that dumping has begun 1328>
	selector = new_string;
	print(TEX_STRING(" (preloaded format="));
	print(job_name);
	print_char(TEX_STRING(" "));
	print_int(year);
	print_char(TEX_STRING("."));
	print_int(month);
	print_char(TEX_STRING("."));
	print_int(day);
	print_char(TEX_STRING(")"));
	if (interaction == batch_mode) selector = log_only;
	else
		selector = term_and_log;
	str_room(1); format_ident = make_string(); pack_job_name(format_extension);
	while (!w_open_out(&fmt_file)) prompt_file_name(TEX_STRING("format file name"), format_extension);

	print_nl(TEX_STRING("Beginning to dump on file "));
	slow_print(w_make_name_string(fmt_file));
	flush_string;
	print_nl(TEX_STRING(""));
	slow_print(format_ident);


	#pragma endregion

	#pragma region <Dump constants for consistency check 1307>
	dump_int(@$);
	dump_int(mem_bot);
	dump_int(mem_top);
	dump_int(eqtb_size);
	dump_int(hash_prime);
	dump_int(hyph_size);
#pragma endregion

	#pragma region <Dump the string pool 1309>
	dump_int(pool_ptr); dump_int(str_ptr);
	for (k = 0; k <= str_ptr; k++) dump_int(str_start[k]);
	k = 0;
	while (k + 4 < pool_ptr) {
		dump_four_ASCII;
		k += 4;
	}
	k = pool_ptr - 4;
	dump_four_ASCII;
	print_ln();
	print_int(str_ptr);
	print(TEX_STRING(" strings of total length "));
	print_int(pool_ptr);
	#pragma endregion

	#pragma region <Dump the dynamic memory 1311>
	sort_avail();
	var_used = 0; dump_int(lo_mem_max);
	dump_int(rover);
	p = mem_bot;
	q = rover;
	x = 0;
	do {
		for (k = p; k <= q + 1; k++) dump_wd(mem[k]);
		x = x + q + 2 - p; var_used = var_used + q - p; p = q + node_size(q); q = rlink(q);
	} while (!(q == rover));
	var_used = var_used + lo_mem_max - p; dyn_used = mem_end + 1 - hi_mem_min;
	for (k = p; k <= lo_mem_max; k++) dump_wd(mem[k]);
	x = x + lo_mem_max + 1 - p; dump_int(hi_mem_min); dump_int(avail);
	for (k = hi_mem_min; k <= mem_end; k++) dump_wd(mem[k]);
	x = x + mem_end + 1 - hi_mem_min; p = avail;
	while (p != null) {
		decr(dyn_used); p = link(p);
	}
	dump_int(var_used); dump_int(dyn_used); print_ln(); print_int(x);
	print(TEX_STRING(" memory locations dumped; current usage is "));
	print_int(var_used); print_char(TEX_STRING("&"));
	print_int(dyn_used);
	#pragma endregion

	#pragma region <Dump the table of equivalents 1313>
	#pragma region <Dump regions 1 to 4 of eqtb 1315>
	k = active_base;
	do { 
		j = k;
		while (j < int_base - 1) {
			if (equiv(j) == equiv(j + 1) && eq_type(j) == eq_type(j + 1) && eq_level(j) == eq_level(j + 1))
				goto found1;
			incr(j);
		}
		l = int_base; goto done1;
	found1:
		incr(j); l = j;
		while (j < int_base - 1) {
			if (equiv(j) != equiv(j + 1) || eq_type(j) != eq_type(j + 1) || eq_level(j) != eq_level(j + 1))
				goto done1;
			incr(j);
		}
	done1:
		dump_int(l - k);
		while (k < l) {
			dump_wd(eqtb[k]); incr(k);
		}
		k = j + 1; dump_int(k - l);
	} while (!(k == int_base));
	#pragma endregion

		
	#pragma region <Dump regions 5 and 6 of eqtb 1316>
	do {
		j = k;
		while (j < eqtb_size) {
			if (eqtb[j].union_t.an_int == eqtb[j + 1].union_t.an_int)
				goto found2;
			incr(j);
		}
		l = eqtb_size + 1; goto done2;
	found2:
		incr(j); l = j;
		while (j < eqtb_size) {
			if (eqtb[j].union_t.an_int != eqtb[j + 1].union_t.an_int)
				goto done2;
			incr(j);
		}
	done2:
		dump_int(l - k);
		while (k < l) {
			dump_wd(eqtb[k]); incr(k);
		}
		k = j + 1; dump_int(k - l);
	} while (!(k > eqtb_size));
	#pragma endregion


	dump_int(par_loc); dump_int(write_loc);

	#pragma region <dump the hash table 1318>
	dump_int(hash_used); cs_count = frozen_control_sequence - 1 - hash_used;
	for(p = hash_base; p<=hash_used;p++)
		if (text(p) != 0) {
			dump_int(p); dump_hh(hash[p]); incr(cs_count);
		}
	for (p = hash_used + 1; p <= undefined_control_sequence - 1; p++) dump_hh(hash[p]);
	dump_int(cs_count);
	print_ln();
	print_int(cs_count);
	print(TEX_STRING(" multiletter control sequences"));

	#pragma endregion

	#pragma endregion

	#pragma region <Dump the font information 1320>
	dump_int(fmem_ptr);
	for (k = 0; k <= fmem_ptr - 1; k++) dump_wd(font_info[k]);
	dump_int(font_ptr);
	for (k = null_font; k <= font_ptr; k++)
	#pragma region <Dump the array info for internal font number k 1322>
	{
		dump_qqqq(font_check[k]); dump_int(font_size[k]); dump_int(font_dsize[k]);
		dump_int(font_params[k]);
		dump_int(hyphen_char[k]); dump_int(skew_char[k]);
		dump_int(font_name[k]); dump_int(font_area[k]);
		dump_int(font_bc[k]); dump_int(font_ec[k]);
		dump_int(char_base[k]); dump_int(width_base[k]); dump_int(height_base[k]);
		dump_int(depth_base[k]); dump_int(italic_base[k]); dump_int(lig_kern_base[k]);
		dump_int(kern_base[k]); dump_int(exten_base[k]); dump_int(param_base[k]);
		dump_int(font_glue[k]);
		dump_int(bchar_label[k]); dump_int(font_bchar[k]); dump_int(font_false_bchar[k]);
		print_nl(TEX_STRING("\font")); print_esc(font_id_text(k)); 
		print_char(TEX_STRING("="));
		print_file_name(font_name[k], font_area[k], TEX_STRING(""));
		if (font_size[k] != font_dsize[k]) {
			print(TEX_STRING(" at ")); print_scaled(font_size[k]);
			print(TEX_STRING("pt"));
		}
	}
#pragma endregion

	print_ln(); print_int(fmem_ptr - 7); print(TEX_STRING(" words of font info for "));
	print_int(font_ptr - font_base); print(TEX_STRING(" preloaded font"));
	if (font_ptr != font_base + 1) print_char(TEX_STRING("s"));
#pragma endregion

	#pragma region <Dump the hyphenation tables 1324>
	dump_int(hyph_count);
	for(k =0;k<=hyph_size;k++)
		if (hyph_word[k] != 0) {
			dump_int(k); dump_int(hyph_word[k]); dump_int(hyph_list[k]);
		}
	print_ln(); print_int(hyph_count); print(TEX_STRING(" hyphenation exception"));
	if (hyph_count != 1) print_char(TEX_STRING("s"));
	if (trie_not_ready) init_trie();
	dump_int(trie_max);
	for (k = 0; k <= trie_max; k++) dump_hh(trie[k]);
	dump_int(trie_op_ptr);
	for (k = 1; k <= trie_op_ptr; k++) {
		dump_int(hyf_distance[k]); dump_int(hyf_num[k]); dump_int(hyf_next[k]);
	}
	print_nl(TEX_STRING("Hyphenation trie of length "));
	print_int(trie_max); print(TEX_STRING(" has "));
	print_int(trie_op_ptr); print(TEX_STRING(" op"));
	if (trie_op_ptr != 1) print_char(TEX_STRING("s"));
	print(TEX_STRING(" out of ")); print_int(trie_op_size);
	for (k=256; k--;)
		if (trie_used[k] > min_quarterword) {
			print_nl(TEX_STRING("  ")); print_int(qo(trie_used[k]));
			print(TEX_STRING(" for language ")); print_int(k);
			dump_int(k); dump_int(qo(trie_used[k]));
		}
	#pragma endregion

	#pragma region <Dump a couple more things and the closing check word 1326>
	dump_int(interaction); dump_int(format_ident); dump_int(69069);
	tracing_stats = 0;
	#pragma endregion

	#pragma region <Close the format file 1329>
	w_close(fmt_file);

	#pragma endregion
}
//tini

int main()
{
	// 1332
	history = fatal_error_stop;
	// t_open_out open the terminal for ouput
	// no need to do this in C

	if (ready_already == 314159) {
		goto start_of_TEX;
	}
	#pragma region <check the constant values for consistency 14>
	bad = 0;
	if (half_error_line<30 || half_error_line > error_line - 15) bad = 1;
	if (max_print_line < 60) bad = 2;
	if (dvi_buf_size % 8 != 0) bad = 3;
	if (mem_bot + 1100 > mem_top) bad = 4;
	if (hash_prime > hash_size) bad = 5;
	if (max_in_open >= 128) bad = 6;
	if (mem_top < 256 + 11) bad = 7;

	// 111
	//init
	if (mem_min != mem_bot || mem_max != mem_top) bad = 10;
	//tini
	if (mem_min > mem_bot || mem_max < mem_top) bad = 10;
	if (min_quarterword > 0 || max_quarterword < 127) bad = 11;
	if (min_halfword > 0 || max_halfword < 32767) bad = 12;
	if (min_quarterword < min_halfword || max_quarterword > max_halfword) bad = 13;
	if (mem_min < min_halfword || mem_max >= max_halfword ||
		mem_bot - mem_min > max_halfword + 1) bad = 14;
	if (font_base < min_quarterword || font_max > max_quarterword) bad = 15;
	if (font_max > font_base + 256) bad = 16;
	if (save_size > max_halfword) bad = 18;
	if (max_quarterword - min_quarterword < 255) bad = 19;

	//290
	if (cs_token_flag + undefined_control_sequence > max_halfword) bad = 21;

	// 522
	if (format_default_length > file_name_size) bad = 31;

	// 1249
	if (2 * max_halfword < mem_top - mem_min) bad = 41;
	

#pragma endregion

	if (bad > 0) {
		wterm_ln_s("Ouch---my internal constants have been clobbered");
		goto final_end;
	}
	initialize();
	//init
	if (!get_strings_started())
		goto final_end;
	init_prim();
	init_str_ptr = str_ptr; init_pool_ptr = pool_ptr; fix_date_and_time();
	//tini

	ready_already = 314159;

start_of_TEX:

	#pragma region <Initialize the output routines 55>
	selector = term_only; tally = 0; term_offset = 0; file_offset = 0;

	// 61
	wterm_s(banner);
	if (format_ident == 0) wterm_ln_s(" (no format preloaded)");
	else {
		slow_print(format_ident);
		print_ln();
	}
	update_terminal();

	// 528
	job_name = 0; name_in_progress = false; log_opened = false;

	//533
	output_file_name = 0;

#pragma endregion

	#pragma region <Get the first line of input and prepare to start 1337

	#pragma region <Initialize the input routines 331>
	input_ptr = 0; max_in_stack = 0; in_open = 0; open_parens = 0; max_buf_stack = 0;
	param_ptr = 0; max_param_stack = 0; first = buf_size;
	do { buffer[first] = 0; decr(first);
	} while (!(first == 0));
	scanner_status = normal; warning_index = null; first = 1; state = new_line; start = 1; index = (enum_token_type)0;
	line = 0; name = 0; force_eof = false; align_state = 1000000;
	if (!init_terminal()) goto final_end;
	limit = last; first = last + 1;
#pragma endregion

	if (format_ident == 0 || buffer[loc] == TEX_STRING("&")) {
		if (format_ident != 0) initialize();
		if (!open_fmt_file()) goto final_end;
		if (!load_fmt_file()) {
			w_close(fmt_file);
			goto final_end;
		}
		w_close(fmt_file);
		while (loc < limit&&buffer[loc] == TEX_STRING(" ")) incr(loc);
	}
	if (end_line_char_inactive) decr(limit);
	else buffer[limit] = end_line_char;
	fix_date_and_time();

	#pragma region <Compute the magic offset 765>
	magic_offset = str_start[math_spacing] - 9 * ord_noad;
#pragma endregion

	#pragma region <Initialize the print selector based on interaction 75>
	if (interaction == batch_mode) selector = no_print;
	else selector = term_only;
	#pragma endregion

	if (loc < limit && cat_code(buffer[loc]) != escape) start_input();

#pragma endregion

	history = spotless;
	main_control();
	final_cleanup();


	do_end_of_TEX();
	
final_end:
	do_final_end();

	return 0;
}

