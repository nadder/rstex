/*
Copyright (C) 2018 by Richard Sandberg.

This is the windows specific version of rstex.

*/
#include <io.h>
#include <sstream>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <ctime>
#include <climits>
#include "rstex.h"


// Some versions of gcc and clang easily get confused about the abs function overloads so let's use our own abs functions
float myabs(float x)
{
	return x >= 0.0f ? x : -x;
}

int myabs(int x)
{
	// overflow check
	if (x == INT_MIN && -(INT_MIN + 1) == INT_MAX) {
		printf("Overflow myabs.\n");
		exit(1);
	}
	///////////////////////
	
	return x >= 0 ? x : -x;
}

bool myodd(int c)
{
	return ((c % 2) != 0);
}

// 21,23,24
void setup_char_arrays()
{
	for (int i = 0; i < 32; i++)
		xchr[i] = i;

	for (int i = 127; i < 256; i++)
		xchr[i] = i;

	xchr[32] = ' '; xchr[33] = '!'; xchr[34] = '\"'; xchr[35] = '#'; xchr[36] = '$';
	xchr[37] = '%'; xchr[38] = '&'; xchr[39] = '\''; xchr[40] = '('; xchr[41] = ')';
	xchr[42] = '*'; xchr[43] = '+'; xchr[44] = ','; xchr[45] = '-'; xchr[46] = '.';
	xchr[47] = '/'; xchr[48] = '0'; xchr[49] = '1'; xchr[50] = '2'; xchr[51] = '3';
	xchr[52] = '4'; xchr[53] = '5'; xchr[54] = '6'; xchr[55] = '7'; xchr[56] = '8';
	xchr[57] = '9'; xchr[58] = ':'; xchr[59] = ';'; xchr[60] = '<'; xchr[61] = '=';
	xchr[62] = '>'; xchr[63] = '?'; xchr[64] = '@'; xchr[65] = 'A'; xchr[66] = 'B';
	xchr[67] = 'C'; xchr[68] = 'D'; xchr[69] = 'E'; xchr[70] = 'F'; xchr[71] = 'G';
	xchr[72] = 'H'; xchr[73] = 'I'; xchr[74] = 'J'; xchr[75] = 'K'; xchr[76] = 'L';
	xchr[77] = 'M'; xchr[78] = 'N'; xchr[79] = 'O'; xchr[80] = 'P'; xchr[81] = 'Q';
	xchr[82] = 'R'; xchr[83] = 'S'; xchr[84] = 'T'; xchr[85] = 'U'; xchr[86] = 'V';
	xchr[87] = 'W'; xchr[88] = 'X'; xchr[89] = 'Y'; xchr[90] = 'Z'; xchr[91] = '[';
	xchr[92] = '\\'; xchr[93] = ']'; xchr[94] = '^'; xchr[95] = '_'; xchr[96] = '`';
	xchr[97] = 'a'; xchr[98] = 'b'; xchr[99] = 'c'; xchr[100] = 'd'; xchr[101] = 'e';
	xchr[102] = 'f'; xchr[103] = 'g'; xchr[104] = 'h'; xchr[105] = 'i'; xchr[106] = 'j';
	xchr[107] = 'k'; xchr[108] = 'l'; xchr[109] = 'm'; xchr[110] = 'n'; xchr[111] = 'o';
	xchr[112] = 'p'; xchr[113] = 'q'; xchr[114] = 'r'; xchr[115] = 's'; xchr[116] = 't';
	xchr[117] = 'u'; xchr[118] = 'v'; xchr[119] = 'w'; xchr[120] = 'x'; xchr[121] = 'y';
	xchr[122] = 'z'; xchr[123] = '{'; xchr[124] = '|'; xchr[125] = '}'; xchr[126] = '~';
	
	for (int i = 0; i < 256; i++) {
		xord[i] = 127;
	}
	for (int i = 128; i < 256; i++) {
		int ind = xchr[i];
		xord[ind] = i;
	}
	for (int i = 0; i < 127; i++) {
		int ind = xchr[i];
		xord[ind] = i;
	}
}

// 34
void update_terminal()
{}
void clear_terminal()
{}
void wake_up_terminal()
{}



// 81
void jump_out()
{
	do_end_of_TEX();
}

// routine called when tex says goto final_end
void do_final_end()
{
	wterm_cr;

	if (history <= warning_issued)
		exit(0);
	else
		exit(1);
}

// routine called when tex says goto end_of_TEX
void do_end_of_TEX()
{
	close_files_and_terminate();
	do_final_end();
}


// 58
void print_char(ASCII_code s)
{
	if (s == new_line_char) // character s is the current new-line character (244)
		if (selector < pseudo) {
			print_ln(); return;
		}

	switch (selector) {
		case term_and_log:
			wterm_c(xchr[s]);
			wlog_c(xchr[s]);
			incr(term_offset);
			incr(file_offset);
			if (term_offset == max_print_line) {
				wterm_cr;
				term_offset = 0;
			}
			if (file_offset == max_print_line) {
				wlog_cr;
				file_offset = 0;
			}
			break;

		case log_only:
			wlog_c(xchr[s]);
			incr(file_offset);
			if (file_offset == max_print_line)
				print_ln();
			break;

		case term_only:
			wterm_c(xchr[s]);
			incr(term_offset);
			if (term_offset == max_print_line)
				print_ln();
			break;

		case no_print:
			// do_nothing
			break;
			
		case pseudo:
			if (tally < trick_count)
				trick_buf[tally % error_line] = s;
			break;
			
		case new_string:
			if (pool_ptr < pool_size)
				append_char(s);
			break;

		default:
			fputc(xchr[s], write_file[selector]);
			break;
	}
	incr(tally);
}


// 59
void print(int s)
{
	pool_pointer j;
	int nl;

	if (s >= str_ptr) s = TEX_STRING("???");
	else if (s < 256)
		if (s < 0) s = TEX_STRING("???");
		else {
			if (selector > pseudo) {
				print_char(s); return;
			}
			if (s == new_line_char) // <Character s is the current new-line character 244>
				if (selector < pseudo) {
					print_ln(); return;
				}
			nl = new_line_char; new_line_char = -1;
			j = str_start[s];
			while (j < str_start[s + 1]) {
				print_char(so(str_pool[j])); incr(j);
			}
			new_line_char = nl; return;
		}


	j = str_start[s];
	while (j < str_start[s + 1]) {
		print_char(so(str_pool[j]));
		incr(j);
	}
}

void print_the_digs(eight_bits k)
{
	while (k > 0) {
		decr(k);
		if (dig[k] < 10)
			print_char(TEX_STRING("0") + dig[k]);
		else
			print_char(TEX_STRING("A") - 10 + dig[k]);
	}
}

//67
void print_hex(int n)
{
	int k; // 0..22

	k = 0; print_char(TEX_STRING(""""));
	do {
		dig[k] = n % 16; n = n / 16; incr(k);
	} while (!(n == 0));
	print_the_digs(k);
}

//65
void print_int(int n)
{
	int k;
	int m;
	k = 0;
	if (n < 0) {
		print_char(TEX_STRING("-"));
		if (n > -100000000)
			negate(n);
		else {
			m = -1 - n; n = m / 10; m = (m % 10) + 1; k = 1;
			if (m < 10)
				dig[0] = m;
			else {
				dig[0] = 0;
				incr(n);
			}
		}
	}
	do {
		dig[k] = n % 10; n = n / 10; incr(k);
	} while (!(n == 0));
	print_the_digs(k);
}

// 57
void print_ln()
{
	switch (selector) {
		case term_and_log:
			wterm_cr;
			wlog_cr;
			term_offset = 0;
			file_offset = 0;
			break;

		case log_only:
			wlog_cr;
			file_offset = 0;
			break;

		case term_only:
			wterm_cr;
			term_offset = 0;
			break;

		case no_print:
		case pseudo:
		case new_string:
			//do_nothing:
			break;
		default:
			fputc('\n', write_file[selector]);
			break;

	}
}

void print_nl(str_number s)
{
	if((term_offset > 0 && myodd(selector)) || (file_offset > 0 && selector >= log_only))
		print_ln();
	print(s);
}

// 60
void slow_print(int s)
{
	pool_pointer j;
	if (s >= str_ptr || s < 256)
		print(s);
	else {
		j = str_start[s];
		while (j < str_start[s + 1]) {
			print(str_pool[j]);
			incr(j);
		}
	}
}

// 66
void print_two(int n)
{
	n = myabs(n) % 100;
	print_char(TEX_STRING("0") + (n / 10));
	print_char(TEX_STRING("0") + (n % 10));
}

// 69
void print_roman_int(int n)
{
	pool_pointer j, k;
	nonnegative_integer u, v;

	j = str_start[TEX_STRING("m2d5c2l5x2v5i")]; v = 1000;
	while (1) {
		while (n >= v) {
			print_char(so(str_pool[j])); n -= v;
		}
		if (n <= 0) return;
		k = j + 2; u = v / (so(str_pool[k - 1]) - TEX_STRING("0"));
		if (str_pool[k - 1] == si(TEX_STRING("2"))) {
			k += 2; u = u / (so(str_pool[k - 1]) - TEX_STRING("0"));
		}
		if (n + u >= v) {
			print_char(so(str_pool[k])); n += u;
		}
		else {
			j += 2; v = v / (so(str_pool[j - 1]) - TEX_STRING("0"));
		}
	}

}

void print_esc(str_number s)
{
	int c;

	#pragma region <Set variable c to the current escape character 243>
	c = escape_char;
	#pragma endregion

	if (c >= 0)
		if (c < 256)
			print(c);

	slow_print(s);
}

// 94
void overflow(str_number s, int n)
{
	normalize_selector();
	print_err(TEX_STRING("TeX capacity exceeded, sorry ["));
	print(s); print_char('=');
	print_int(n); print_char(']');
	help2(TEX_STRING("If you really absolutely need more capacity,"),
		TEX_STRING("you can ask a wizard to enlarge me."));
	succumb();
}

// 43
str_number make_string()
{
	if (str_ptr == max_strings)
		overflow(TEX_STRING("number of strings"), max_strings - init_str_ptr);
	incr(str_ptr); str_start[str_ptr] = pool_ptr;
	return str_ptr - 1;
}


// 45
bool str_eq_buf(str_number s, int k)
{
	pool_pointer j;
	bool result;

	j = str_start[s];
	while (j < str_start[s + 1]) {
		if (so(str_pool[j]) != buffer[k]) {
			result = false;
			goto not_found;
		}
		incr(j); incr(k);
	}
	result = true;
not_found:
	return result;
}

// 46
bool str_eq_str(str_number s, str_number t)
{
	pool_pointer j, k;
	bool result;

	result = false;
	if (length(s) != length(t))
		goto not_found;
	j = str_start[s]; k = str_start[t];
	while (j < str_start[s + 1]) {
		if (str_pool[j] != str_pool[k])
			goto not_found;
		incr(j); incr(k);
	}
	result = true;
not_found:
	return result;
}

// 100
int half(int x)
{
	if (myodd(x))return (x + 1) / 2;
	else return x / 2;
}

// 102
scaled round_decimals(small_number k)
{
	int a;

	a = 0;
	while (k > 0) {
		decr(k); a = (a + dig[k] * two) / 10;
	}
	return (a + 1) / 2;
}


// 103
void print_scaled(scaled s)
{
	scaled delta;
	if (s < 0) {
		print_char(TEX_STRING("-")); negate(s);
	}
	print_int(s / unity);
	print_char(TEX_STRING(".")); s = 10 * (s%unity) + 5; delta = 10;
	do {
		if (delta > unity)
			s = s + 0100000 - 50000;
		print_char(TEX_STRING("0") + (s / unity)); s = 10 * (s % unity); delta = delta * 10;
	} while (!(s <= delta));
}

// 105
scaled mult_and_add(int n, scaled x, scaled y, scaled max_answer)
{
	if (n < 0) {
		negate(x); negate(n);
	}
	if (n == 0)return y;
	else if (x <= (max_answer - y) / n && -x <= (max_answer + y) / n) return n * x + y;
	else {
		arith_error = true; return 0;
	}
}

// 114
#ifndef NO_DEBUG 
void print_word(memory_word w) // {prints w in all ways}
{
	print_int(w.an_int); print_char(TEX_STRING(" "));
	print_scaled(w.sc); print_char(TEX_STRING(" "));
	print_scaled((scaled)round(unity * w.gr)); print_ln();
	print_int(w.hh.lh); print_char(TEX_STRING("=")); print_int(w.hh.b0); print_char(TEX_STRING(":")); print_int(w.hh.b1);
	print_char(TEX_STRING(";")); print_int(w.hh.rh); print_char(TEX_STRING(" "));
	print_int(w.qqqq.b0); print_char(TEX_STRING(":")); print_int(w.qqqq.b1); print_char(TEX_STRING(":")); print_int(w.qqqq.b2);
	print_char(TEX_STRING(":")); print_int(w.qqqq.b3);
}
#endif

//167
//debug
#ifndef NO_DEBUG
void check_mem(bool print_locs)
{
	pointer q, p;
	bool clobbered;

	for (p = mem_min; p <= lo_mem_max; p++)
		_free[p] = false;
	for (p = hi_mem_min; p <= mem_end; p++)
		_free[p] = false;

	#pragma region <Check single word avail list 168>
	p = avail; q = null; clobbered = false;
	while (p != null) {
		if (p > mem_end || p < hi_mem_min) clobbered = true;
		else if (_free[p]) clobbered = true;
		if (clobbered) {
			print_nl(TEX_STRING("AVAIL list clobbered at "));
			print_int(q);
			goto done1;
		}
		_free[p] = true; q = p; p = link(q);
	}
done1:
	#pragma endregion

	#pragma region <Check varaible-size avail list 169>
	p = rover; q = null; clobbered = false;
	do {
		if (p >= lo_mem_max || p < mem_min) clobbered = true;
		else if (rlink(p) >= lo_mem_max || rlink(p) < mem_min) clobbered = true;
		else if (!is_empty(p) || node_size(p) < 2 || p + node_size(p) > lo_mem_max ||
			llink(rlink(p)) != p) clobbered = true;

		if (clobbered) {
			print_nl(TEX_STRING("Double-AVAIL list clobbered at "));
			print_int(q); goto done2;
		}
		for (q = p; q <= p + node_size(p) - 1; q++) {
			if (_free[q]) {
				print_nl(TEX_STRING("Doubly free location at "));
				print_int(q); goto done2;
			}
			_free[q] = true;
		}
		q = p; p = rlink(p);
	} while (!(p==rover));
done2:
	#pragma endregion

	#pragma region <Check flags of unavailable nodes 170>
	p = mem_min;
	while (p <= lo_mem_max) {
		if (is_empty(p)) {
			print_nl(TEX_STRING("Bad flag at "));
			print_int(p);
		}
		while (p <= lo_mem_max && !_free[p]) incr(p);
		while (p <= lo_mem_max && _free[p]) incr(p);
	}
	#pragma endregion

	if (print_locs) 
		#pragma region <Print newly busy locations 171>
	{
		print_nl(TEX_STRING("New busy locs:"));
		for(p = mem_min; p <= lo_mem_max; p++)
			if (!_free[p] && (p > was_lo_max || was_free[p]))
			{
				print_char(TEX_STRING(" ")); print_int(p);
			}
		for(p=hi_mem_min; p <= mem_end; p++)
			if (!_free[p] && (p<was_hi_min || p> was_mem_end || was_free[p]))
			{
				print_char(TEX_STRING(" ")); print_int(p);
			}
	}
		#pragma endregion


	for (p = mem_min; p <= lo_mem_max; p++)
		was_free[p] = _free[p];
	for (p = hi_mem_min; p <= mem_end; p++)
		was_free[p] = _free[p];
	was_mem_end = mem_end; was_lo_max = lo_mem_max; was_hi_min = hi_mem_min;
}
#endif
//gubed


//172
//debug
#ifndef NO_DEBUG
void search_mem(pointer p)
{
	int q;

	for (q = mem_min; q <= lo_mem_max; q++) {
		if (link(q) == p) {
			print_nl(TEX_STRING("LINK(")); print_int(q); print_char(TEX_STRING(")"));
		}
		if (info(q) == p) {
			print_nl(TEX_STRING("INFO(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}
	for (q = hi_mem_min; q <= mem_end; q++) {
		if (link(q) == p) {
			print_nl(TEX_STRING("LINK(")); print_int(q); print_char(TEX_STRING(")"));
		}
		if (info(q) == p) {
			print_nl(TEX_STRING("INFO(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}

	#pragma region <Search eqtb for equivalents equal to p 255>
	for (q = active_base; q <= box_base + 255; q++) {
		if (equiv(q) == p) {
			print_nl(TEX_STRING("EQUIV(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}
	#pragma endregion

	#pragma region <Search save_stack for equivalents that point to p 285>
	if(save_ptr > 0)
		for (q = 0; q <= save_ptr - 1; q++) {
			if (equiv_field(save_stack[q]) == p) {
				print_nl(TEX_STRING("SAVE(")); print_int(q); print_char(TEX_STRING(")"));
			}
		}
	#pragma endregion

	#pragma region <Search hyph_list for pointers to p 933>
	for (q = 0; q <= hyph_size; q++) {
		if (hyph_list[q] == p) {
			print_nl(TEX_STRING("HYPH(")); print_int(q); print_char(TEX_STRING(")"));
		}
	}
	#pragma endregion
}
#endif
//gubed


// 136
pointer new_null_box()
{
	pointer p;
	p = get_node(box_node_size);
	type(p) = hlist_node; subtype(p) = min_quarterword;
	width(p) = 0; depth(p) = 0; height(p) = 0; shift_amount(p) = 0; list_ptr(p) = null;
	glue_sign(p) = normal; glue_order(p) = normal; set_glue_ratio_zero(glue_set(p));
	return p;
}


// 147
pointer new_math(scaled w, small_number s)
{
	pointer p;
	p = get_node(small_node_size); type(p) = math_node; subtype(p) = s; width(p) = w;
	return p;
}

// 156
pointer new_kern(scaled w)
{
	pointer p;
	p = get_node(small_node_size); type(p) = kern_node; subtype(p) = normal; width(p) = w;
	return p;
}

// 177
void print_glue(scaled d, int order, str_number s)
{
	print_scaled(d);
	if (order < normal || order > filll)
		print(TEX_STRING("foul"));
	else if (order > normal) {
		print(TEX_STRING("fil"));
		while (order > fil) {
			print_char(TEX_STRING("l")); decr(order);
		}
	}
	else if (s != 0)
		print(s);
}

// 178
void print_spec(int p, str_number s)
{
	if (p < mem_min || p >= lo_mem_max)
		print_char(TEX_STRING("*"));
	else {
		print_scaled(width(p));
		if (s != 0)
			print(s);
		if (stretch(p) != 0) {
			print(TEX_STRING(" plus ")); print_glue(stretch(p), stretch_order(p), s);
		}
		if (shrink(p) != 0) {
			print(TEX_STRING(" minus ")); print_glue(shrink(p), shrink_order(p), s);
		}
	}
}

// 216
void push_nest()
{
	if (nest_ptr > max_nest_stack) {
		max_nest_stack = nest_ptr;
		if (nest_ptr == nest_size) overflow(TEX_STRING("semantic nest size"), nest_size);
	}
	nest[nest_ptr] = cur_list;
	incr(nest_ptr); head = get_avail(); tail = head; prev_graf = 0; mode_line = line;
}

// 217
void pop_nest()
{
	free_avail(head); decr(nest_ptr); cur_list = nest[nest_ptr];
}

// 1119
void build_discretionary()
{
	pointer p, q;
	int n;

	unsave();

	#pragma region <Prune the current list, if necessary, until it contains onlychar_node, kern_node, hlist_node.. 1121>
	q = head; p = link(q); n = 0;
	while (p != null) { 
		if(!is_char_node(p))
			if(type(p) > rule_node)
				if(type(p) != kern_node)
					if (type(p) != ligature_node) {
						print_err(TEX_STRING("Improper discretionary list"));
						help1(TEX_STRING("Discretionary lists must contain only boxes and kerns."));
						error();
						begin_diagnostic();
						print_nl(TEX_STRING("The following discretionary sublist has been deleted:")); show_box(p);
						end_diagnostic(true); flush_node_list(p); link(q) = null; goto done;
					}
		q = p; p = link(q); incr(n);
	}
done:
	#pragma endregion

	p = link(head); pop_nest();
	switch (saved(-1)) {
	case 0: pre_break(tail) = p; break;
	case 1: post_break(tail) = p; break;
	case 2: 
		#pragma region <Attach list p to the current list, and record its length; then finish up and return 1120>
		if (n > 0 && myabs(mode) == mmode) {
			print_err(TEX_STRING("Illegal math ")); 
			print_esc(TEX_STRING("discretionary"));
			help2(TEX_STRING("Sorry: The third part of a discretionary break must be"),
				TEX_STRING("empty, in math formulas. I had to delete your third part."));
			flush_node_list(p); n = 0;
			error();
		}
		else link(tail) = p;
		if (n <= max_quarterword) replace_count(tail) = n;
		else {
			print_err(TEX_STRING("Discretionary list is too long"));
			help2(TEX_STRING("Wow---I never thought anybody would tweak me here."),
				TEX_STRING("You can't seriously need such a huge discretionary list?"));
			error();
		}
		if (n > 0)tail = q;
		decr(save_ptr); goto _exit;
		#pragma endregion
		break;
	}
	incr(saved(-1)); new_save_level(disc_group); scan_left_brace(); push_nest(); mode = (mode_type)-hmode;
	space_factor = 1000;

_exit:
	;
}

// 47
//init
#ifndef NO_INIT
bool get_strings_started()
{
	int k, l; // 0..255
	text_char m, n;
	// str_number g; // not used
	int a;
	bool c;


	pool_ptr = 0;
	str_ptr = 0;
	str_start[0] = 0;

	#pragma region <Make the first 256 strings 48>
	for (k = 0; k <= 255; k++) {
		if ( k < TEX_STRING(" ") || 
			 k > TEX_STRING("~")) {
			append_char(TEX_STRING("^")); 
			append_char(TEX_STRING("^"));
			if (k < 0100)
				append_char(k + 0100);
			else if (k < 0200)
				append_char(k - 0100);
			else {
				app_lc_hex(k / 16); app_lc_hex(k % 16);
			}
		}
		else
			append_char(k);
		make_string();
	}
	#pragma endregion

	#pragma region <Read the other strings from the TEX.POOL file and return true, or give an error message and return false 51>

	strcpy(name_of_file.get_c_str(), pool_name);
	if (a_open_in(&pool_file, pool_file_path)) {
		c = false;
		do {
			#pragma region <Read one string, but return false if the string memory space is getting too tight for comfort 52>
			{
				if (feof(pool_file))
					bad_pool("! tex.pool has no checksum.", true);
				m = fgetc(pool_file);
				n = fgetc(pool_file);
				if (m == '*') 
					#pragma region <check the pool checksum 53>
				{
					a = 0;
					k = 1;
					while (1) {
						if (xord[n] < '0' || xord[n] > '9')
							bad_pool("! tex.pool check sum doesn\'t have nine digits.", true);
						a = 10 * a + xord[n] - '0';
						if (k == 9) goto done;
						k++;
						n = fgetc(pool_file);
					}
				done:
					if (a != @$)
						bad_pool("! tex.pool doesn\'t match; TANGLE me again.", true);
					c = true;
				}
					#pragma endregion
				else {
					if (xord[m] < TEX_STRING("0") || xord[m]> TEX_STRING("9") || xord[n] < TEX_STRING("0") || xord[n] > TEX_STRING("9"))
						bad_pool("! tex.pool line does not begin with two digits.", true);
					l = xord[m] * 10 + xord[n] - TEX_STRING("0") * 11;
					if (pool_ptr + l + string_vacancies > pool_size)
						bad_pool("! You have to increase POOLSIZE.", true);
					for (k = 1; k <= l; k++) {
						int ch = fgetc(pool_file);
						if (ch == '\n')
							m = ' ';
						else
							m = ch;
						append_char(xord[m]);
					}
					fgetc(pool_file); // read and discard new line
					make_string();
			
				}
			}
			#pragma endregion
		} while (!c);
		a_close(pool_file);

		return true;
	}
	else
		bad_pool("! I cannot read tex.pool.", false);
	#pragma endregion

}
#endif
//tini


// 71
void term_input()
{
	int k;
	update_terminal();
	if (!input_ln(term_in, true))
		fatal_error(TEX_STRING("End of file on the terminal!"));
	term_offset = 0;
	decr(selector);
	if (last != first)
		for (k = first; k <= last - 1; k++) print(buffer[k]);
	print_ln(); incr(selector);
}
// 329
void end_file_reading()
{
	first = start; line = line_stack[index];
	if (name > 17) a_close(cur_file);
	pop_input;
	decr(in_open);
}

// 330
void clear_for_error_prompt()
{
	while (state != token_list && terminal_input && input_ptr > 0 && loc > limit)
		end_file_reading();
	print_ln(); clear_terminal();
}


bool a_open_in(FILE **f, int path_specifier)
{
	if (test_access(path_specifier))
		*f = fopen(real_name_of_file.get_c_str(), "r");
	else 
		return false;

	return *f;
}

bool a_open_out(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "w");
	return *f;
}

bool b_open_in(FILE **f)
{
	if (test_access(font_file_path))
		*f = fopen(real_name_of_file.get_c_str(), "rb");
	else
		return false;
	return *f;
}

bool b_open_out(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "wb");
	return *f;
}


bool w_open_in(FILE **f)
{
	if (test_access(format_file_path))
		*f = fopen(real_name_of_file.get_c_str(), "rb");
	else
		return false;
	return *f;
}

bool w_open_out(FILE **f)
{
	*f = fopen(name_of_file.get_c_str(), "wb");
	return *f;
}



void a_close(FILE *f)
{
	fclose(f);
}

void b_close(FILE *f)
{
	fclose(f);
}

void w_close(FILE *f)
{
	fclose(f);
}

// 70
void print_current_string()
{
	pool_pointer j;
	j = str_start[str_ptr];
	while (j < pool_ptr) {
		print_char(so(str_pool[j])); incr(j);
	}
}

// 176
void print_font_and_char(int p)
{
	if (p > mem_end)
		print_esc(TEX_STRING("CLOBBERED."));
	else {
		if (font(p) < font_base || font(p) > font_max)
			print_char(TEX_STRING("*"));
		else 
			#pragma region <Print the font identifier for font(p) 267>
			print_esc(font_id_text(font(p)));
			#pragma endregion
		print_char(TEX_STRING(" ")); print_ASCII(qo(character(p)));
	}
}

void print_mark(int p)
{
	print_char(TEX_STRING("{"));
	if (p < hi_mem_min || p > mem_end) print_esc(TEX_STRING("CLOBBERED."));
	else show_token_list(link(p), null, max_print_line - 10);
	print_char(TEX_STRING("}"));
}

void print_rule_dimen(scaled d)
{
	if (is_running(d)) print_char(TEX_STRING("*"));
	else print_scaled(d);
}


// 92
void normalize_selector()
{
	if (log_opened)
		selector = term_and_log;
	else selector = term_only;
	if (job_name == 0)open_log_file();
	if (interaction == batch_mode)decr(selector);
}

// 93
void fatal_error(str_number s)
{
	normalize_selector();
	print_err(TEX_STRING("Emergency stop"));
	help1(s);
	succumb();
}

// 106
scaled x_over_n(scaled x, int n)
{
	bool negative;
	scaled ret;
	negative = false;
	if (n == 0) {
		arith_error = true;		
		ret = 0;
		_remainder = x;
	}
	else {
		if (n < 0) {
			negate(x); negate(n); negative = true;
		}
		if (x >= 0) {
			ret = x / n; _remainder = x % n;
		}
		else {
			ret = -((-x) / n); _remainder = -((-x) % n);
		}
	}
	if (negative)
		negate(_remainder);
	return ret;
}

// 108
halfword badness(scaled t, scaled s)
{
	int r;
	if (t == 0)
		return 0;
	else if (s <= 0)
		return inf_bad;
	else {
		if (t <= 7230584)
			r = (t * 297) / s;
		else if (s >= 1663497)
			r = t / (s / 297);
		else
			r = t;
		if (r > 1290)
			return inf_bad;
		else
			return (r*r*r + 0400000) / 01000000;
	}
}

// 298
void print_cmd_chr(quarterword cmd, halfword chr_code)
{
	switch (cmd) {
	case left_brace:
		chr_cmd(TEX_STRING("begin-group character "));
		break;
	case right_brace:
		chr_cmd(TEX_STRING("end-group character "));
		break;
	case math_shift:
		chr_cmd(TEX_STRING("math shift character "));
		break;
	case mac_param:
		chr_cmd(TEX_STRING("macro parameter character "));
		break;
	case sup_mark:
		chr_cmd(TEX_STRING("superscript character "));
		break;
	case sub_mark:
		chr_cmd(TEX_STRING("subscript character "));
		break;
	case endv:
		print(TEX_STRING("end of alignment template"));
		break;
	case spacer:
		chr_cmd(TEX_STRING("blank space "));
		break;
	case letter:
		chr_cmd(TEX_STRING("the letter "));
		break;
	case other_char:
		chr_cmd(TEX_STRING("the character "));
		break;
	#pragma region <Cases of print_cmd_chr for symbolic printing of primitives 227>
	case assign_glue:
	case assign_mu_glue:
		if (chr_code < skip_base)
			print_skip_param(chr_code - glue_base);
		else if (chr_code < mu_skip_base) {
			print_esc(TEX_STRING("skip")); print_int(chr_code - skip_base);
		}
		else {
			print_esc(TEX_STRING("muskip")); print_int(chr_code - mu_skip_base);
		}
		break;

	case assign_toks:
		if (chr_code >= toks_base) {
			print_esc(TEX_STRING("toks")); print_int(chr_code - toks_base);
		}
		else switch (chr_code) {
		case output_routine_loc: print_esc(TEX_STRING("output")); break;
		case every_par_loc: print_esc(TEX_STRING("everypar")); break;
		case every_math_loc: print_esc(TEX_STRING("everymath")); break;
		case every_display_loc: print_esc(TEX_STRING("everydisplay")); break;
		case every_hbox_loc: print_esc(TEX_STRING("everyhbox")); break;
		case every_vbox_loc: print_esc(TEX_STRING("everyvbox")); break;
		case every_job_loc: print_esc(TEX_STRING("everyjob")); break;
		case every_cr_loc: print_esc(TEX_STRING("everycr")); break;
		default: print_esc(TEX_STRING("errhelp")); break;
		}
		break;

	case assign_int:
		if (chr_code < count_base) print_param(chr_code - int_base);
		else {
			print_esc(TEX_STRING("count")); print_int(chr_code - count_base);
		}
		break;

	case assign_dimen:
		if (chr_code < scaled_base) print_length_param(chr_code - dimen_base);
		else {
			print_esc(TEX_STRING("dimen")); print_int(chr_code - scaled_base);
		}
		break;

	case accent: print_esc(TEX_STRING("accent")); break;
	case advance: print_esc(TEX_STRING("advance")); break;
	case after_assignment: print_esc(TEX_STRING("afterassignment")); break;
	case after_group: print_esc(TEX_STRING("aftergroup")); break;
	case assign_font_dimen: print_esc(TEX_STRING("fontdimen")); break;
	case begin_group: print_esc(TEX_STRING("begingroup")); break;
	case break_penalty: print_esc(TEX_STRING("penalty")); break;
	case char_num: print_esc(TEX_STRING("char")); break;
	case cs_name: print_esc(TEX_STRING("csname")); break;
	case def_font: print_esc(TEX_STRING("font")); break;
	case delim_num: print_esc(TEX_STRING("delimiter")); break;
	case divide: print_esc(TEX_STRING("divide")); break;
	case end_cs_name: print_esc(TEX_STRING("endcsname")); break;
	case end_group: print_esc(TEX_STRING("endgroup")); break;
	case ex_space: print_esc(TEX_STRING(" ")); break;
	case expand_after: print_esc(TEX_STRING("expandafter")); break;
	case halign: print_esc(TEX_STRING("halign")); break;
	case hrule: print_esc(TEX_STRING("hrule")); break;
	case ignore_spaces: print_esc(TEX_STRING("ignorespaces")); break;
	case insert: print_esc(TEX_STRING("insert")); break;
	case ital_corr: print_esc(TEX_STRING("/")); break;
	case mark: print_esc(TEX_STRING("mark")); break;
	case math_accent: print_esc(TEX_STRING("mathaccent")); break;
	case math_char_num: print_esc(TEX_STRING("mathchar")); break;
	case math_choice: print_esc(TEX_STRING("mathchoice")); break;
	case multiply: print_esc(TEX_STRING("multiply")); break;
	case no_align: print_esc(TEX_STRING("noalign")); break;
	case no_boundary: print_esc(TEX_STRING("noboundary")); break;
	case no_expand: print_esc(TEX_STRING("noexpand")); break;
	case non_script: print_esc(TEX_STRING("nonscript")); break;
	case omit: print_esc(TEX_STRING("omit")); break;
	case radical: print_esc(TEX_STRING("radical")); break;
	case read_to_cs: print_esc(TEX_STRING("read")); break;
	case relax: print_esc(TEX_STRING("relax")); break;
	case set_box: print_esc(TEX_STRING("setbox")); break;
	case set_prev_graf: print_esc(TEX_STRING("prevgraf")); break;
	case set_shape: print_esc(TEX_STRING("parshape")); break;
	case the: print_esc(TEX_STRING("the")); break;
	case toks_register: print_esc(TEX_STRING("toks")); break;
	case vadjust: print_esc(TEX_STRING("vadjust")); break;
	case valign: print_esc(TEX_STRING("valign")); break;
	case vcenter: print_esc(TEX_STRING("vcenter")); break;
	case vrule: print_esc(TEX_STRING("vrule")); break;

	//335
	case par_end: print_esc(TEX_STRING("par")); break;

	//377
	case input:
		if (chr_code == 0) print_esc(TEX_STRING("input"));
		else print_esc(TEX_STRING("endinput"));
		break;

	//385
	case top_bot_mark:
		switch (chr_code) {
		case first_mark_code: print_esc(TEX_STRING("firstmark")); break;
		case bot_mark_code: print_esc(TEX_STRING("botmark")); break;
		case split_first_mark_code: print_esc(TEX_STRING("splitfirstmark")); break;
		case split_bot_mark_code: print_esc(TEX_STRING("splitbotmark")); break;
		default: print_esc(TEX_STRING("topmark")); break;
		}
		break;

	//412
	case _register:
		if (chr_code == int_val) print_esc(TEX_STRING("count"));
		else if(chr_code == dimen_val) print_esc(TEX_STRING("dimen"));
		else if(chr_code == glue_val) print_esc(TEX_STRING("skip"));
		else print_esc(TEX_STRING("muskip"));
		break;

	//417
	case set_aux:
		if (chr_code == vmode) print_esc(TEX_STRING("prevdepth"));
		else print_esc(TEX_STRING("spacefactor"));
		break;
	case set_page_int:
		if (chr_code == 0) print_esc(TEX_STRING("deadcycles"));
		else print_esc(TEX_STRING("insertpenalties"));
		break;
	case set_box_dimen:
		if (chr_code == width_offset) print_esc(TEX_STRING("wd"));
		else if (chr_code == height_offset) print_esc(TEX_STRING("ht"));
		else print_esc(TEX_STRING("dp"));
		break;
	case last_item:
		switch (chr_code) {
		case int_val: print_esc(TEX_STRING("lastpenalty")); break;
		case dimen_val: print_esc(TEX_STRING("lastkern")); break;
		case glue_val: print_esc(TEX_STRING("lastskip")); break;
		case input_line_no_code: print_esc(TEX_STRING("inputlineno")); break;
		default: print_esc(TEX_STRING("badness")); break;
		}
		break;

		//469
	case convert:
		switch (chr_code) {
		case number_code: print_esc(TEX_STRING("number")); break;
		case roman_numeral_code: print_esc(TEX_STRING("romannumeral")); break;
		case string_code: print_esc(TEX_STRING("string")); break;
		case meaning_code: print_esc(TEX_STRING("meaning")); break;
		case font_name_code: print_esc(TEX_STRING("fontname")); break;
		default: print_esc(TEX_STRING("jobname")); break;
		}
		break;

		//488
	case if_test:
		switch (chr_code) {
		case if_cat_code: print_esc(TEX_STRING("ifcat")); break;
		case if_int_code: print_esc(TEX_STRING("ifnum")); break;
		case if_dim_code: print_esc(TEX_STRING("ifdim")); break;
		case if_odd_code: print_esc(TEX_STRING("ifodd")); break;
		case if_vmode_code: print_esc(TEX_STRING("ifvmode")); break;
		case if_hmode_code: print_esc(TEX_STRING("ifhmode")); break;
		case if_mmode_code: print_esc(TEX_STRING("ifmmode")); break;
		case if_inner_code: print_esc(TEX_STRING("ifinner")); break;
		case if_void_code: print_esc(TEX_STRING("ifvoid")); break;
		case if_hbox_code: print_esc(TEX_STRING("ifhbox")); break;
		case if_vbox_code: print_esc(TEX_STRING("ifvbox")); break;
		case ifx_code: print_esc(TEX_STRING("ifx")); break;
		case if_eof_code: print_esc(TEX_STRING("ifeof")); break;
		case if_true_code: print_esc(TEX_STRING("iftrue")); break;
		case if_false_code: print_esc(TEX_STRING("iffalse")); break;
		case if_case_code: print_esc(TEX_STRING("ifcase")); break;
		default: print_esc(TEX_STRING("if")); break;
		}
		break;

		//492
	case fi_or_else:
		if (chr_code == fi_code) print_esc(TEX_STRING("fi"));
		else if (chr_code == or_code) print_esc(TEX_STRING("or"));
		else print_esc(TEX_STRING("else"));
		break;

		//781
	case tab_mark:
		if (chr_code == span_code) print_esc(TEX_STRING("span"));
		else
			chr_cmd(TEX_STRING("alignment tab character "));
		break;
	case car_ret:
		if (chr_code == cr_code) print_esc(TEX_STRING("cr"));
		else print_esc(TEX_STRING("crcr"));
		break;

		//984
	case set_page_dimen:
		switch (chr_code) {
		case 0:print_esc(TEX_STRING("pagegoal")); break;
		case 1:print_esc(TEX_STRING("pagetotal")); break;
		case 2:print_esc(TEX_STRING("pagestretch")); break;
		case 3:print_esc(TEX_STRING("pagefilstretch")); break;
		case 4:print_esc(TEX_STRING("pagefillstretch")); break;
		case 5:print_esc(TEX_STRING("pagefilllstretch")); break;
		case 6:print_esc(TEX_STRING("pageshrink")); break;
		default:print_esc(TEX_STRING("pagedepth")); break;
		}
		break;

		//1053
	case stop:
		if (chr_code == 1) print_esc(TEX_STRING("dump"));
		else print_esc(TEX_STRING("end"));
		break;

		//1059
	case hskip:
		switch (chr_code) {
		case skip_code:print_esc(TEX_STRING("hskip")); break;
		case fil_code:print_esc(TEX_STRING("hfil")); break;
		case fill_code:print_esc(TEX_STRING("hfill")); break;
		case ss_code:print_esc(TEX_STRING("hss")); break;
		default:print_esc(TEX_STRING("hfilneg")); break;
		}
		break;
	case vskip:
		switch (chr_code) {
		case skip_code:print_esc(TEX_STRING("vskip")); break;
		case fil_code:print_esc(TEX_STRING("vfil")); break;
		case fill_code:print_esc(TEX_STRING("vfill")); break;
		case ss_code:print_esc(TEX_STRING("vss")); break;
		default:print_esc(TEX_STRING("vfilneg")); break;
		}
		break;
	case mskip:
		print_esc(TEX_STRING("mskip"));
		break;
	case kern:
		print_esc(TEX_STRING("kern"));
		break;
	case mkern:
		print_esc(TEX_STRING("mkern"));
		break;
		//1072
	case hmove:
		if (chr_code == 1) print_esc(TEX_STRING("moveleft"));
		else print_esc(TEX_STRING("moveright"));
		break;
	case vmove:
		if (chr_code == 1) print_esc(TEX_STRING("raise"));
		else print_esc(TEX_STRING("lower"));
		break;
	case make_box:
		switch (chr_code) {
		case box_code:print_esc(TEX_STRING("box")); break;
		case copy_code:print_esc(TEX_STRING("copy")); break;
		case last_box_code:print_esc(TEX_STRING("lastbox")); break;
		case vsplit_code:print_esc(TEX_STRING("vsplit")); break;
		case vtop_code:print_esc(TEX_STRING("vtop")); break;
		case vtop_code+vmode:print_esc(TEX_STRING("vbox")); break;
		default:print_esc(TEX_STRING("hbox")); break;
		}
		break;
	case leader_ship:
		if (chr_code == a_leaders) print_esc(TEX_STRING("leaders"));
		else if (chr_code == c_leaders) print_esc(TEX_STRING("cleaders"));
		else if (chr_code == x_leaders) print_esc(TEX_STRING("xleaders"));
		else print_esc(TEX_STRING("shipout"));
		break;

		//1089
	case start_par:
		if (chr_code == 0) print_esc(TEX_STRING("noindent"));
		else print_esc(TEX_STRING("indent"));
		break;

		//1108
	case remove_item:
		if (chr_code == glue_node) print_esc(TEX_STRING("unskip"));
		else if (chr_code == kern_node) print_esc(TEX_STRING("unkern"));
		else print_esc(TEX_STRING("unpenalty"));
		break;
	case un_hbox:
		if (chr_code == copy_code) print_esc(TEX_STRING("unhcopy"));
		else print_esc(TEX_STRING("unhbox"));
		break;
	case un_vbox:
		if (chr_code == copy_code) print_esc(TEX_STRING("unvcopy"));
		else print_esc(TEX_STRING("unvbox"));
		break;

		//1115
	case discretionary:
		if (chr_code == 1)print_esc(TEX_STRING("-"));
		else print_esc(TEX_STRING("discretionary"));
		break;

		//1143
	case eq_no:
		if (chr_code == 1) print_esc(TEX_STRING("leqno"));
		else print_esc(TEX_STRING("eqno"));
		break;

		//1157
	case math_comp:
		switch (chr_code) {
		case ord_noad: print_esc(TEX_STRING("mathord")); break;
		case op_noad: print_esc(TEX_STRING("mathop")); break;
		case bin_noad: print_esc(TEX_STRING("mathbin")); break;
		case rel_noad: print_esc(TEX_STRING("mathrel")); break;
		case open_noad: print_esc(TEX_STRING("mathopen")); break;
		case close_noad: print_esc(TEX_STRING("mathclose")); break;
		case punct_noad: print_esc(TEX_STRING("mathpunct")); break;
		case inner_noad: print_esc(TEX_STRING("mathinner")); break;
		case under_noad: print_esc(TEX_STRING("underline")); break;
		default: print_esc(TEX_STRING("overline")); break;
		}
		break;
	case limit_switch:
		if (chr_code == limits) print_esc(TEX_STRING("limits"));
		else if (chr_code == no_limits) print_esc(TEX_STRING("nolimits"));
		else print_esc(TEX_STRING("displaylimits"));
		break;

		//1170
	case math_style:
		print_style(chr_code);
		break;

		//1179
	case above:
		switch (chr_code) {
		case over_code: print_esc(TEX_STRING("over")); break;
		case atop_code: print_esc(TEX_STRING("atop")); break;
		case delimited_code+above_code: print_esc(TEX_STRING("abovewithdelims")); break;
		case delimited_code+over_code: print_esc(TEX_STRING("overwithdelims")); break;
		case delimited_code+atop_code: print_esc(TEX_STRING("atopwithdelims")); break;
		default: print_esc(TEX_STRING("above")); break;
		}
		break;

		//1189
	case left_right:
		if (chr_code == left_noad) print_esc(TEX_STRING("left"));
		else print_esc(TEX_STRING("right"));
		break;

		//1209
	case prefix:
		if (chr_code == 1) print_esc(TEX_STRING("long"));
		else if (chr_code == 2) print_esc(TEX_STRING("outer"));
		else print_esc(TEX_STRING("global"));
		break;
	case def: 
		if (chr_code == 0) print_esc(TEX_STRING("def"));
		else if (chr_code == 1) print_esc(TEX_STRING("gdef"));
		else if (chr_code == 2) print_esc(TEX_STRING("edef"));
		else print_esc(TEX_STRING("xdef"));
		break;

		//1220
	case let:
		if (chr_code != normal) print_esc(TEX_STRING("futurelet"));
		else print_esc(TEX_STRING("let"));
		break;


		//1223
	case shorthand_def:
		switch (chr_code) {
		case char_def_code: print_esc(TEX_STRING("chardef")); break;
		case math_char_def_code: print_esc(TEX_STRING("mathchardef")); break;
		case count_def_code: print_esc(TEX_STRING("countdef")); break;
		case dimen_def_code: print_esc(TEX_STRING("dimendef")); break;
		case skip_def_code: print_esc(TEX_STRING("skipdef")); break;
		case mu_skip_def_code: print_esc(TEX_STRING("muskipdef")); break;
		default: print_esc(TEX_STRING("toksdef")); break;
		}
		break;
	case char_given:
		print_esc(TEX_STRING("char")); print_hex(chr_code);
		break;
	case math_given:
		print_esc(TEX_STRING("mathchar")); print_hex(chr_code);
		break;

		//1231
	case def_code:
		if (chr_code == cat_code_base) print_esc(TEX_STRING("catcode"));
		else if (chr_code == math_code_base) print_esc(TEX_STRING("mathcode"));
		else if (chr_code == lc_code_base) print_esc(TEX_STRING("lccode"));
		else if (chr_code == uc_code_base) print_esc(TEX_STRING("uccode"));
		else if (chr_code == sf_code_base) print_esc(TEX_STRING("sfcode"));
		else  print_esc(TEX_STRING("delcode"));
		break;
	case def_family:
		print_size(chr_code - math_font_base);
		break;

		//1251
	case hyph_data:
		if (chr_code == 1) print_esc(TEX_STRING("patterns"));
		else print_esc(TEX_STRING("hyphenation"));
		break;

		//1255
	case assign_font_int:
		if (chr_code == 0) print_esc(TEX_STRING("hyphenchar"));
		else print_esc(TEX_STRING("skewchar"));
		break;

		//1261
	case set_font:
		print(TEX_STRING("select font "));
		slow_print(font_name[chr_code]);
		if (font_size[chr_code] != font_dsize[chr_code]) {
			print(TEX_STRING(" at ")); print_scaled(font_size[chr_code]);
			print(TEX_STRING("pt"));
		}
		break;

		//1263
	case set_interaction:
		switch (chr_code) {
		case batch_mode: print_esc(TEX_STRING("batchmode")); break;
		case nonstop_mode: print_esc(TEX_STRING("nonstopmode")); break;
		case scroll_mode: print_esc(TEX_STRING("scrollmode")); break;
		default: print_esc(TEX_STRING("errorstopmode")); break;
		}
		break;

		// 1273
	case in_stream:
		if (chr_code == 0) print_esc(TEX_STRING("closein"));
		else print_esc(TEX_STRING("openin"));
		break;

		//1278
	case message:
		if (chr_code == 0) print_esc(TEX_STRING("message"));
		else print_esc(TEX_STRING("errmessage"));
		break;

		//1287
	case case_shift:
		if (chr_code == lc_code_base) print_esc(TEX_STRING("lowercase"));
		else print_esc(TEX_STRING("uppercase"));
		break;

		//1292
	case xray:
		switch (chr_code) {
		case show_box_code: print_esc(TEX_STRING("showbox")); break;
		case show_the_code: print_esc(TEX_STRING("showthe")); break;
		case show_lists: print_esc(TEX_STRING("showlists")); break;
		default: print_esc(TEX_STRING("show")); break;
		}
		break;

		//1295
	case undefined_cs: print(TEX_STRING("undefined")); break;
	case call: print(TEX_STRING("macro")); break;
	case long_call: print_esc(TEX_STRING("long macro")); break;
	case outer_call: print_esc(TEX_STRING("outer macro")); break;
	case long_outer_call: 
		print_esc(TEX_STRING("long"));
		print_esc(TEX_STRING("outer macro"));
		break;
	case end_template: print_esc(TEX_STRING("outer endtemplate")); break;

		//1346
	case extension:
		switch (chr_code) {
		case open_node: print_esc(TEX_STRING("openout")); break;
		case write_node: print_esc(TEX_STRING("write")); break;
		case close_node: print_esc(TEX_STRING("closeout")); break;
		case special_node: print_esc(TEX_STRING("special")); break;
		case immediate_code: print_esc(TEX_STRING("immediate")); break;
		case set_language_code: print_esc(TEX_STRING("setlanguage")); break;
		default: print(TEX_STRING("[unknown extension!]")); break;
		}
		break;



#pragma endregion

	default:
		print(TEX_STRING("[unknown command code!]"));
		break;
	}
}

// 341
void get_next()
{
	int k;
	halfword t;
	unsigned int cat;
	ASCII_code c, cc;
	unsigned char d;

restart:
	cur_cs = 0;
	if (state != token_list)
		#pragma region <Input from external file, goto restart if no input found 343>
	{
	_switch:
		if (loc <= limit) {
			cur_chr = buffer[loc]; incr(loc);
		reswitch:
			cur_cmd = (eight_bits)cat_code(cur_chr);
			#pragma region <Change state if necessary and goto switch if the current character shoudl be ignored, or goto reswtich if the current character changes to another 344>
			switch (state + cur_cmd) {
			#pragma region <cases where character is ignored 345>
			case any_state_plus(ignore):
			case skip_blanks + spacer:
			case new_line + spacer:
			#pragma endregion
				goto _switch;
				break;
			case any_state_plus(escape):
				#pragma region <Scan a control sequence and set state to skip_blanks or mid line 354>
				if (loc > limit)
					cur_cs = null_cs;
				else {
				start_cs:
					k = loc; cur_chr = buffer[k]; cat = cat_code(cur_chr); incr(k);
					if (cat == letter)
						state = skip_blanks;
					else if (cat == spacer)
						state = skip_blanks;
					else
						state = mid_line;
					if (cat == letter && k <= limit) 
						#pragma region <Scan ahead in the buffer until finding a nonletter; .. 356>
					{
						do {
							cur_chr = buffer[k]; cat = cat_code(cur_chr); incr(k);
						} while (!(cat != letter || k > limit));

						#pragma region <If an expanded code is present, reduce it and goto start_cs 355>
						if (buffer[k] == cur_chr)
							if (cat == sup_mark) 
								if (k < limit) {
									c = buffer[k + 1];
									if (c < 0200) {
										d = 2;
										if (is_hex(c)) 
											if (k + 2 <= limit) {
												cc = buffer[k + 2];
												if (is_hex(cc))
													incr(d);
											}
										
										if (d > 2) {
											hex_to_cur_chr;
											buffer[k - 1] = (unsigned char)cur_chr;
										}
										else if (c < 0100)
											buffer[k - 1] = c + 0100;
										else
											buffer[k - 1] = c - 0100;

										limit = limit - d; first = first - d;
										while (k <= limit) {
											buffer[k] = buffer[k + d]; incr(k);
										}
										goto start_cs;
									}
								}
						#pragma endregion

						if (cat != letter)
							decr(k);
						if (k > loc + 1) {
							cur_cs = id_lookup(loc, k - loc); loc = k; goto found;
						}
					}
						#pragma endregion
					else 
						#pragma region <If an expanded code is present, reduce it and goto start_cs 355>
					{

						if (buffer[k] == cur_chr)
							if (cat == sup_mark)
								if (k < limit) {
									c = buffer[k + 1];
									if (c < 0200) {
										d = 2;
										if (is_hex(c))
											if (k + 2 <= limit) {
												cc = buffer[k + 2];
												if (is_hex(cc))
													incr(d);
											}

										if (d > 2) {
											hex_to_cur_chr;
											buffer[k - 1] = (unsigned char)cur_chr;
										}
										else if (c < 0100)
											buffer[k - 1] = c + 0100;
										else
											buffer[k - 1] = c - 0100;

										limit = limit - d; first = first - d;
										while (k <= limit) {
											buffer[k] = buffer[k + d]; incr(k);
										}
										goto start_cs;
									}
								}

					}
						#pragma endregion

					cur_cs = single_base + buffer[loc]; incr(loc);
				}
			found:
				cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				if (cur_cmd >= outer_call)
					check_outer_validity();
				#pragma endregion
				break;
			case any_state_plus(active_char):
				#pragma region <Process an active-character control sequence and set state to mid line 353>
				cur_cs = cur_chr + active_base; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				state = mid_line;
				if (cur_cmd >= outer_call) check_outer_validity();
				#pragma endregion
				break;
			case any_state_plus(sup_mark):
				#pragma region <If this sup_mark starts an expanded character like ^^A or ^^df then goto reswitch, otherwwise set state to mid line 352>
				if(cur_chr == buffer[loc])
					if (loc < limit) {
						c = buffer[loc + 1]; 
						if (c < 0200) {
							loc += 2;
							if(is_hex(c))
								if (loc <= limit) {
									cc = buffer[loc];
									if (is_hex(cc)) {
										incr(loc); hex_to_cur_chr;
										goto reswitch;
									}									
								}
							if (c < 0100) cur_chr = c + 0100;
							else cur_chr = c - 0100;
							goto reswitch;
						}
					}
				state = mid_line;
				#pragma endregion
				break;
			case any_state_plus(invalid_char):
				#pragma region <Decry the invalid character and goto restart 346>
				print_err(TEX_STRING("Text line contains an invalid character"));
				help2(TEX_STRING("A funny symbol that I can't read has just been input."),
					TEX_STRING("Continue, and I'll forget that it ever happened."));
				deletions_allowed = false; error(); deletions_allowed = true;
				goto restart;

				#pragma endregion
				break;

			#pragma region <Handle situations involving spaces, braces, changes of state 347>
			case mid_line+spacer:
				//<Enter skip_blanks state, emit a space 349>
				state = skip_blanks; cur_chr = TEX_STRING(" ");
				break;
			case mid_line + car_ret:
				//<Finish line, emit a spcae 348>
				loc = limit + 1; cur_cmd = spacer; cur_chr = TEX_STRING(" ");
				break;
			case skip_blanks+car_ret:
			case any_state_plus(comment):
				//<Finish line, goto switch 350>
				loc = limit + 1;
				goto _switch;
				break;
			case new_line+car_ret:
				//<Finish line, emit a \par 351>
				loc = limit + 1; cur_cs = par_loc; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				if (cur_cmd >= outer_call)
					check_outer_validity();
				break;
			case mid_line+left_brace:
				incr(align_state);
				break;
			case skip_blanks+left_brace:
			case new_line+left_brace:
				state = mid_line; incr(align_state);
				break;
			case mid_line+right_brace:
				decr(align_state);
				break;
			case skip_blanks+right_brace:
			case new_line+right_brace:
				state = mid_line; decr(align_state);
				break;
			case add_delims_to(skip_blanks):
			case add_delims_to(new_line):
				state = mid_line;
				break;

			#pragma endregion

			}
			#pragma endregion
		}
		else {
			state = new_line;
			#pragma region <Move to next line of file or goto restart if there is no next linek or return if a read line has finished 360>
			if (name > 17)
				#pragma region <Read next line of file into buffer, or goto restart if the file has ended 362>
			{
				incr(line); first = start;
				if (!force_eof) {
					if (input_ln(cur_file, true))
						firm_up_the_line();
					else force_eof = true;
				}
				if (force_eof) {
					print_char(TEX_STRING(")")); decr(open_parens); update_terminal();
					force_eof = false; end_file_reading();
					check_outer_validity(); goto restart;
				}
				if (end_line_char_inactive) decr(limit);
				else buffer[limit] = end_line_char;
				first = limit + 1; loc = start;
			}
				#pragma endregion
			else {
				if (!terminal_input) {
					cur_cmd = 0; cur_chr = 0; return;
				}
				if (input_ptr > 0) {
					end_file_reading(); goto restart;
				}
				if (selector < log_only) open_log_file();
				if (interaction > nonstop_mode) {
					if (end_line_char_inactive) incr(limit);
					if (limit == start)
						print_nl(TEX_STRING("(Please type a command or say `\end')"));
					print_ln(); first = start; prompt_input(TEX_STRING("*"));
					limit = last;
					if (end_line_char_inactive) decr(limit);
					else buffer[limit] = end_line_char;
					first = limit + 1; loc = start;
				}
				else fatal_error(TEX_STRING("*** (job aborted, no legal \end found)"));
			}

			#pragma endregion
			check_interrupt;
			goto _switch;
		}
	}
		#pragma endregion
	else
		#pragma region <Input from token list, goto restart if end of list or if a parameter needs to be expanded 357>
	{
		
		if (loc != null) {
			t = info(loc); loc = link(loc);
			if (t >= cs_token_flag) {
				cur_cs = t - cs_token_flag; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
				if (cur_cmd >= outer_call)
					if (cur_cmd == dont_expand)
						#pragma region <Get the next token, suppressing expansion 358>
					{						
						cur_cs = info(loc) - cs_token_flag; loc = null;
						cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs);
						if (cur_cmd > max_command) {
							cur_cmd = relax; cur_chr = no_expand_flag;
						}
					}
						#pragma endregion
					else check_outer_validity();
			}
			else {
				cur_cmd = t / 0400; cur_chr = t % 0400;
				switch (cur_cmd) {
				case left_brace: incr(align_state); break;
				case right_brace: decr(align_state); break;
				case out_param:
					#pragma region <Insert macro parameter and goto restart 359>
					begin_token_list(param_stack[param_start + cur_chr - 1], parameter);
					goto restart;
					#pragma endregion
					break;
				default:
					//do_nothing
					break;
				}
			}
		}
		else {
			end_token_list();
			goto restart;
		}
	}
		#pragma endregion
	
	#pragma region <If an alignment entry has just ended take appropriate action 342>
	if(cur_cmd <= car_ret)
		if(cur_cmd >= tab_mark)
			if (align_state == 0) 
				#pragma region <Insert the <v_j> template and goto restart 789>
			{
				
				if (scanner_status == aligning || cur_align == null)
					fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
				cur_cmd = (eight_bits)extra_info(cur_align); extra_info(cur_align) = cur_chr;
				if (cur_cmd == omit) begin_token_list(omit_template, v_template);
				else begin_token_list(v_part(cur_align), v_template);
				align_state = 1000000;
				goto restart;
			}
				#pragma endregion
	#pragma endregion

}


// 365
void get_token()
{
	no_new_control_sequence = false;
	get_next();
	no_new_control_sequence = true;
	if (cur_cs == 0)
		cur_tok = (cur_cmd * 0400) + cur_chr;
	else
		cur_tok = cs_token_flag + cur_cs;
}

// 95
void confusion(str_number s)
{
	normalize_selector();
	if (history < error_message_issued)
	{
		print_err(TEX_STRING("This can't happen (")); print(s); 
		print_char(TEX_STRING(")"));
		help1(TEX_STRING("I'm broken. Please show this to someone who can fix can fix"));
	}
	else {
		print_err(TEX_STRING("I can't go on meeting you like this"));
		help2(TEX_STRING("One of your faux pas seems to have wounded me deeply..."),
			TEX_STRING("in fact, I'm barely conscious. Please fix it and try again."));
	}
	succumb();
}

// 123
void flush_list(pointer p)
{
	pointer q, r;
	if (p != null) {
		r = p;
		do {
			q = r; r = link(r);
			//stat
#ifndef NO_STAT
			decr(dyn_used);
#endif
			//tats

		} while (r != null);
		link(q) = avail; avail = p;
	}
}

// 130
void free_node(pointer p, halfword s)
{
	pointer q;
	node_size(p) = s;
	link(p) = empty_flag;
	q = llink(rover);
	llink(p) = q; rlink(p) = rover;
	llink(rover) = p; rlink(q) = p;
	//stat
#ifndef NO_STAT
	var_used -= s;
#endif
	//tats

}

// 154
pointer new_skip_param(small_number n)
{
	pointer p;
	temp_ptr = new_spec(/*<Current mem equiv... 224*/glue_par(n));
	p = new_glue(temp_ptr); glue_ref_count(temp_ptr) = null; subtype(p) = n + 1;
	return p;
}


// 200
void delete_token_ref(pointer p)
{
	if (token_ref_count(p) == null)
		flush_list(p);
	else decr(token_ref_count(p));
}

// 201
void delete_glue_ref(pointer p)
{
	fast_delete_glue_ref(p);
}

// 202
void flush_node_list(pointer p)
{
	pointer q;
	while (p != null) {
		q = link(p);
		if (is_char_node(p))
			free_avail(p);
		else {
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case unset_node:
				flush_node_list(list_ptr(p));
				free_node(p, box_node_size);
				goto done;
				break;

			case rule_node:
				free_node(p, rule_node_size);
				goto done;
				break;

			case ins_node:
				flush_node_list(ins_ptr(p)); delete_glue_ref(split_top_ptr(p));
				free_node(p, ins_node_size);
				goto done;
				break;
			case whatsit_node:
				#pragma region <Wipe out the whatsit node p and goto done 1358>
				switch (subtype(p)) {
				case open_node:
					free_node(p, open_node_size);
					break;
				case write_node:
				case special_node:
					delete_token_ref(write_tokens(p));
					free_node(p, write_node_size);
					goto done;
					break;
				case close_node:
				case language_node:
					free_node(p, small_node_size);
					break;
				default:
					confusion(TEX_STRING("ext3"));
					break;
				}
				goto done;
				#pragma endregion
				break;
			case glue_node:
				fast_delete_glue_ref(glue_ptr(p));
				if (leader_ptr(p) != null)
					flush_node_list(leader_ptr(p));
				break;
			case kern_node:
			case math_node:
			case penalty_node:
				break;
			case ligature_node:
				flush_node_list(lig_ptr(p));
				break;
			case mark_node:
				delete_token_ref(mark_ptr(p));
				break;
			case disc_node:
				flush_node_list(pre_break(p)); flush_node_list(post_break(p));
				break;
			case adjust_node:
				flush_node_list(adjust_ptr(p));
				break;
			#pragma region <Cases of flush_node_list that arise in mlists only 698>
			case style_node:
				free_node(p, style_node_size);
				goto done;
				break;
			case choice_node:
				flush_node_list(display_mlist(p)); flush_node_list(text_mlist(p));
				flush_node_list(script_mlist(p)); flush_node_list(script_script_mlist(p));
				free_node(p, style_node_size);
				goto done;
				break;

			case ord_noad:
			case op_noad:
			case bin_noad:
			case rel_noad:
			case open_noad:
			case close_noad:
			case punct_noad:
			case inner_noad:
			case radical_noad:
			case over_noad:
			case under_noad:
			case vcenter_noad:
			case accent_noad:
				if (math_type(nucleus(p)) >= sub_box) flush_node_list(info(nucleus(p)));
				if (math_type(supscr(p)) >= sub_box) flush_node_list(info(supscr(p)));
				if (math_type(subscr(p)) >= sub_box) flush_node_list(info(subscr(p)));
				if (type(p) == radical_noad) free_node(p, radical_noad_size);
				else if (type(p) == accent_noad) free_node(p, accent_noad_size);
				else free_node(p, noad_size);
				goto done;
				break;
			case left_noad:
			case right_noad:
				free_node(p, noad_size);
				goto done;
				break;
			case fraction_noad:
				flush_node_list(info(numerator(p))); flush_node_list(info(denominator(p)));
				free_node(p, fraction_noad_size);
				goto done;
				break;
			#pragma endregion

			default:
				confusion(TEX_STRING("flushing"));
				break;
			}
			free_node(p, small_node_size);
		done:
			;
		}

		p = q;
	}
}

// 120
pointer get_avail()
{
	pointer p;
	p = avail;
	if (p != null) avail = link(avail);
	else if (mem_end < mem_max) {
		incr(mem_end); p = mem_end;
	}
	else {
		decr(hi_mem_min); p = hi_mem_min;
		if (hi_mem_min <= lo_mem_max) {
			runaway();
			overflow(TEX_STRING("main memory size"), mem_max + 1 - mem_min);
		}
	}
	link(p) = null;
	//stat
#ifndef NO_STAT
	incr(dyn_used);
#endif
	//tats

	return p;
}

// 121
void free_avail(pointer s)
{
	link(s) = avail; 
	avail = s;
	/*stat*/
#ifndef NO_STAT
	decr(dyn_used);
#endif
	/*tats*/ 
}
// 93
void succumb()
{
	if(interaction == error_stop_mode)
		interaction = scroll_mode;
	if(log_opened)
		error();
//debug
#ifndef NO_DEBUG
	if(interaction > batch_mode)
		debug_help();
#endif
//gubed
	history = fatal_error_stop;
	jump_out();
}

// 98
void pause_for_instructions()
{
	if (OK_to_interrupt) {
		interaction = error_stop_mode;
		if (selector == log_only || selector == no_print)
			incr(selector);
		print_err(TEX_STRING("Interruption"));
		help3(TEX_STRING("You rang?"),
			TEX_STRING("Try to insert some instructions for me (e.g.,`I\showlists'),"),
			TEX_STRING("unless you just want to quit by typing `X'."));
		deletions_allowed = false;
		error();
		deletions_allowed = true;
		interrupt = 0;
	}
}


// 144
pointer new_ligature(quarterword f, quarterword c, pointer q)
{
	pointer p;
	p = get_node(small_node_size); type(p) = ligature_node; font(lig_char(p)) = f;
	character(lig_char(p)) = c; lig_ptr(p) = q; subtype(p) = 0;
	return p;
}

pointer new_lig_item(quarterword c)
{
	pointer p;
	p = get_node(small_node_size); character(p) = c; lig_ptr(p) = null;
	return p;
}

// 145
pointer new_disc()
{
	pointer p;
	p = get_node(small_node_size); type(p) = disc_node; replace_count(p) = 0; pre_break(p) = null;
	post_break(p) = null;
	return p;
}

pointer new_rule()
{
	pointer p;

	p = get_node(rule_node_size);
	type(p) = rule_node; subtype(p) = 0;
	width(p) = null_flag; depth(p) = null_flag; height(p) = null_flag;
	return p;
}

// 263
void sprint_cs(pointer p)
{
	if (p < hash_base) {
		if (p < single_base)
			print(p - active_base);
		else if (p < null_cs)
			print_esc(p - single_base);
		else {
			print_esc(TEX_STRING("csname"));
			print_esc(TEX_STRING("endcsname"));
		}
	}
	else
		print_esc(text(p));
}


// 306
void runaway()
{
	pointer p;
	if (scanner_status > skipping) {
		print_nl(TEX_STRING("Runaway "));
		switch (scanner_status) {
		case defining:
			print(TEX_STRING("definition"));
			p = def_ref;
			break;
		case matching:
			print(TEX_STRING("argument"));
			p = temp_head;
			break;
		case aligning:
			print(TEX_STRING("preamble"));
			p = hold_head;
			break;
		case absorbing:
			print(TEX_STRING("text"));
			p = def_ref;
			break;
		}
		print_char(TEX_STRING("?"));
		print_ln();
		show_token_list(link(p), null, error_line - 10);
	}
}

// 336
void check_outer_validity()
{
	pointer p, q;

	if (scanner_status != normal) {
		deletions_allowed = false;
		#pragma region <Back up an outer control sequence so that it can be reread 337>
		if (cur_cs != 0) {
			if (state == token_list || name < 1 || name >17) {
				p = get_avail(); info(p) = cs_token_flag + cur_cs; back_list(p);
			}
			cur_cmd = spacer; cur_chr = TEX_STRING(" ");
		}
		#pragma endregion

		if (scanner_status > skipping) 
			#pragma region <Tell the user what has run away and try to recover 338>
		{
			runaway();
			if (cur_cs == 0) print_err(TEX_STRING("File ended"));
			else {
				cur_cs = 0; print_err(TEX_STRING("Forbidden control sequence found"));
			}
			print(TEX_STRING(" while scanning "));
			#pragma region <Print either definition or use or preamble or text, and insert tokens that should lead to recovery 339>
			p = get_avail();
			switch (scanner_status) {
			case defining: 
				print(TEX_STRING("definition"));
				info(p) = right_brace_token + TEX_STRING("}");
				break;
			case matching:
				print(TEX_STRING("use"));
				info(p) = par_token; long_state = outer_call;
				break;
			case aligning:
				print(TEX_STRING("preamble"));
				info(p) = right_brace_token + TEX_STRING("}");
				q = p; p = get_avail();
				link(p) = q; info(p) = cs_token_flag + frozen_cr; align_state = -1000000;
				break;
			case absorbing:
				print(TEX_STRING("text")); 
				info(p) = right_brace_token + TEX_STRING("}");
				break;
			}
			ins_list(p);
			#pragma endregion

			print(TEX_STRING(" of ")); sprint_cs(warning_index);
			help4(TEX_STRING("I suspect you have forgotten a `}', causing me"),
				TEX_STRING("to read past where you wanted me to stop."),
				TEX_STRING("I'll try to recover; but if the error is serious,"),
				TEX_STRING("you'd better type `E' or `X' now and fix your file."));
			error();
		}
			#pragma endregion
		else {
			print_err(TEX_STRING("Incomplete ")); print_cmd_chr(if_test, cur_if);
			print(TEX_STRING("; all text was ignored after line ")); print_int(skip_line);
			help3(TEX_STRING("A forbidden control sequence occurred in skipped text."),
				TEX_STRING("This kind of error happens when you say `\if...' and forget"),
				TEX_STRING("the matching `\fi'. I've inserted a `\fi'; this might work."));
			if (cur_cs != 0)
				cur_cs = 0;
			else
				help_line[2] = TEX_STRING("The file ended while I was skipping conditional text.");
			cur_tok = cs_token_flag + frozen_fi; ins_error();
		}
		deletions_allowed = true;
	}
}

// 325
void back_input()
{
	pointer p;
	while (state == token_list && loc == null && token_type != v_template)
		end_token_list();
	p = get_avail(); info(p) = cur_tok;
	if (cur_tok < right_brace_limit)
		if (cur_tok < left_brace_limit)
			decr(align_state);
		else
			incr(align_state);
	push_input;
	state = token_list;
	start = p; token_type = backed_up; loc = p;
}

// 107
scaled xn_over_d(scaled x, int n, int d)
{
	bool positive;
	nonnegative_integer t, u, v;
	if (x >= 0)
		positive = true;
	else {
		negate(x); positive = false;
	}
	t = (x % 0100000)*n;
	u = (x / 0100000)*n + (t / 0100000);
	v = (u%d) * 0100000 + (t % 0100000);
	if (u / d >= 0100000)
		arith_error = true;
	else
		u = 0100000 * (u / d) + (v / d);
	if (positive) {
		_remainder = v % d;
		return u;
	}
	else {
		_remainder = -(v % d);
		return -u;
	}
}

// 125
pointer get_node(int s)
{
	pointer p;
	pointer q;
	int r;
	int t;
restart:
	p = rover;
	do {
		#pragma region <Try to allocate within node p and its physical successors and goto found if possible 127>
		q = p + node_size(p);
		while (is_empty(q)) {
			t = rlink(q);
			if (q == rover) rover = t;
			llink(t) = llink(q); rlink(llink(q)) = t;
			q = q + node_size(q);
		}
		r = q - s;
		if (r > p + 1) 
			#pragma region <Allocate from the top of node p and goto found 128>
		{
			node_size(p) = r - p;
			rover = p;
			goto found;
		}
			#pragma endregion

		if (r == p)
			if (rlink(p) != p) 
				#pragma region <Allocate entire node p and goto found 129>
			{
				rover = rlink(p); t = llink(p); llink(rover) = t; rlink(t) = rover;
				goto found;
			}
				#pragma endregion
		node_size(p) = q - p;
		#pragma endregion
		p = rlink(p);
	} while (!(p == rover));

	if (s == 010000000000) {
		return max_halfword;
	}

	if (lo_mem_max + 2 < hi_mem_min)
		if (lo_mem_max + 2 <= mem_bot + max_halfword) 
			#pragma region <Grow more variable-size memory and goto restart 126>
		{
			if (hi_mem_min - lo_mem_max >= 1998)
				t = lo_mem_max + 1000;
			else
				t = lo_mem_max + 1 + (hi_mem_min - lo_mem_max) / 2;
			p = llink(rover); q = lo_mem_max; rlink(p) = q; llink(rover) = q;
			if (t > mem_bot + max_halfword)
				t = mem_bot + max_halfword;
			rlink(q) = rover; llink(q) = p; link(q) = empty_flag; node_size(q) = t - lo_mem_max;
			lo_mem_max = t; link(lo_mem_max) = null; info(lo_mem_max) = null; rover = q;
			goto restart;
		}
			#pragma endregion

	overflow(TEX_STRING("main memory size"), mem_max + 1 - mem_min);
found:
	link(r) = null;
	//stat
#ifndef NO_STAT
	var_used = var_used + s;
#endif
	//tats

	return r;
}

// 151
pointer new_spec(pointer p)
{
	pointer q;
	q = get_node(glue_spec_size);
	mem[q] = mem[p]; glue_ref_count(q) = null;
	width(q) = width(p); stretch(q) = stretch(p); shrink(q) = shrink(p); 
	return q;
}



// 152
pointer new_param_glue(small_number n)
{
	pointer p;
	pointer q;
	p = get_node(small_node_size); type(p) = glue_node;
	subtype(p) = n + 1; leader_ptr(p) = null;
	q = 
		#pragma region <Current mem quivalent of glue parameter n 224>
		glue_par(n);
		#pragma endregion

	glue_ptr(p) = q;
	incr(glue_ref_count(q));
	return p;

}

// 153
pointer new_glue(pointer q)
{
	pointer p;
	p = get_node(small_node_size); type(p) = glue_node;
	subtype(p) = normal;
	leader_ptr(p) = null; glue_ptr(p) = q; incr(glue_ref_count(q));
	return p;
}

// 158
pointer new_penalty(int m)
{
	pointer p;
	p = get_node(small_node_size); type(p) = penalty_node;
	subtype(p) = 0;
	penalty(p) = m;
	return p;
}

// 327
void back_error()
{
	OK_to_interrupt = false;
	back_input();
	OK_to_interrupt = true;
	error();
}

void ins_error()
{
	OK_to_interrupt = false;
	back_input();
	token_type = inserted;
	OK_to_interrupt = true;
	error();
}

// 328

void begin_file_reading()
{
	if (in_open == max_in_open)
		overflow(TEX_STRING("text input levels"), max_in_open);
	if (first == buf_size)
		overflow(TEX_STRING("buffer size"), buf_size);
	incr(in_open); push_input; index = (enum_token_type)in_open; line_stack[index] = line;
	start = first; state = mid_line;
	name = 0;
}

// 182
void show_node_list(int p)
{
	int n;
	float g;
	if (cur_length > depth_threshold) {
		if (p > null)
			print(TEX_STRING(" []"));
		return;
	}
	n = 0;
	while (p > mem_min) {
		print_ln(); print_current_string();
		if (p > mem_end) {
			print(TEX_STRING("Bad link, display aborted."));
			return;
		}
		incr(n);
		if (n > breadth_max) {
			print(TEX_STRING("etc."));
			return;
		}
		#pragma region <Display node p 183>
		if (is_char_node(p))
			print_font_and_char(p);
		else
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case unset_node:
				#pragma region <Display box p 184>
				if (type(p) == hlist_node) print_esc(TEX_STRING("h"));
				else if (type(p) == vlist_node) print_esc(TEX_STRING("v"));
				else print_esc(TEX_STRING("unset"));
				print(TEX_STRING("box("));
				print_scaled(height(p));
				print_char(TEX_STRING("+"));
				print_scaled(depth(p));
				print(TEX_STRING(")x"));
				print_scaled(width(p));
				if (type(p) == unset_node) 
					#pragma region <Display special fields of the unset node p 185>
				{
					if (span_count(p) != min_quarterword) {
						print(TEX_STRING(" ("));
						print_int(qo(span_count(p))+1);
						print(TEX_STRING(" columns)"));
					}
					if (glue_stretch(p) != 0) {
						print(TEX_STRING(", stretch ")); print_glue(glue_stretch(p), glue_order(p), 0);
					}
					if (glue_shrink(p) != 0) {
						print(TEX_STRING(", shrink ")); print_glue(glue_shrink(p), glue_sign(p), 0);
					}
				}
					#pragma endregion
				else {
					#pragma region <Display the value of glue_set(p) 186>
					g = _float(glue_set(p));
					if (g != 0.0f && glue_sign(p) != normal) {
						print(TEX_STRING(", glue set "));
						if (glue_sign(p) == shrinking) print(TEX_STRING("- "));
						if (myabs(mem[p + glue_offset].an_int) < 04000000)
							print(TEX_STRING("?.?"));
						else if (myabs(g) > 20000.0f) {
							if (g > 0.0f) print_char(TEX_STRING(">"));
							else print(TEX_STRING("< -"));
							print_glue(20000 * unity, glue_order(p), 0);
						}
						else {
							// Check for overflow
							float ftemp = round(unity*g);
							if(ftemp > 2147483583 || ftemp < -2147483583) {
								printf("Overflow in 186.\n");
								exit(1);
							}
							/////////////////////////
							
							print_glue((scaled)ftemp, glue_order(p), 0);
						}
					}
					#pragma endregion
					if (shift_amount(p) != 0) {
						print(TEX_STRING(", shifted ")); print_scaled(shift_amount(p));
					}
				}
				node_list_display(list_ptr(p));
				#pragma endregion
				break;
			case rule_node:
				#pragma region <Display rule p 187>
				print_esc(TEX_STRING("rule("));
				print_rule_dimen(height(p));
				print_char(TEX_STRING("+"));
				print_rule_dimen(depth(p));
				print(TEX_STRING(")x"));
				print_rule_dimen(width(p));
				#pragma endregion
				break;
			case ins_node:
				#pragma region <Display insertions p 188>
				print_esc(TEX_STRING("insert"));
				print_int(qo(subtype(p)));
				print(TEX_STRING(", natural size "));
				print_scaled(height(p));
				print(TEX_STRING("; split("));
				print_spec(split_top_ptr(p), 0);
				print_char(TEX_STRING(","));
				print_scaled(depth(p));
				print(TEX_STRING("); float cost "));
				print_int(float_cost(p));
				node_list_display(ins_ptr(p));
				#pragma endregion
				break;
			case whatsit_node:
				#pragma region <Display the whatsit node p 1356>
				switch (subtype(p)) {
				case open_node:
					print_write_whatsit(TEX_STRING("openout"), p);
					print_char(TEX_STRING("="));
					print_file_name(open_name(p), open_area(p), open_ext(p));
					break;
				case write_node:
					print_write_whatsit(TEX_STRING("write"), p); print_mark(write_tokens(p));
					break;
				case close_node:
					print_write_whatsit(TEX_STRING("closeout"), p);
					break;
				case special_node:
					print_esc(TEX_STRING("special")); print_mark(write_tokens(p));
					break;
				case language_node:
					print_esc(TEX_STRING("setlanguage")); print_int(what_lang(p));
					print(TEX_STRING(" (hyphenmin "));
					print_int(what_lhm(p)); print_char(TEX_STRING(","));
					print_int(what_rhm(p)); print_char(TEX_STRING(")"));
					break;
				default:
					print(TEX_STRING("whatsit?"));
					break;
				}
				#pragma endregion
				break;
			case glue_node:
				#pragma region <Display glue p 189>
				if (subtype(p) >= a_leaders) 
					#pragma region <Display leaders p 190>
				{
					print_esc(TEX_STRING(""));
					if (subtype(p) == c_leaders) print_char(TEX_STRING("c"));
					else if (subtype(p) == x_leaders) print_char(TEX_STRING("x"));
					print(TEX_STRING("leaders "));
					print_spec(glue_ptr(p), 0); node_list_display(leader_ptr(p));
				}
					#pragma endregion
				else {
					print_esc(TEX_STRING("glue"));
					if (subtype(p) != normal) {
						print_char(TEX_STRING("("));
						if (subtype(p) < cond_math_glue) print_skip_param(subtype(p) - 1);
						else if (subtype(p) == cond_math_glue) print_esc(TEX_STRING("nonscript"));
						else print_esc(TEX_STRING("mskip"));
						print_char(TEX_STRING(")"));
					}
					if (subtype(p) != cond_math_glue) {
						print_char(TEX_STRING(" "));
						if (subtype(p) < cond_math_glue) print_spec(glue_ptr(p), 0);
						else print_spec(glue_ptr(p), TEX_STRING("mu"));
					}
				}
				#pragma endregion
				break;
			case kern_node:
				#pragma region <Display kern p 191>
				if (subtype(p) != mu_glue) {
					print_esc(TEX_STRING("kern"));
					if (subtype(p) != normal) print_char(TEX_STRING(" "));
					print_scaled(width(p));
					if (subtype(p) == acc_kern) print(TEX_STRING(" (for accent)"));
				}
				else {
					print_esc(TEX_STRING("mkern")); print_scaled(width(p));
					print(TEX_STRING("mu"));
				}
				#pragma endregion
				break;
			case math_node:
				#pragma region <Display math node p 192>
				print_esc(TEX_STRING("math"));
				if (subtype(p) == before) print(TEX_STRING("on"));
				else print(TEX_STRING("off"));
				if (width(p) != 0) {
					print(TEX_STRING(", surrounded ")); print_scaled(width(p));
				}
				#pragma endregion
				break;
			case ligature_node:
				#pragma region <Display ligature p 193>
				print_font_and_char(lig_char(p)); print(TEX_STRING(" (ligature "));
				if (subtype(p) > 1) print_char(TEX_STRING("|"));
				font_in_short_display = font(lig_char(p)); short_display(lig_ptr(p));
				if (myodd(subtype(p))) print_char(TEX_STRING("|"));
				print_char(TEX_STRING(")"));
				#pragma endregion
				break;
			case penalty_node:
				#pragma region <Display penalty p 194>
				print_esc(TEX_STRING("penalty ")); print_int(penalty(p));
				#pragma endregion
				break;
			case disc_node:
				#pragma region <Display discretionary p 195>
				print_esc(TEX_STRING("discretionary"));
				if (replace_count(p) > 0) {
					print(TEX_STRING(" replacing ")); print_int(replace_count(p));
				}
				node_list_display(pre_break(p));
				append_char(TEX_STRING("|")); show_node_list(post_break(p)); flush_char;
				#pragma endregion
				break;
			case mark_node:
				#pragma region <Display mark p 196>
				print_esc(TEX_STRING("mark")); print_mark(mark_ptr(p));
				#pragma endregion
				break;
			case adjust_node:
				#pragma region <Display adjustment p 197>
				print_esc(TEX_STRING("vadjust")); node_list_display(adjust_ptr(p));
				#pragma endregion
				break;

			#pragma region <Cases of show_node_list that arise in mlists only 690>
			case style_node: print_style(subtype(p)); break;
			case choice_node:
				#pragma region <Display choice node p 695>
				print_esc(TEX_STRING("mathchoice")); append_char(TEX_STRING("D")); show_node_list(display_mlist(p)); flush_char;
				append_char(TEX_STRING("T")); show_node_list(text_mlist(p)); flush_char; append_char(TEX_STRING("S"));
				show_node_list(script_mlist(p)); flush_char; append_char(TEX_STRING("s")); show_node_list(script_script_mlist(p));
				flush_char;
				#pragma endregion
				break;

			case ord_noad:
			case op_noad:
			case bin_noad:
			case rel_noad:
			case open_noad:
			case close_noad:
			case punct_noad:
			case inner_noad:
			case radical_noad:
			case over_noad:
			case under_noad:
			case vcenter_noad:
			case accent_noad:
			case left_noad:
			case right_noad:
				#pragma region <Display normal noad p 696>
				switch (type(p)) {
				case ord_noad: print_esc(TEX_STRING("mathord")); break;
				case op_noad: print_esc(TEX_STRING("mathop")); break;
				case bin_noad: print_esc(TEX_STRING("mathbin")); break;
				case rel_noad: print_esc(TEX_STRING("mathrel")); break;
				case open_noad: print_esc(TEX_STRING("mathopen")); break;
				case close_noad: print_esc(TEX_STRING("mathclose")); break;
				case punct_noad: print_esc(TEX_STRING("mathpunct")); break;
				case inner_noad: print_esc(TEX_STRING("mathinner")); break;
				case over_noad: print_esc(TEX_STRING("overline")); break;
				case under_noad: print_esc(TEX_STRING("underline")); break;
				case vcenter_noad: print_esc(TEX_STRING("vcenter")); break;
				case radical_noad: print_esc(TEX_STRING("radical")); print_delimiter(left_delimiter(p)); break;
				case accent_noad: print_esc(TEX_STRING("accent")); print_fam_and_char(accent_chr(p)); break;
				case left_noad: print_esc(TEX_STRING("left")); print_delimiter(delimiter(p)); break;
				case right_noad: print_esc(TEX_STRING("right")); print_delimiter(delimiter(p)); break;
				}
				if (subtype(p) != normal)
					if (subtype(p) == limits) print_esc(TEX_STRING("limits"));
					else print_esc(TEX_STRING("nolimits"));
				if (type(p) < left_noad) print_subsidiary_data(nucleus(p), TEX_STRING("."));
				print_subsidiary_data(supscr(p), TEX_STRING("^")); print_subsidiary_data(subscr(p), TEX_STRING("_"));

				#pragma endregion
				break;

			case fraction_noad:
				#pragma region <Display fraction noad p 697>
				print_esc(TEX_STRING("fraction, thickness "));
				if (thickness(p) == default_code) print(TEX_STRING("= default"));
				else print_scaled(thickness(p));
				if (small_fam(left_delimiter(p)) != 0 || small_char(left_delimiter(p)) != min_quarterword ||
					large_fam(left_delimiter(p)) != 0 || large_char(left_delimiter(p)) != min_quarterword) {
					print(TEX_STRING(", left-delimiter ")); print_delimiter(left_delimiter(p));
				}
				if (small_fam(right_delimiter(p)) != 0 || small_char(right_delimiter(p)) != min_quarterword ||
					large_fam(right_delimiter(p)) != 0 || large_char(right_delimiter(p)) != min_quarterword) {
					print(TEX_STRING(", right-delimiter ")); print_delimiter(right_delimiter(p));
				}
				print_subsidiary_data(numerator(p), TEX_STRING("\")); print_subsidiary_data(denominator(p), TEX_STRING("/"));
				#pragma endregion
				break;

			#pragma endregion

			default:
				print(TEX_STRING("Unknown node type!"));
				break;

			}
		#pragma endregion

		p = link(p);
	}
}

//198
void show_box(pointer p)
{
	#pragma region <Assign the values depth_threshold = show_box_depth and breadth_max = show_box_breadth 236>
	depth_threshold = show_box_depth; breadth_max = show_box_breadth;
	#pragma endregion
	if (breadth_max <= 0)
		breadth_max = 5;
	if (pool_ptr + depth_threshold >= pool_size)
		depth_threshold = pool_size - pool_ptr - 1;
	show_node_list(p);
	print_ln();
}

// 174
void short_display(int p)
{
	int n;
	while (p > mem_min) {
		if (is_char_node(p)) {
			if (p <= mem_end) {
				if (font(p) != font_in_short_display) {
					if (font(p) < font_base || font(p) > font_max) print_char(TEX_STRING("*"));
					else 
						#pragma region <Print the font identifier for font(p) 267>
					{
						print_esc(font_id_text(font(p)));

					}
						#pragma endregion
					print_char(TEX_STRING(" ")); font_in_short_display = font(p);
				}
				print_ASCII(qo(character(p)));
			}
		}
		else
			#pragma region	<Print a short indication of the contents of node p 175>
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case ins_node:
			case whatsit_node:
			case mark_node:
			case adjust_node:
			case unset_node:
				print(TEX_STRING("[]"));
				break;
			case rule_node: print_char(TEX_STRING("|")); break;
			case glue_node: if (glue_ptr(p) != zero_glue) print_char(TEX_STRING(" ")); break;
			case math_node: print_char(TEX_STRING("$")); break;
			case ligature_node: short_display(lig_ptr(p)); break;
			case disc_node:
				short_display(pre_break(p)); short_display(post_break(p));
				n = replace_count(p);
				while (n > 0) {
					if (link(p) != null) p = link(p);
					decr(n);
				}
				break;

			default:
				//do_nothing
				break;
			}
			#pragma endregion
		p = link(p);
	}
}


// 311
void show_context()
{
	unsigned int old_setting;
	int nn;
	bool bottom_line;
	#pragma region <Local variables for formatting calculations 315>
	int i;
	int j;
	int l;
	int m;
	int n;
	int p;
	int q;
	#pragma endregion

	base_ptr = input_ptr; input_stack[base_ptr] = cur_input;
	nn = -1; bottom_line = false;
	while (1) {
		cur_input = input_stack[base_ptr];
		if (state != token_list)
			if (name > 17 || base_ptr == 0)
				bottom_line = true;
		if (base_ptr == input_ptr || bottom_line || nn < error_context_lines)
			#pragma region <Display the current context 312>
		{
			if (base_ptr == input_ptr || state != token_list || token_type != backed_up || loc != null) {
				tally = 0;
				old_setting = selector;
				if (state != token_list) {
					#pragma region <Print location of current line 313>
					if (name <= 17)
						if (terminal_input)
							if (base_ptr == 0)
								print_nl(TEX_STRING("<*>"));
							else
								print_nl(TEX_STRING("<insert> "));
						else {
							print_nl(TEX_STRING("<read "));
							if (name == 17) print_char(TEX_STRING("*"));
							else print_int(name - 1);
							print_char(TEX_STRING(">"));
						}
					else {
						print_nl(TEX_STRING("l.")); print_int(line);
					}
					print_char(TEX_STRING(" "));
					#pragma endregion

					#pragma region <Pseudoprint the line 318>
					begin_pseudoprint;
					if (buffer[limit] == end_line_char)
						j = limit;
					else
						j = limit + 1;
					if(j>0)
						for (i = start; i <= j - 1; i++) {
							if (i == loc)
								set_trick_count;
							print(buffer[i]);
						}
					#pragma endregion
				}
				else {
					#pragma region <Print type of token list 314>
					switch (token_type) {
					case parameter:
						print_nl(TEX_STRING("<argument> "));
						break;
					case u_template:
					case v_template:
						print_nl(TEX_STRING("<template> "));
						break;
					case backed_up:
						if (loc == null) print_nl(TEX_STRING("<recently read> "));
						else print_nl(TEX_STRING("<to be read again> "));
						break;
					case inserted:
						print_nl(TEX_STRING("<inserted text> "));
						break;
					case macro:
						print_ln();
						print_cs(name);
						break;
					case output_text:
						print_nl(TEX_STRING("<output> "));
						break;
					case every_par_text:
						print_nl(TEX_STRING("<everypar> "));
						break;
					case every_math_text:
						print_nl(TEX_STRING("<everymath> "));
						break;
					case every_display_text:
						print_nl(TEX_STRING("<everydisplay> "));
						break;
					case every_hbox_text:
						print_nl(TEX_STRING("<everyhbox> "));
						break;
					case every_vbox_text:
						print_nl(TEX_STRING("<everyvbox> "));
						break;
					case every_job_text:
						print_nl(TEX_STRING("<everyjob> "));
						break;
					case every_cr_text:
						print_nl(TEX_STRING("<everycr> "));
						break;
					case mark_text:
						print_nl(TEX_STRING("<mark> "));
						break;
					case write_text:
						print_nl(TEX_STRING("<write> "));
						break;
					default:
						print_nl(TEX_STRING("?"));
						break;
					}
					#pragma endregion
					#pragma region <Pseudoprint the token list 319>
					begin_pseudoprint;
					if (token_type < macro) show_token_list(start, loc, 100000);
					else show_token_list(link(start), loc, 100000);
					#pragma endregion
				}
				selector = old_setting;
				#pragma region <Print two lines using the tricky pseudoprinted information 317>
				if (trick_count == 1000000)
					set_trick_count;
				if (tally < trick_count)
					m = tally - first_count;
				else m = trick_count - first_count;
				if (l + first_count <= half_error_line) {
					p = 0; n = l + first_count;
				}
				else {
					print(TEX_STRING("...")); p = l + first_count - half_error_line + 3; n = half_error_line;
				}
				for (q = p; q <= first_count - 1; q++) print_char(trick_buf[q % error_line]);
				print_ln();
				for (q = 1; q <= n; q++) print_char(TEX_STRING(" "));
				if (m + n <= error_line)
					p = first_count + m;
				else
					p = first_count + (error_line - n - 3);
				for (q = first_count; q <= p - 1; q++) print_char(trick_buf[q % error_line]);
				if (m + n > error_line) print(TEX_STRING("..."));
				#pragma endregion
				incr(nn);

			}
		}
			#pragma endregion
		else if (nn == error_context_lines) {
			print_nl(TEX_STRING("...")); incr(nn);
		}
		if (bottom_line)
			goto done;
		decr(base_ptr);
	}
done:
	cur_input = input_stack[input_ptr];
}

// 433
void scan_eight_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 255) {
		print_err(TEX_STRING("Bad register code"));
		help2(TEX_STRING("A register number must be between 0 and 255."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

// 435
void scan_four_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 15) {
		print_err(TEX_STRING("Bad number"));
		help2(TEX_STRING("Since I expected to read a number between 0 and 15,"),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

// 436
void scan_fifteen_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 077777) {
		print_err(TEX_STRING("Bad mathchar"));
		help2(TEX_STRING("A mathchar number must be between 0 and 32767."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

//31
bool input_ln(FILE *fp, bool bypass_eoln)
{
	int last_nonblank;

	last = first;

	last_nonblank = first;
	int c;
	c = fgetc(fp);
	if (c == EOF)
		return false;
	else
		ungetc(c, fp);
	while ((c = fgetc(fp)) != '\n' && c != EOF) {
		if (last >= max_buf_stack) {
			max_buf_stack = last + 1;
			if (max_buf_stack == buf_size) 
				#pragma region <Report overflow of the input buffer, and abort 35>
			{
				if (format_ident == 0) {
					puts("Buffer size exceeded!");
					do_final_end();
				}
				else {
					cur_input.loc_field = first;
					cur_input.limit_field = last - 1;
					overflow(TEX_STRING("buffer size"), buf_size);
				}
			}
				#pragma endregion
		}
		buffer[last] = xord[c]; incr(last);		
		if (buffer[last - 1] != TEX_STRING(" "))
			last_nonblank = last;
	}
	last = last_nonblank;
	return true;
}



// 275
void eq_destroy(memory_word w)
{
	pointer q;
	switch (eq_type_field(w))
	{
	case call:
	case long_call:
	case outer_call:
	case long_outer_call:
		delete_token_ref(equiv_field(w));
		break;
	case glue_ref:
		delete_glue_ref(equiv_field(w));
		break;
	case shape_ref:
		q = equiv_field(w);
		if (q != null)
			free_node(q, info(q) + info(q) + 1);
		break;
	case box_ref:
		flush_node_list(equiv_field(w));
		break;
	default:
		break;
	}
}

// 276
void eq_save(pointer p, quarterword l)
{
	check_full_save_stack;
	if (l == level_zero)
		save_type(save_ptr) = restore_zero;
	else {
		save_stack[save_ptr] = eqtb[p]; incr(save_ptr); save_type(save_ptr) = restore_old_value;
	}
	save_level(save_ptr) = l; save_index(save_ptr) = p; incr(save_ptr);
}

// 277
void eq_define(pointer p, quarterword t, halfword e)
{
	if (eq_level(p) == cur_level)
		eq_destroy(eqtb[p]);
	else if (cur_level > level_one)
		eq_save(p, eq_level(p));
	eq_level(p) = cur_level; eq_type(p) = t; equiv(p) = e;
}

// 278
void eq_word_define(pointer p, int w)
{
	if (xeq_level[p] != cur_level) {
		eq_save(p, xeq_level[p]);
		xeq_level[p] = cur_level;
	}
	eqtb[p].an_int = w;
}

// 279
void geq_define(pointer p, quarterword t, halfword e)
{
	eq_destroy(eqtb[p]); eq_level(p) = level_one; eq_type(p) = t; equiv(p) = e;
}

void geq_word_define(pointer p, int w)
{
	eqtb[p].an_int = w;
	xeq_level[p] = level_one;
}

// 211
void print_mode(int m)
{
	if (m > 0)
		switch (m / (max_command + 1)) {
		case 0:print(TEX_STRING("vertical")); break;
		case 1:print(TEX_STRING("horizontal")); break;
		case 2:print(TEX_STRING("display math")); break;
		}
	else if (m == 0)
		print(TEX_STRING("no"));
	else
		switch ((-m) / (max_command + 1)) {
		case 0:print(TEX_STRING("internal vertical")); break;
		case 1:print(TEX_STRING("restricted horizontal")); break;
		case 2:print(TEX_STRING("math")); break;
		}
	print(TEX_STRING(" mode"));
}

// 299
void show_cur_cmd_chr()
{
	begin_diagnostic();
	print_nl(TEX_STRING("{"));
	if (mode != shown_mode) {
		print_mode(mode); print(TEX_STRING(": ")); shown_mode = mode;
	}
	print_cmd_chr(cur_cmd, cur_chr); print_char(TEX_STRING("}"));
	end_diagnostic(false);
}


// 37
bool init_terminal(int argc, char **argv)
{
	//////////////////////////////////////////////////////////
	// system dependent part, similar to tex-sparc/initex.ch
	if(argc > 1) {
		last = first;
		for (int i = 1; i < argc; i++) {
			if (argv[i][0] == '-') // skip
				continue;		
			int j = 0;
			int k = strlen(argv[i]) - 1;
			while (k > 0 && argv[i][k] == ' ')
				decr(k);
			while (j <= k) {
				buffer[last] = xord[argv[i][j]];
				incr(j); incr(last);
			}
			if(k > 0) {
				buffer[last] = xord[' '];
				incr(last);
			}
		}
		if(last > first) {
			loc  = first;
			while (loc < last && buffer[loc] == ' ')
				incr(loc);
			if (loc < last)
				return true;
		}
	}
	//////////////////////////////////////////////////////////
	
	
	while (1) {
		fputs("**", term_out);
		if (!input_ln(term_in, true)) {
			fputc('\n', term_out);
			fputs("! End of file on terminal... why?", term_out);
			return false;
		}
		loc = first;
		while (loc < last && buffer[loc] == ' ')
			incr(loc);
		if (loc < last)
			return true;
		fputs("Please type the name of your input file.\n", term_out);
	}
}

// 363
void firm_up_the_line()
{
	int k;

	limit = last;
	if(pausing > 0)
		if (interaction > nonstop_mode) {
			wake_up_terminal(); print_ln();
			if (start < limit)
				for (k = start; k <= limit - 1; k++) print(buffer[k]);
			first = limit; prompt_input(TEX_STRING("=>"));
			if (last > first) {
				for (k = first; k <= last - 1; k++)
					buffer[k + start - first] = buffer[k];
				limit = start + last - first;
			}
		}
}

// 523
void pack_buffered_name(small_number n, int a, int b)
{
	int k;
	ASCII_code c;
	int j;

	if (n + b - a + 1 + format_ext_length > file_name_size)
		b = a + file_name_size - n - 1 - format_ext_length;
	k = 0;
	for (j = 1; j <= n; j++) append_to_name(xord[TEX_format_default[j]]);
	for (j = a; j <= b; j++) append_to_name(buffer[j]);
	for (j = format_default_length - format_ext_length + 1; j <= format_default_length; j++)
		append_to_name(xord[TEX_format_default[j]]);

	// addition for C, add zero terminator
	name_of_file[k + 1] = 0;
}


// 524
bool open_fmt_file()
{
	unsigned int j;

	j = loc;
	if (buffer[loc] == TEX_STRING("&")) {
		incr(loc); j = loc; buffer[last] = TEX_STRING(" ");
		while (buffer[j] != TEX_STRING(" ")) incr(j);
		pack_buffered_name(0, loc, j - 1);
		if (w_open_in(&fmt_file)) goto found;
		wake_up_terminal(); 
		wterm_ln_s("Sorry, I can't find that format; will try PLAIN.");
		update_terminal();
	}
	pack_buffered_name(format_default_length - format_ext_length, 1, 0);
	if (!w_open_in(&fmt_file)) {
		wake_up_terminal();
		wterm_ln_s("I can't find the PLAIN format file!");
		return false;
	}
found:
	loc = j;
	return true;
}

// 408
void mu_error()
{
	print_err(TEX_STRING("Incompatible glue units"));
	help1(TEX_STRING("I'm going to assume that 1mu=1pt when they're mixed."));
	error();
}


// 463
pointer scan_rule_spec()
{
	pointer q;

	q = new_rule();
	if (cur_cmd == vrule)
		width(q) = default_rule;
	else {
		height(q) = default_rule;
		depth(q) = 0;
	}
reswitch:
	if (scan_keyword(TEX_STRING("width"))) {
		scan_normal_dimen;
		width(q) = cur_val;
		goto reswitch;
	}
	if (scan_keyword(TEX_STRING("height"))) {
		scan_normal_dimen;
		height(q) = cur_val;
		goto reswitch;
	}
	if (scan_keyword(TEX_STRING("depth"))) {
		scan_normal_dimen;
		depth(q) = cur_val;
		goto reswitch;
	}
	return q;
}

// 578
void find_font_dimen(bool writing)
{
	internal_font_number f;
	int n;
	scan_int();
	n = cur_val;
	scan_font_ident();
	f = cur_val;
	if (n <= 0)
		cur_val = fmem_ptr;
	else {
		if (writing && (n <= space_shrink_code) && n >= space_code && font_glue[f] != null) {
			delete_glue_ref(font_glue[f]); font_glue[f] = null;
		}
		if (n > font_params[f])
			if (f < font_ptr)
				cur_val = fmem_ptr;
			else
				#pragma region <Increase the number of parameters in the last font 580>
			{
				do {
					if (fmem_ptr == font_mem_size)
						overflow(TEX_STRING("font memory"), font_mem_size);
					font_info[fmem_ptr].sc = 0; incr(fmem_ptr); incr(font_params[f]);
				} while (!(n == font_params[f]));
				cur_val = fmem_ptr - 1;
			}
				#pragma endregion
		else
			cur_val = n + param_base[f];
	}
	#pragma region <Issue an error message if cur_val = fmem_ptr 579>
	if (cur_val == fmem_ptr) {
		print_err(TEX_STRING("Font "));
		print_esc(font_id_text(f));
		print(TEX_STRING(" has only "));
		print_int(font_params[f]); print(TEX_STRING(" fontdimen parameters"));
		help2(TEX_STRING("To increase the number of font parameters, you must"),
			TEX_STRING("use \fontdimen immediately after the \font is loaded."));
		error();
	}
	#pragma endregion
}


// 413
void scan_something_internal(small_number level, bool negative)
{
	halfword m;
	unsigned int p;

	m = cur_chr;
	switch (cur_cmd) {
	case def_code:
		#pragma region <Fetch a character code from some table 414>
		scan_char_num();
		if (m == math_code_base) scanned_result(ho(math_code(cur_val)), int_val);
		else if (m < math_code_base) scanned_result(equiv(m + cur_val), int_val);
		else scanned_result(eqtb[m + cur_val].an_int, int_val);
		#pragma endregion
		break;
	case toks_register:
	case assign_toks:
	case def_family:
	case set_font:
	case def_font:
		#pragma region <Fetch token list or font identiifer provided that level == tok_val 415>
		if (level != tok_val) {
			print_err(TEX_STRING("Missing number, treated as zero"));
			help3(TEX_STRING("A number should have been here; I inserted `0'."),
				TEX_STRING("(If you can't figure out why I needed to see a number,"),
				TEX_STRING("look up `weird error' in the index to The TeXbook.)"));
			back_error();
			scanned_result(0, dimen_val);
		}
		else if (cur_cmd <= assign_toks) {
			if (cur_cmd < assign_toks) {
				scan_eight_bit_int(); m = toks_base + cur_val;
			}
			scanned_result(equiv(m), tok_val);
		}
		else {
			back_input(); scan_font_ident(); scanned_result(font_id_base + cur_val, ident_val);
		}
		#pragma endregion
		break;
	case assign_int:
		scanned_result(eqtb[m].an_int, int_val);
		break;
	case assign_dimen:
		scanned_result(eqtb[m].sc, dimen_val);
		break;
	case assign_glue:
		scanned_result(equiv(m), glue_val);
		break;
	case assign_mu_glue:
		scanned_result(equiv(m), mu_val);
		break;
	case set_aux:
		#pragma region <Fetch the space factor or the prev_depth 418>
		if (myabs(mode) != m) {
			print_err(TEX_STRING("Improper "));
			print_cmd_chr(set_aux, m);
			help4(TEX_STRING("You can refer to \spacefactor only in horizontal mode;"),
				TEX_STRING("you can refer to \prevdepth only in vertical mode; and"),
				TEX_STRING("neither of these is meaningful inside \write. So"),
				TEX_STRING("I'm forgetting what you said and using zero instead."));
			error();
			if (level != tok_val)
				scanned_result(0, dimen_val);
			else
				scanned_result(0, int_val);
		}
		else if (m == vmode)
			scanned_result(prev_depth, dimen_val);
		else
			scanned_result(space_factor, int_val);
		#pragma endregion
		break;
	case set_prev_graf:
		#pragma region <Fetch the prev_graf 422>
		if (mode == 0)
			scanned_result(0, int_val);
		else {
			nest[nest_ptr] = cur_list; p = nest_ptr;
			while (myabs(nest[p].mode_field) != vmode)
				decr(p);
			scanned_result(nest[p].pg_field, int_val);
		}
		#pragma endregion
		break;
	case set_page_int:
		#pragma region <Fetch the dead_cycles or the insert_penalties 419>
		if (m == 0)
			cur_val = dead_cycles;
		else
			cur_val = insert_penalties;
		cur_val_level = int_val;
		#pragma endregion
		break;
	case set_page_dimen:
		#pragma region <Fetch something on the page_so_far 421>
		if (page_contents == empty && !output_active) {
			if (m == 0)
				cur_val = max_dimen;
			else
				cur_val = 0;
		}
		else
			cur_val = page_so_far[m];
		cur_val_level = dimen_val;
		#pragma endregion
		break;
	case set_shape:
		#pragma region <Fetch the par shape size 423>
		if (par_shape_ptr == null)
			cur_val = 0;
		else
			cur_val = info(par_shape_ptr);
		cur_val_level = int_val;
		#pragma endregion
		break;
	case set_box_dimen:
		#pragma region <Fetch a box dimension 420>
		scan_eight_bit_int();
		if (box(cur_val) == null)
			cur_val = 0;
		else
			cur_val = mem[box(cur_val) + m].sc;
		cur_val_level = dimen_val;
		#pragma endregion
		break;
	case char_given:
	case math_given:
		scanned_result(cur_chr, int_val);
		break;
	case assign_font_dimen:
		#pragma region <Fetch a font dimension 425>
		find_font_dimen(false); font_info[fmem_ptr].sc = 0;
		scanned_result(font_info[cur_val].sc, dimen_val);
		#pragma endregion
		break;
	case assign_font_int:
		#pragma region <Fetch a font integer 426>
		scan_font_ident();
		if (m == 0)
			scanned_result(hyphen_char[cur_val], int_val);
		else
			scanned_result(skew_char[cur_val], int_val);
		#pragma endregion
		break;
	case _register:
		#pragma region <Fetch a register 427>
		scan_eight_bit_int();
		switch (m) {
		case int_val:
			cur_val = count(cur_val);
			break;
		case dimen_val:
			cur_val = dimen(cur_val);
			break;
		case glue_val:
			cur_val = skip(cur_val);
			break;
		case mu_val:
			cur_val = mu_skip(cur_val);
			break;
		}
		cur_val_level = m;
		#pragma endregion
		break;
	case last_item:
		#pragma region <Fetch an item in the current node if appropriate 424>
		if (cur_chr > glue_val) {
			if (cur_chr == input_line_no_code)
				cur_val = line;
			else
				cur_val = last_badness;
			cur_val_level = int_val;
		}
		else {
			if (cur_chr == glue_val)
				cur_val = zero_glue;
			else
				cur_val = 0;
			cur_val_level = cur_chr;

			if (!is_char_node(tail) && (mode != 0))
				switch (cur_chr) {
				case int_val:
					if (type(tail) == penalty_node)
						cur_val = penalty(tail);
					break;
				case dimen_val:
					if (type(tail) == kern_node)
						cur_val = width(tail);
					break;
				case glue_val:
					if (type(tail) == glue_node) {
						cur_val = glue_ptr(tail);
						if (subtype(tail) == mu_glue)
							cur_val_level = mu_val;
					}
					break;
				}

			else if (mode == vmode && tail == head)
				switch (cur_chr) {
				case int_val:
					cur_val = last_penalty;
					break;
				case dimen_val:
					cur_val = last_kern;
					break;
				case glue_val:
					if (last_glue != max_halfword)
						cur_val = last_glue;
					break;
				}
		}
		#pragma endregion
		break;
	default:
		#pragma region <Complain that the cant do this; give zero result 428>
	{
		print_err(TEX_STRING("You can't use `"));
		print_cmd_chr(cur_cmd, cur_chr);
		print(TEX_STRING("' after "));
		print_esc(TEX_STRING("the"));
		help1(TEX_STRING("I'm forgetting what you said and using zero instead."));
		error();
		if (level != tok_val)
			scanned_result(0, dimen_val);
		else
			scanned_result(0, int_val);
	}
		#pragma endregion
		break;
	}
	while (cur_val_level > level) 
		#pragma region <Convert cur_val to a lower level 429>
	{
		if (cur_val_level == glue_val)
			cur_val = width(cur_val);
		else if (cur_val_level == mu_val)
			mu_error();
		decr(cur_val_level);
	}
		#pragma endregion

	#pragma region <Fix the reference count if any and negate cur_val if negative 430>
	if (negative) {
		if (cur_val_level >= glue_val) {
			cur_val = new_spec(cur_val);
			#pragma region<Negate all three glue components of cur_val 431>
			negate(width(cur_val));
			negate(stretch(cur_val));
			negate(shrink(cur_val));
			#pragma endregion
		}
		else {
			negate(cur_val);
		}
	}
	else if (cur_val_level >= glue_val && cur_val_level <= mu_val)
		add_glue_ref(cur_val);
	#pragma endregion
}

// 529
void pack_job_name(str_number s)
{
	cur_area = TEX_STRING("");
	cur_ext = s;
	cur_name = job_name;
	pack_cur_name;
}

// 515
void begin_name()
{
	area_delimiter = 0;
	ext_delimiter = 0;
}

// 516
bool more_name(ASCII_code c)
{
	if (c == TEX_STRING(" ")) return false;
	else {
		str_room(1); append_char(c);
		if (c == TEX_STRING("/")) {
			area_delimiter = cur_length;
			ext_delimiter = 0;
		}
		else if (c == TEX_STRING(".") && ext_delimiter == 0)
			ext_delimiter = cur_length;
		return true;

	}
}

// 517
void end_name()
{
	if (str_ptr + 3 > max_strings) overflow(TEX_STRING("number of strings"), max_strings - init_str_ptr);
	if (area_delimiter == 0)
		cur_area = TEX_STRING("");
	else {
		cur_area = str_ptr; str_start[str_ptr + 1] = str_start[str_ptr] + area_delimiter; incr(str_ptr);
	}
	if (ext_delimiter == 0) {
		cur_ext = TEX_STRING(""); cur_name = make_string();
	}
	else {
		cur_name = str_ptr;
		str_start[str_ptr + 1] = str_start[str_ptr] + ext_delimiter - area_delimiter - 1; incr(str_ptr);
		cur_ext = make_string();
	}
}

// 518
void print_file_name(int n, int a, int e)
{
	slow_print(a);
	slow_print(n);
	slow_print(e);
}

// 519
void pack_file_name(str_number n, str_number a, str_number e)
{
	int k;
	ASCII_code c;
	pool_pointer j;

	k = 0;
	for (j = str_start[a]; j <= str_start[a + 1] - 1; j++)
		append_to_name(so(str_pool[j]));
	for (j = str_start[n]; j <= str_start[n + 1] - 1; j++)
		append_to_name(so(str_pool[j]));
	for (j = str_start[e]; j <= str_start[e + 1] - 1; j++)
		append_to_name(so(str_pool[j]));

	name_of_file[k + 1] = 0;
}

// 530
void prompt_file_name(str_number s, str_number e)
{
	int k;
	if (interaction == scroll_mode)
		wake_up_terminal();

	if (s == TEX_STRING("input file name"))
		print_err(TEX_STRING("I can't find file `"));
	else print_err(TEX_STRING("I can't write on file `"));
	print_file_name(cur_name, cur_area, cur_ext); print(TEX_STRING("'."));
	if (e == TEX_STRING(".tex")) show_context();
	print_nl(TEX_STRING("Please type another ")); print(s);
	if (interaction < scroll_mode)
		fatal_error(TEX_STRING("*** (job aborted, file error in nonstop mode)"));
	clear_terminal();
	prompt_input(TEX_STRING(": "));
	#pragma region <Scan file name in the buffer 531>
	{
		begin_name();
		k = first;
		while (buffer[k] == TEX_STRING(" ") && k < last) incr(k);
		while (1) {
			if (k == last)
				goto done;
			if (!more_name(buffer[k])) goto done;
			incr(k);
		}
done:
		end_name();
	}
	#pragma endregion
	if (cur_ext == TEX_STRING("")) cur_ext = e;
	pack_cur_name;
}

// 607
void movement(scaled w, eight_bits o)
{
	small_number mstate;
	pointer p, q;
	int k;
	q = get_node(movement_node_size);
	width(q) = w;
	location(q) = dvi_offset + dvi_ptr;
	if (o == dvi_op::down1) {
		link(q) = down_ptr; down_ptr = q;
	}
	else {
		link(q) = right_ptr; right_ptr = q;
	}

	#pragma region <Look at the other stack entries until decidign what sort of DVI.. 611>
	p = link(q); mstate = none_seen;
	while (p != null) {
		if (width(p) == w)
			#pragma region <Consider a node with matching width.. 612>
			switch(mstate+info(p)){
			case none_seen+yz_OK:
			case none_seen+y_OK:
			case z_seen+yz_OK:
			case z_seen+y_OK:
				if (location(p) < dvi_gone) goto not_found;
				else
					#pragma region <Change buffered instruction to y or w and goto found 613>
				{
					k = location(p) - dvi_offset;
					if (k < 0) k += dvi_buf_size;
					dvi_buf[k] += dvi_op::y1 - dvi_op::down1;
					info(p) = y_here; goto found;
				}
					#pragma endregion
				break;
			case none_seen+z_OK:
			case y_seen+yz_OK:
			case y_seen+z_OK:
				if (location(p) < dvi_gone) goto not_found;
				else
				#pragma region <Change buffered instruction to z or x and goto found 614>
				{
					k = location(p) - dvi_offset;
					if (k < 0) k += dvi_buf_size;
					dvi_buf[k] += dvi_op::z1 - dvi_op::down1;
					info(p) = z_here; goto found;
				}
				#pragma endregion
				break;
			case none_seen+y_here:
			case none_seen+z_here:
			case y_seen+z_here:
			case z_seen+y_here:
				goto found;
				break;
			default:
				//do_nothing
				break;
			}
		#pragma endregion
		else switch (mstate + info(p)) {
		case none_seen + y_here: mstate = y_seen; break;
		case none_seen + z_here: mstate = z_seen; break;
		case y_seen+z_here:
		case z_seen+y_here:
			goto not_found;
			break;
		default:
			//do_nothing
			break;
		}
		p = link(p);

	}
	not_found:
	#pragma endregion

	#pragma region <Generate a down or right command for w and return 610>
	info(q) = yz_OK;
	if (myabs(w) >= 040000000) {
		dvi_out(o + 3);
		dvi_four(w); goto _exit;
	}
	if (myabs(w) >= 0100000) {
		dvi_out(o + 2);
		if (w < 0) w += 0100000000;
		dvi_out(w / 0200000); w = w % 0200000; goto my2;
	}
	if (myabs(w) >= 0200) {
		dvi_out(o + 1);
		if (w < 0) w += 0200000;
		goto my2;
	}
	dvi_out(o);
	if (w < 0) w += 0400;
	goto my1;
my2:
	dvi_out(w / 0400);
my1:
	dvi_out(w % 0400);
	goto _exit;
	#pragma endregion
found:
	#pragma region <Generate a y0 or z0 command in order to reuse a previosu appearance of w 609>
	 info(q) = info(p);
	 if (info(q) == y_here) {
		 dvi_out(o + dvi_op::y0 - dvi_op::down1);
		 while (link(q) != p) {
			 q = link(q);
			 switch (info(q)) {
			 case yz_OK: info(q) = z_OK; break;
			 case y_OK: info(q) = d_fixed; break;
			 default:
				 //do_nothing
				 break;
			 }
		 }
	 }
	 else {
		 dvi_out(o + dvi_op::z0 - dvi_op::down1);
		 while (link(q) != p) {
			 q = link(q);
			 switch (info(q)) {
			 
			 case yz_OK:
				info(q) = y_OK;
				break;
				
			 case z_OK:
				info(q) = d_fixed;
				break;
				
			 default:
				 //do_nothing
				 break;
			 }
		 }
	 }
	#pragma endregion

_exit:
	;
}

// 686
pointer new_noad()
{
	pointer p;
	p = get_node(noad_size); type(p) = ord_noad; subtype(p) = normal;
	mem[nucleus(p)].hh = empty_field; mem[subscr(p)].hh = empty_field;
	mem[supscr(p)].hh = empty_field;
	return p;
}


/// 691
void print_fam_and_char(pointer p)
{
	print_esc(TEX_STRING("fam")); print_int(fam(p)); print_char(TEX_STRING(" ")); print_ASCII(qo(character(p)));
}

void print_delimiter(pointer p)
{
	int a;
	a = small_fam(p) * 256 + qo(small_char(p));
	a = a * 0x1000 + large_fam(p) * 256 + qo(large_char(p));
	if (a < 0) print_int(a);
	else print_hex(a);
}

// 692
void print_subsidiary_data(pointer p, ASCII_code c)
{
	if (cur_length >= depth_threshold) {
		if (math_type(p) != empty) print(TEX_STRING(" []"));
	}
	else {
		append_char(c);
		temp_ptr = p;
		switch (math_type(p)) {
		case math_char:
			print_ln(); print_current_string(); print_fam_and_char(p);
			break;
		case sub_box: show_info(); break;
		case sub_mlist:
			if (info(p) == null) {
				print_ln(); print_current_string(); print(TEX_STRING("{}"));
			}
			else show_info();
			break;
		default:
			//do_nothing
			break;
		}
		flush_char;
	}
}

//693
void show_info()
{
	show_node_list(info(temp_ptr));
}

// 704
pointer fraction_rule(scaled t)
{
	pointer p;
	p = new_rule(); height(p) = t; depth(p) = 0;
	return p;
}

// 705
pointer overbar(pointer b, scaled k, scaled t)
{
	pointer p, q;
	p = new_kern(k); link(p) = b; q = fraction_rule(t); link(q) = p; p = new_kern(t); link(p) = q;
	return vpack(p, natural);
}


// 706
pointer var_delimiter(pointer d, small_number s, scaled v)
{
	pointer b;
	internal_font_number f, g;
	quarterword c, x, y;
	int m, n;
	scaled u;
	scaled w;
	four_quarters q;
	eight_bits hd;
	four_quarters r;
	small_number z;
	bool large_attempt;

	f = null_font; w = 0; large_attempt = false; z = small_fam(d); x = small_char(d);
	while (1) {
		#pragma region <Look at the variants of (z,x); set f and c whenever a better character is found; goto found.. 707>
		if (z != 0 || x != min_quarterword) {
			z += s + 16;
			do {
				z -= 16; g = fam_fnt(z);

				if (g != null_font)

					#pragma region <Look at the list of characters starting with x in font g; set f and c.. 708>
				{
					y = x;
					if (qo(y) >= font_bc[g] && qo(y) <= font_ec[g]) {
					mycontinue:
						q = char_info(g, y);
						if (char_exists(q)) {
							if (char_tag(q) == ext_tag) {
								f = g; c = y; goto found;
							}
							hd = height_depth(q); u = char_height(g, hd) + char_depth(g, hd);
							if (u > w) {
								f = g; c = y; w = u;
								if (u >= v) goto found;
							}
							if (char_tag(q) == list_tag) {
								y = rem_byte(q); goto mycontinue;
							}
						}
					}
				}
					#pragma endregion

			} while (!(z < 16));
		}
		#pragma endregion
		if (large_attempt) goto found;
		large_attempt = true; z = large_fam(d); x = large_char(d);

	}
found:
	if (f != null_font)
		#pragma region <Make variable b point to a box for (f,c) 710>
		if (char_tag(q) == ext_tag)

			#pragma region <Construct an extensible character in a new box b, using recipe rem_byte(q) and font f 713>
		{
			b = new_null_box(); type(b) = vlist_node; r = font_info[exten_base[f] + rem_byte(q)].qqqq;

			#pragma region <Compute the minimum suitable height, w, and the corresponding number of extension steps, n; .. 714>
			c = ext_rep(r); u = height_plus_depth(f, c); w = 0; q = char_info(f, c);
			width(b) = char_width(f, q) + char_italic(f, q);
			c = ext_bot(r); if (c != min_quarterword) w += height_plus_depth(f, c);
			c = ext_mid(r); if (c != min_quarterword) w += height_plus_depth(f, c);
			c = ext_top(r); if (c != min_quarterword) w += height_plus_depth(f, c);
			n = 0;
			if(u>0)
				while (w < v) {
					w += u; incr(n);
					if (ext_mid(r) != min_quarterword) w += u;
				}
			#pragma endregion
			c = ext_bot(r);
			if (c != min_quarterword) stack_into_box(b, f, c);
			c = ext_rep(r);
			for (m = 1; m <= n; m++) stack_into_box(b, f, c);
			c = ext_mid(r);
			if (c != min_quarterword) {
				stack_into_box(b, f, c); c = ext_rep(r);
				for (m = 1; m <= n; m++) stack_into_box(b, f, c);
			}
			c = ext_top(r);
			if (c != min_quarterword) stack_into_box(b, f, c);
			depth(b) = w - height(b);
		}
			#pragma endregion
		else b = char_box(f, c);

		#pragma endregion
	else {
		b = new_null_box(); width(b) = null_delimiter_space;
	}
	shift_amount(b) = half(height(b) - depth(b)) - axis_height(s); return b;
}



// 709
pointer char_box(internal_font_number f, quarterword c)
{
	four_quarters q;
	eight_bits hd;
	pointer b, p;

	q = char_info(f, c); hd = height_depth(q); b = new_null_box();
	width(b) = char_width(f, q) + char_italic(f, q); height(b) = char_height(f, hd);
	depth(b) = char_depth(f, hd); p = get_avail(); character(p) = c; font(p) = f; list_ptr(b) = p;
	return b;
}


// 711
void stack_into_box(pointer b, internal_font_number f, quarterword c)
{
	pointer p;
	p = char_box(f, c); link(p) = list_ptr(b); list_ptr(b) = p; height(b) = height(p);
}

//712
scaled height_plus_depth(internal_font_number f, quarterword c)
{
	four_quarters q;
	eight_bits hd;
	q = char_info(f, c); hd = height_depth(q);
	return char_height(f, hd) + char_depth(f, hd);
}


// 715
pointer rebox(pointer b, scaled w)
{
	pointer p;
	internal_font_number f;
	scaled v;

	if (width(b) != w && list_ptr(b) != null) {
		if (type(b) == vlist_node) b = hpack(b, natural);
		p = list_ptr(b);
		if (is_char_node(p) && link(p) == null) {
			f = font(p); v = char_width(f, char_info(f, character(p)));
			if (v != width(b)) link(p) = new_kern(width(b) - v);
		}
		free_node(b, box_node_size); b = new_glue(ss_glue); link(b) = p;
		while (link(p) != null) p = link(p);
		link(p) = new_glue(ss_glue); return hpack(b, w, exactly);
	}
	else {
		width(b) = w; return b;
	}
}

// 716
pointer math_glue(pointer g, scaled m)
{
	pointer p;
	int n;
	scaled f;

	n = x_over_n(m, 0200000); f = _remainder;
	if (f < 0) {
		decr(n); f += 0200000;
	}
	p = get_node(glue_spec_size); width(p) = mu_mult(width(g));

	stretch_order(p) = stretch_order(g);
	if (stretch_order(p) == normal) stretch(p) = mu_mult(stretch(g));
	else stretch(p) = stretch(g);

	shrink_order(p) = shrink_order(g);
	if (shrink_order(p) == normal) shrink(p) = mu_mult(shrink(g));
	else shrink(p) = shrink(g);

	return p;
}

// 717
void math_kern(pointer p, scaled m)
{
	int n;
	scaled f;

	if (subtype(p) == mu_glue) {
		n = x_over_n(m, 0200000); f = _remainder;
		if (f < 0) {
			decr(n); f += 0200000;
		}
		width(p) = mu_mult(width(p)); subtype(p) = _explicit;
	}
}

// 718
void flush_math()
{
	flush_node_list(link(head)); flush_node_list(incompleat_noad); link(head) = null; tail = head;
	incompleat_noad = null;
}

// 720
pointer clean_box(pointer p, small_number s)
{
	pointer q;
	small_number save_style;
	pointer x;
	pointer r;

	switch (math_type(p)) {
	case math_char:
		cur_mlist = new_noad(); mem[nucleus(cur_mlist)] = mem[p];
		break;
	case sub_box:
		q = info(p); goto found;
		break;
	case sub_mlist:
		cur_mlist = info(p);
		break;
	default:
		q = new_null_box(); goto found;
		break;
	}
	save_style = cur_style; cur_style = s; mlist_penalties = false;
	mlist_to_hlist(); q = link(temp_head);
	cur_style = save_style;

	#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703>
	if (cur_style < script_style) cur_size = text_size;
	else cur_size = 16 * ((cur_style - text_style) / 2);
	cur_mu = x_over_n(math_quad(cur_size), 18);
	#pragma endregion
found:
	if (is_char_node(q) || q == null) x = hpack(q, natural);
	else if (link(q) == null && type(q) <= vlist_node && shift_amount(q) == 0) x = q;
	else x = hpack(q, natural);

	#pragma region <Simplify a trivial box 721>
		 q = list_ptr(x);
		 if (is_char_node(q)) {
			 r = link(q);
			 if(r!=null)
				 if(link(r) == null)
					 if(!is_char_node(r))
						 if (type(r) == kern_node) {
							 free_node(r, small_node_size); link(q) = null;
						 }
		 }
	#pragma endregion
	return x;
}


// 722
void fetch(pointer a)
{
	cur_c = character(a); cur_f = fam_fnt(fam(a) + cur_size);
	if (cur_f == null_font)

	#pragma region <Complain about an undefined family and set cur_i null 723>
	{
		print_err(TEX_STRING("")); print_size(cur_size); print_char(TEX_STRING(" ")); print_int(fam(a));
		print(TEX_STRING(" is undefined (character ")); print_ASCII(qo(cur_c)); print_char(TEX_STRING(")"));
		help4(TEX_STRING("Somewhere in the math formula just ended, you used the"),
			TEX_STRING("stated character from an undefined font family. For example,"),
			TEX_STRING("plain TeX doesn't allow \it or \sl in subscripts. Proceed,"),
			TEX_STRING("and I'll try to forget that I needed that character."));
		error();
		cur_i = null_character;
		math_type(a) = empty;
	}
	#pragma endregion
	else {
		if (qo(cur_c) >= font_bc[cur_f] && qo(cur_c) <= font_ec[cur_f])
			cur_i = char_info(cur_f, cur_c);
		else cur_i = null_character;
		if (!char_exists(cur_i)) {
			char_warning(cur_f, qo(cur_c)); math_type(a) = empty;
		}
	}
}


//726
void mlist_to_hlist()
{
	pointer mlist;
	bool penalties;
	small_number style;
	small_number save_style;
	pointer q;
	pointer r;
	small_number r_type;
	small_number t;
	pointer p, x, y, z;
	int pen;
	small_number s;
	scaled max_h, max_d;
	scaled delta;

	mlist = cur_mlist; penalties = mlist_penalties; style = cur_style;
	q = mlist; r = null; r_type = op_noad; max_h = 0; max_d = 0;
	#pragma region <Set up values of cur_size and cur_mu, based on cur_style 703>
	if (cur_style < script_style) cur_size = text_size;
	else cur_size = 16 * ((cur_style - text_style) / 2);
	cur_mu = x_over_n(math_quad(cur_size), 18);
	#pragma endregion
	while (q != null)
		#pragma region <Process node-or_noad q as much as possible in preparation for the second pass mlist_to_hlist.. 727>
	{
		#pragma region <Do first-pass processing based on type(q); goto done_with_noad if a noad has been .. 728>
	reswitch:
			delta = 0;
			switch (type(q)) {
			case bin_noad:
				switch (r_type) {
				case bin_noad:
				case op_noad:
				case rel_noad:
				case open_noad:
				case punct_noad:
				case left_noad:
					type(q) = ord_noad;
					goto reswitch;
					break;
				default:
					//do_nothing
					break;
				}
				break;

			case rel_noad:
			case close_noad:
			case punct_noad:
			case right_noad:
				#pragma region <Convert a final bin_noad to an ord_noad 729>
				if (r_type == bin_noad) type(r) = ord_noad;
				#pragma endregion
				if (type(q) == right_noad) goto done_with_noad;
				break;

			#pragma region <Cases for noads that can follow a bin_noad 733>
			case left_noad:
				goto done_with_noad;
				break;
			case fraction_noad:
				make_fraction(q); goto check_dimensions;
				break;
			case op_noad:
				delta = make_op(q);
				if (subtype(q) == limits) goto check_dimensions;
				break;
			case ord_noad: make_ord(q); break;
			case open_noad: case inner_noad: /*do_nothing*/ break;
			case radical_noad: make_radical(q); break;
			case over_noad: make_over(q); break;
			case under_noad: make_under(q); break;
			case accent_noad: make_math_accent(q); break;
			case vcenter_noad: make_vcenter(q); break;
			#pragma endregion

			#pragma region <Cases for nodes that can appear in an mlist, after which we goto done_with_node 730>
			case style_node:
				cur_style = subtype(q);
				#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703
				if (cur_style < script_style) cur_size = text_size;
				else cur_size = 16 * ((cur_style - text_style) / 2);
				cur_mu = x_over_n(math_quad(cur_size), 18);
				#pragma endregion
				goto done_with_node;
				break;
			case choice_node:
				#pragma region <Change this node to a style node followed by the correct choice, then goto done_with_node 731>
				switch (cur_style / 2) {
				case 0: choose_mlist(display_mlist); break;
				case 1: choose_mlist(text_mlist); break;
				case 2: choose_mlist(script_mlist); break;
				case 3: choose_mlist(script_script_mlist); break;
				}
				flush_node_list(display_mlist(q)); flush_node_list(text_mlist(q)); flush_node_list(script_mlist(q));
				flush_node_list(script_script_mlist(q));
				type(q) = style_node; subtype(q) = cur_style; width(q) = 0; depth(q) = 0;
				if (p != null) {
					z = link(q); link(q) = p;
					while (link(p) != null) p = link(p);
					link(p) = z;
				}
				goto done_with_node;
				#pragma endregion
				break;

			case ins_node:
			case mark_node:
			case adjust_node:
			case whatsit_node:
			case penalty_node:
			case disc_node:
				goto done_with_node;
				break;

			case rule_node:
				if (height(q) > max_h) max_h = height(q);
				if (depth(q) > max_d) max_d = depth(q);
				goto done_with_node;
				break;

			case glue_node:
				#pragma region <Convert math glue to ordinary glue 732>
				if (subtype(q) == mu_glue) {
					x = glue_ptr(q); y = math_glue(x, cur_mu); delete_glue_ref(x); glue_ptr(q) = y;
					subtype(q) = normal;
				}
				else if (cur_size != text_size && subtype(q) == cond_math_glue) {
					p = link(q);
					if(p!=null)
						if (type(p) == glue_node || type(p) == kern_node) {
							link(q) = link(p); link(p) = null; flush_node_list(p);
						}
				}
				#pragma endregion
				goto done_with_node;
				break;

			case kern_node:
				math_kern(q, cur_mu); goto done_with_node;
				break;
			#pragma endregion

			default: confusion(TEX_STRING("mlist1")); break;
			}
			#pragma region <Convert nucleus(q) to an hlist and attach the sub/superscripts 754>
			switch (math_type(nucleus(q))) {
			case math_char:
			case math_text_char:
				#pragma region <Create a character node p for nucleus(q), possibly followed by a kern node .. 755>
			{
				fetch(nucleus(q));
				if (char_exists(cur_i)) {
					delta = char_italic(cur_f, cur_i); p = new_character(cur_f, qo(cur_c));
					if (math_type(nucleus(q)) == math_text_char && space(cur_f) != 0) delta = 0;
					if (math_type(subscr(q)) == empty && delta != 0) {
						link(p) = new_kern(delta); delta = 0;
					}
				}
				else p = null;
			}
				#pragma endregion
				break;
			case empty:
				p = null;
				break;
			case sub_box:
				p = info(nucleus(q));
				break;
			case sub_mlist:
				cur_mlist = info(nucleus(q)); save_style = cur_style; mlist_penalties = false;
				mlist_to_hlist();
				cur_style = save_style;
				#pragma region <Set up the values of cur_size and cur_mu, base on cur_style 703>
				if (cur_style < script_style) cur_size = text_size;
				else cur_size = 16 * ((cur_style - text_style) / 2);
				cur_mu = x_over_n(math_quad(cur_size), 18);
				#pragma endregion
				p = hpack(link(temp_head), natural);
				break;
			default:
				confusion(TEX_STRING("mlist2"));
				break;
			}
			new_hlist(q) = p;
			if (math_type(subscr(q)) == empty && math_type(supscr(q)) == empty) goto check_dimensions;
			make_scripts(q, delta);
			#pragma endregion

		#pragma endregion
	check_dimensions:
		z = hpack(new_hlist(q), natural);
		if (height(z) > max_h) max_h = height(z);
		if (depth(z) > max_d) max_d = depth(z);
		free_node(z, box_node_size);
	done_with_noad:
		r = q; r_type = type(r);
	done_with_node:
		q = link(q);
	}
		#pragma endregion

	#pragma region <convert a final bin_noad to an ord_noad 729>
	if (r_type == bin_noad) type(r) = ord_noad;
	#pragma endregion

	#pragma region <Make a second pass over the mlist, removing all noads and inserting the proper spacing and penalties 760>
	p = temp_head; link(p) = null; q = mlist; r_type = 0; cur_style = style;
	#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703>
	if (cur_style < script_style) cur_size = text_size;
	else cur_size = 16 * ((cur_style - text_style) / 2);
	cur_mu = x_over_n(math_quad(cur_size), 18);
	#pragma endregion
	while (q != null) {
		#pragma region <If node q is a style node, change the style and goto delete_q; .. 761>
		t = ord_noad; s = noad_size; pen = inf_penalty;
		switch (type(q)) {
		case op_noad:
		case open_noad:
		case close_noad:
		case punct_noad:
		case inner_noad:
			t = type(q);
			break;
		case bin_noad:
			t = bin_noad;
			pen = bin_op_penalty;
			break;
		case rel_noad:
			t = rel_noad; pen = rel_penalty;
			break;
		case ord_noad:
		case vcenter_noad:
		case over_noad:
		case under_noad:
			//do_nothing
			break;
		case radical_noad:
			s = radical_noad_size;
			break;
		case accent_noad:
			s = accent_noad_size;
			break;
		case fraction_noad:
			t = inner_noad;
			s = fraction_noad_size;
			break;
		case left_noad:
		case right_noad:
			t = make_left_right(q, style, max_d, max_h);
			break;
		case style_node:
			#pragma region <Change the current style and goto delete_q 763>
			cur_style = subtype(q); s = style_node_size;
			#pragma region <Set up the values of cur_size and cur_mu, based on cur_style 703>
			if (cur_style < script_style) cur_size = text_size;
			else cur_size = 16 * ((cur_style - text_style) / 2);
			cur_mu = x_over_n(math_quad(cur_size), 18);
			#pragma endregion
			goto delete_q;
			#pragma endregion
			break;
		case whatsit_node:
		case penalty_node:
		case rule_node:
		case disc_node:
		case adjust_node:
		case ins_node:
		case mark_node:
		case glue_node:
		case kern_node:
			link(p) = q; p = q; q = link(q); link(p) = null; goto done;
			break;
		default:
			confusion(TEX_STRING("mlist3"));
			break;
		}
		#pragma endregion

		#pragma region <Append inter-element spacing based on r_type and t 766>
		if (r_type > 0) {
			switch (so(str_pool[r_type * 8 + t + magic_offset])) {
			case TEX_STRING("0"): x = 0; break;
			case TEX_STRING("1"): if (cur_style < script_style) x = thin_mu_skip_code; else x = 0; break;
			case TEX_STRING("2"): x = thin_mu_skip_code; break;
			case TEX_STRING("3"): if (cur_style < script_style) x = med_mu_skip_code; else x = 0; break;
			case TEX_STRING("4"): if (cur_style < script_style) x = thick_mu_skip_code; else x = 0; break;
			default:
				confusion(TEX_STRING("mlist4"));
				break;
			}
			if (x != 0) {
				y = math_glue(glue_par(x), cur_mu); z = new_glue(y); glue_ref_count(y) = null;
				link(p) = z; p = z;
				subtype(z) = x + 1;
			}
		}
		#pragma endregion

		#pragma region <Append any new_hlist entries for q, and any appropriate penalties 767>
		if (new_hlist(q) != null) {
			link(p) = new_hlist(q);
			do {
				p = link(p);
			} while (!(link(p) == null));
		}
		if(penalties)
			if(link(q)!=null)
				if (pen < inf_penalty) {
					r_type = type(link(q));
					if(r_type != penalty_node)
						if (r_type != rel_noad) {
							z = new_penalty(pen); link(p) = z; p = z;
						}
				}
		#pragma endregion
		r_type = t;
	delete_q:
		r = q; q = link(q); free_node(r, s);
	done:;
	}

	#pragma endregion

}


// 734
void make_over(pointer q)
{
	info(nucleus(q)) = overbar(clean_box(nucleus(q), cramped_style(cur_style)), 3 * default_rule_thickness, default_rule_thickness);
	math_type(nucleus(q)) = sub_box;
}

// 735
void make_under(pointer q)
{
	pointer p, x, y;
	scaled delta;

	x = clean_box(nucleus(q), cur_style); p = new_kern(3 * default_rule_thickness); link(x) = p;
	link(p) = fraction_rule(default_rule_thickness); y = vpack(x, natural);
	delta = height(y) + depth(y) + default_rule_thickness; height(y) = height(x);
	depth(y) = delta - height(y); info(nucleus(q)) = y; math_type(nucleus(q)) = sub_box;
}

// 736
void make_vcenter(pointer q)
{
	pointer v;
	scaled delta;

	v = info(nucleus(q));
	if (type(v) != vlist_node) confusion(TEX_STRING("vcenter"));
	delta = height(v) + depth(v); height(v) = axis_height(cur_size) + half(delta);
	depth(v) = delta - height(v);
}


// 737
void make_radical(pointer q)
{
	pointer x, y;
	scaled delta, clr;

	x = clean_box(nucleus(q), cramped_style(cur_style));
	if (cur_style < text_style)
		clr = default_rule_thickness + (myabs(math_x_height(cur_size)) / 4);
	else {
		clr = default_rule_thickness; clr += myabs(clr) / 4;
	}
	y = var_delimiter(left_delimiter(q), cur_size, height(x) + depth(x) + clr + default_rule_thickness);
	delta = depth(y) - (height(x) + depth(x) + clr);
	if (delta > 0) clr += half(delta);
	shift_amount(y) = -(height(x) + clr); link(y) = overbar(x, clr, height(y));
	info(nucleus(q)) = hpack(y, natural); math_type(nucleus(q)) = sub_box;
}


// 738
void make_math_accent(pointer q)
{
	pointer p, x, y;
	int a;
	quarterword c;
	internal_font_number f;
	four_quarters i;
	scaled s;
	scaled h;
	scaled delta;
	scaled w;

	fetch(accent_chr(q));
	if (char_exists(cur_i)) {
		i = cur_i; c = cur_c; f = cur_f;

		#pragma region <Compute the amount of skew 741>
		s = 0;
		if (math_type(nucleus(q)) == math_char) {
			fetch(nucleus(q));
			if (char_tag(cur_i) == lig_tag) {
				a = lig_kern_start(cur_f, cur_i); cur_i = font_info[a].qqqq;
				if (skip_byte(cur_i) > stop_flag) {
					a = lig_kern_restart(cur_f, cur_i); cur_i = font_info[a].qqqq;
				}
				while(1) {
					if (qo(next_char(cur_i)) == skew_char[cur_f]) {
						if (op_byte(cur_i) >= kern_flag)
							if (skip_byte(cur_i) <= stop_flag) s = char_kern(cur_f, cur_i);
						goto done1;
					}
					if (skip_byte(cur_i) >= stop_flag) goto done1;
					a += qo(skip_byte(cur_i)) + 1; cur_i = font_info[a].qqqq;
				}
			}
		}
	done1:

		#pragma endregion
	
		x = clean_box(nucleus(q), cramped_style(cur_style)); w = width(x); h = height(x);

		#pragma region <Switch to a larger accent if available and appropriate 740>
		while (1) {
			if (char_tag(i) != list_tag) goto done;
			y = rem_byte(i); i = char_info(f, y);
			if (!char_exists(i)) goto done;
			if (char_width(f, i) > w) goto done;
			c = (quarterword)y;
			
		}
	done:

		#pragma endregion

		if (h < x_height(f)) delta = h; else delta = x_height(f);
		if(math_type(supscr(q)) != empty || math_type(subscr(q))!= empty)
			if (math_type(nucleus(q)) == math_char)
				#pragma region <Swap the subscript and superscript into box x 742>
			{
				flush_node_list(x); x = new_noad(); mem[nucleus(x)] = mem[nucleus(q)];
				mem[supscr(x)] = mem[supscr(q)]; mem[subscr(x)] = mem[subscr(q)];
				mem[supscr(q)].hh = empty_field; mem[subscr(q)].hh = empty_field;
				math_type(nucleus(q)) = sub_mlist; info(nucleus(q)) = x; x = clean_box(nucleus(q), cur_style);
				delta += height(x) - h; h = height(x);
			}
				#pragma endregion
		y = char_box(f, c); shift_amount(y) = s + half(w - width(y)); width(y) = 0; p = new_kern(-delta);
		link(p) = x; link(y) = p; y = vpack(y, natural); width(y) = width(x);
		if (height(y) < h)
			#pragma region <Make the height of box y equal to h 739>
		{
			p = new_kern(h - height(y)); link(p) = list_ptr(y); list_ptr(y) = p; height(y) = h;
		}
			#pragma endregion
		info(nucleus(q)) = y; math_type(nucleus(q)) = sub_box;


	}
}

// 743
void make_fraction(pointer q)
{
	pointer p, v, x, y, z;
	scaled delta, delta1, delta2, shift_up, shift_down, clr;

	if (thickness(q) == default_code) thickness(q) = default_rule_thickness;

	#pragma region <Create equal-width boxes x and z for the numerator and denominator, and compute.. 744>
	x = clean_box(numerator(q), num_style(cur_style));
	z = clean_box(denominator(q), denom_style(cur_style));
	if (width(x) < width(z)) x = rebox(x, width(z));
	else z = rebox(z, width(x));
	if (cur_style < text_style) {
		shift_up = num1(cur_size); shift_down = denom1(cur_size);
	}
	else {
		shift_down = denom2(cur_size);
		if (thickness(q) != 0) shift_up = num2(cur_size);
		else shift_up = num3(cur_size);
	}
	#pragma endregion

	if (thickness(q) == 0)
		#pragma region <Adjust shift_up and shift_down for the case of no fraction line 745>
	{
		if (cur_style < text_style) clr = 7 * default_rule_thickness;
		else clr = 3 * default_rule_thickness;
		delta = half(clr - ((shift_up - depth(x)) - (height(z) - shift_down)));
		if (delta > 0) {
			shift_up += delta; shift_down += delta;
		}
	}
		#pragma endregion
	else
		#pragma region <Adjust shift_up and shift_down for the case of a fraction line 746>
	{
		if (cur_style < text_style) clr = 3 * thickness(q);
		else clr = thickness(q);
		delta = half(thickness(q)); delta1 = clr - ((shift_up - depth(x)) - (axis_height(cur_size) + delta));
		delta2 = clr - ((axis_height(cur_size) - delta) - (height(z) - shift_down));
		if (delta1 > 0) shift_up += delta1;
		if (delta2 > 0) shift_down += delta2;
	}
		#pragma endregion

	#pragma region <Construct a vlist box for the fraction, according to shift_up and shift_down 747>
	v = new_null_box(); type(v) = vlist_node; height(v) = shift_up + height(x);
	depth(v) = depth(z) + shift_down; width(v) = width(x);
	if (thickness(q) == 0) {
		p = new_kern((shift_up - depth(x)) - (height(z) - shift_down)); link(p) = z;
	}
	else {
		y = fraction_rule(thickness(q));
		p = new_kern((axis_height(cur_size) - delta) - (height(z) - shift_down));
		link(y) = p; link(p) = z;
		p = new_kern((shift_up - depth(x)) - (axis_height(cur_size) + delta)); link(p) = y;
	}
	link(x) = p; list_ptr(v) = x;
	#pragma endregion

	#pragma region <Put the fraction into a box with its delimiters, and make new_hlsit(q) point to it 748>
	if (cur_style < text_style) delta = delim1(cur_size);
	else delta = delim2(cur_size);
	x = var_delimiter(left_delimiter(q), cur_size, delta); link(x) = v;
	z = var_delimiter(right_delimiter(q), cur_size, delta); link(v) = z;
	new_hlist(q) = hpack(x, natural);
	#pragma endregion


}



// 749

scaled make_op(pointer q)
{
	scaled delta;
	pointer p, v, x, y, z;
	quarterword c;
	four_quarters i;
	scaled shift_up, shift_down;


	if (subtype(q) == normal && cur_style < text_style) subtype(q) = limits;
	if (math_type(nucleus(q)) == math_char) {
		fetch(nucleus(q));
		if (cur_style < text_style && char_tag(cur_i) == list_tag) {
			c = rem_byte(cur_i); i = char_info(cur_f, c);
			if (char_exists(i)) {
				cur_c = c; cur_i = i; character(nucleus(q)) = c;
			}
		}
		delta = char_italic(cur_f, cur_i); x = clean_box(nucleus(q), cur_style);
		if (math_type(subscr(q)) != empty && subtype(q) != limits) width(x) -= delta;
		shift_amount(x) = half(height(x) - depth(x)) - axis_height(cur_size);
		math_type(nucleus(q)) = sub_box; info(nucleus(q)) = x;
	}
	else delta = 0;
	if (subtype(q) == limits)
		#pragma region <Construct a box with limits above and below it, skewed by delta 750>
	{
		x = clean_box(supscr(q), sup_style(cur_style)); y = clean_box(nucleus(q), cur_style);
		z = clean_box(subscr(q), sub_style(cur_style)); v = new_null_box(); type(v) = vlist_node;
		width(v) = width(y);
		if (width(x) > width(v)) width(v) = width(x);
		if (width(z) > width(v)) width(v) = width(z);
		x = rebox(x, width(v)); y = rebox(y, width(v)); z = rebox(z, width(v));
		shift_amount(x) = half(delta); shift_amount(z) = -shift_amount(x); height(v) = height(y);
		depth(v) = depth(y);
		#pragma region <Attach the limits to y and adjust height(v), depth(v) to account for their presence 751>
		if (math_type(supscr(q)) == empty) {
			free_node(x, box_node_size); list_ptr(v) = y;
		}
		else {
			shift_up = big_op_spacing3 - depth(x);
			if (shift_up < big_op_spacing1) shift_up = big_op_spacing1;
			p = new_kern(shift_up); link(p) = y; link(x) = p;
			p = new_kern(big_op_spacing5); link(p) = x; list_ptr(v) = p;
			height(v) += big_op_spacing5 + height(x) + depth(x) + shift_up;
		}
		if (math_type(subscr(q)) == empty) free_node(z, box_node_size);
		else {
			shift_down = big_op_spacing4 - height(z);
			if (shift_down < big_op_spacing2) shift_down = big_op_spacing2;
			p = new_kern(shift_down); link(y) = p; link(p) = z;
			p = new_kern(big_op_spacing5); link(z) = p;
			depth(v) += big_op_spacing5 + height(z) + depth(z) + shift_down;
		}
		#pragma endregion
		new_hlist(q) = v;
	}
		#pragma endregion
	return delta;
}

// 752
void make_ord(pointer q)
{
	int a;
	pointer p, r;

restart:
	if(math_type(subscr(q)) == empty)
		if(math_type(supscr(q)) == empty)
			if (math_type(nucleus(q)) == math_char) {
				p = link(q);
				if(p!=null)
					if(type(p) >= ord_noad && type(p) <= punct_noad)
						if(math_type(nucleus(p)) == math_char)
							if (fam(nucleus(p)) == fam(nucleus(q))) {
								math_type(nucleus(q)) = math_text_char; fetch(nucleus(q));
								if (char_tag(cur_i) == lig_tag) {
									a = lig_kern_start(cur_f, cur_i); cur_c = character(nucleus(p));
									cur_i = font_info[a].qqqq;
									if (skip_byte(cur_i) > stop_flag) {
										a = lig_kern_restart(cur_f, cur_i); cur_i = font_info[a].qqqq;
									}
									while (1) {
										#pragma region <If instruction cur_i is a kern with cur_c, attach the kern after q; or.. 753>
										if(next_char(cur_i) == cur_c)
											if(skip_byte(cur_i)<=stop_flag)
												if (op_byte(cur_i) >= kern_flag) {
													p = new_kern(char_kern(cur_f, cur_i)); link(p) = link(q); link(q) = p; return;
												}
												else {
													check_interrupt;
													switch (op_byte(cur_i)) {
													case qi(1):
													case qi(5):
														character(nucleus(q)) = rem_byte(cur_i);
														break;
													case qi(2):
													case qi(6):
														character(nucleus(p)) = rem_byte(cur_i);
														break;
													case qi(3):
													case qi(7):
													case qi(11):
														r = new_noad();
														character(nucleus(r)) = rem_byte(cur_i); fam(nucleus(r)) = fam(nucleus(q));
														link(q) = r; link(r) = p;
														if (op_byte(cur_i) < qi(11)) math_type(nucleus(r)) = math_char;
														else math_type(nucleus(r)) = math_text_char;
														break;
													default:
														link(q) = link(p); character(nucleus(q)) = rem_byte(cur_i);
														mem[subscr(q)] = mem[subscr(p)]; mem[supscr(q)] = mem[supscr(p)];
														free_node(p, noad_size);
														break;
													}
													if (op_byte(cur_i) > qi(3)) return;
													math_type(nucleus(q)) = math_char; goto restart;
												}
										#pragma endregion
										if (skip_byte(cur_i) >= stop_flag) return;
										a += qo(skip_byte(cur_i)) + 1; cur_i = font_info[a].qqqq;
									}
								}
							}
			}
}


// 756
void make_scripts(pointer q, scaled delta)
{
	pointer p, x, y, z;
	scaled shift_up, shift_down, clr;
	small_number t;

	p = new_hlist(q);
	if (is_char_node(p)) {
		shift_up = 0; shift_down = 0;
	}
	else {
		z = hpack(p, natural);
		if (cur_style < script_style) t = script_size; else t = script_script_size;
		shift_up = height(z) - sup_drop(t); shift_down = depth(z) + sub_drop(t); free_node(z, box_node_size);
	}
	if (math_type(supscr(q)) == empty)
		#pragma region <Construct a subscript box x when there is no superscript 757>
	{
		x = clean_box(subscr(q), sub_style(cur_style)); width(x) += script_space;
		if (shift_down < sub1(cur_size)) shift_down = sub1(cur_size);
		clr = height(x) - (myabs(math_x_height(cur_size)*4) / 5);
		if (shift_down < clr) shift_down = clr;
		shift_amount(x) = shift_down;
	}
		#pragma endregion
	else {
		#pragma region <Construct a superscript box x 758>
		{
			x = clean_box(supscr(q), sup_style(cur_style)); width(x) += script_space;
			if (myodd(cur_style)) clr = sup3(cur_size);
			else if (cur_style < text_style) clr = sup1(cur_size);
			else clr = sup2(cur_size);
			if (shift_up < clr) shift_up = clr;
			clr = depth(x) + (myabs(math_x_height(cur_size)) / 4);
			if (shift_up < clr) shift_up = clr;
		}
		#pragma endregion
		if (math_type(subscr(q)) == empty) shift_amount(x) = -shift_up;
		else
			#pragma region <Construct a sub/superscript combination box x, with the superscript offset by delta 759>
		{
			y = clean_box(subscr(q), sub_style(cur_style)); width(y) += script_space;
			if (shift_down < sub2(cur_size)) shift_down = sub2(cur_size);
			clr = 4 * default_rule_thickness - ((shift_up - depth(x)) - (height(y) - shift_down));
			if (clr > 0) {
				shift_down += clr;
				clr = (myabs(math_x_height(cur_size) * 4) / 5) - (shift_up - depth(x));
				if (clr > 0) {
					shift_up += clr; shift_down -= clr;
				}
			}
			shift_amount(x) = delta;
			p = new_kern((shift_up - depth(x)) - (height(y) - shift_down)); link(x) = p; link(p) = y;
			x = vpack(x, natural); shift_amount(x) = shift_down;
		}
			#pragma endregion

	}
	if (new_hlist(q) == null) new_hlist(q) = x;
	else {
		p = new_hlist(q);
		while (link(p) != null) p = link(p);
		link(p) = x;
	}
}


// 762
small_number make_left_right(pointer q, small_number style, scaled max_d, scaled max_h)
{
	scaled delta, delta1, delta2;

	if (style < script_style) cur_size = text_size;
	else cur_size = 16 * ((style - text_style) / 2);
	delta2 = max_d + axis_height(cur_size); delta1 = max_h + max_d - delta2;
	if (delta2 > delta1) delta1 = delta2;
	delta = (delta1 / 500) * delimiter_factor; delta2 = delta1 + delta1 - delimiter_shortfall;
	if (delta < delta2) delta = delta2;
	new_hlist(q) = var_delimiter(delimiter(q), cur_size, delta);
	return type(q) - (left_noad - open_noad);
}


// 772
void push_alignment()
{
	pointer p;
	p = get_node(align_stack_node_size); link(p) = align_ptr; info(p) = cur_align;
	llink(p) = preamble; rlink(p) = cur_span; mem[p + 2].an_int = cur_loop; mem[p + 3].an_int = align_state;
	info(p + 4) = cur_head; link(p + 4) = cur_tail; align_ptr = p; cur_head = get_avail();
}

void pop_alignment()
{
	pointer p;
	free_avail(cur_head); p = align_ptr; cur_tail = link(p + 4); cur_head = info(p + 4);
	align_state = mem[p + 3].an_int; cur_loop = mem[p + 2].an_int; cur_span = rlink(p);
	preamble = llink(p);
	cur_align = info(p); align_ptr = link(p); free_node(p, align_stack_node_size);
}

// 785
void align_peek()
{
restart:
	align_state = 1000000;
	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_cmd == no_align) {
		scan_left_brace(); new_save_level(no_align_group);
		if (mode == -vmode) normal_paragraph();
	}
	else if (cur_cmd == right_brace) fin_align();
	else if (cur_cmd == car_ret && cur_chr == cr_cr_code) goto restart;
	else {
		init_row();
		init_col();
	}
}

// 786
void init_row()
{
	push_nest(); mode = mode_type((-hmode - vmode) - mode);
	if (mode == -hmode) space_factor = 0;
	else prev_depth = 0;
	tail_append(new_glue(glue_ptr(preamble))); subtype(tail) = tab_skip_code + 1;
	cur_align = link(preamble); cur_tail = cur_head; init_span(cur_align);
}

// 787
void init_span(pointer p)
{
	push_nest();
	if (mode == -hmode) space_factor = 1000;
	else {
		prev_depth = ignore_depth; normal_paragraph();
	}
	cur_span = p;
}
//788
void init_col()
{
	extra_info(cur_align) = cur_cmd;
	if (cur_cmd == omit) align_state = 0;
	else {
		back_input(); begin_token_list(u_part(cur_align), u_template);
	}
}

// 577
void scan_font_ident()
{
	internal_font_number f;
	halfword m;

	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_cmd == def_font)
		f = cur_font;
	else if (cur_cmd == set_font)
		f = cur_chr;
	else if (cur_cmd == def_family) {
		m = cur_chr;
		scan_four_bit_int();
		f = equiv(m + cur_val);
	}
	else {
		print_err(TEX_STRING("Missing font identifier"));
		help2(TEX_STRING("I was looking for a control sequence whose"),
			TEX_STRING("current meaning has been defined by \font."));
		back_error();
		f = null_font;
	}
	cur_val = f;
}

// 1136
void push_math(group_code c)
{
	push_nest(); mode = (mode_type)-mmode; incompleat_noad = null; new_save_level(c);
}

// 1174
void build_choices()
{
	pointer p;
	unsave(); p = fin_mlist(null);
	switch (saved(-1)) {
	case 0: display_mlist(tail) = p; break;
	case 1: text_mlist(tail) = p; break;
	case 2: script_mlist(tail) = p; break;
	case 3: script_script_mlist(tail) = p; decr(save_ptr); goto _exit; break;

	}
	incr(saved(-1)); push_math(math_choice_group); scan_left_brace();
_exit:
	;
}

// 800
void fin_align()
{
	pointer p, q, r, s, u, v;
	scaled t, w;
	scaled o;
	halfword n;
	scaled rule_save;
	memory_word aux_save;

	if (cur_group != align_group) confusion(TEX_STRING("align1"));
	unsave();
	if (cur_group != align_group) confusion(TEX_STRING("align0"));
	unsave();
	if (nest[nest_ptr - 1].mode_field == mmode) o = display_indent;
	else o = 0;

	#pragma region <Go through the preamble list, determining the column widths and changing the alignrecords to dummy unset boxes 801>
	q = link(preamble);
	do {
		flush_list(u_part(q)); flush_list(v_part(q)); p = link(link(q));

		if (width(q) == null_flag)
			#pragma region <Nullify width(q) and the tabskip glue following this column 802>
		{
			width(q) = 0; r = link(q); s = glue_ptr(r);
			if (s != zero_glue) {
				add_glue_ref(zero_glue); delete_glue_ref(s); glue_ptr(r) = zero_glue;
			}
		}
			#pragma endregion

		if (info(q) != end_span) 
			#pragma region <Merge the widths in the span nodes of q with those of p, destroying the span nodes of q 803>
		{
			t = width(q) + width(glue_ptr(link(q))); r = info(q); s = end_span; info(s) = p;
			n = min_quarterword + 1;
			do {
				width(r) = width(r) - t; u = info(r);
				while (link(r) > n) {
					s = info(s); n = link(info(s)) + 1;
				}
				if (link(r) < n) {
					info(r) = info(s); info(s) = r; decr(link(r)); s = r;
				}
				else {
					if (width(r) > width(info(s))) width(info(s)) = width(r);
					free_node(r, span_node_size);
				}
				r = u;
			} while (!(r==end_span));
		}
			#pragma endregion

		type(q) = unset_node; span_count(q) = min_quarterword; height(q) = 0; depth(q) = 0;
		glue_order(q) = normal; glue_sign(q) = normal; glue_stretch(q) = 0; glue_shrink(q) = 0; q = p;
	} while (!(q == null));
	#pragma endregion

	#pragma region <Package the preamble list, to determine the actual tabskip glue amounts and let p point to this prototype box 804>
	save_ptr -= 2; pack_begin_line = -mode_line;
	if (mode == -vmode) {
		rule_save = overfull_rule; overfull_rule = 0;
		p = hpack(preamble, saved(1), saved(0)); overfull_rule = rule_save;
	}
	else {
		q = link(preamble);
		do {
			height(q) = width(q); width(q) = 0; q = link(link(q));
		} while (!(q == null));
		p = vpack(preamble, saved(1), saved(0)); q = link(preamble);
		do {
			width(q) = height(q); height(q) = 0; q = link(link(q));
		} while (!(q == null));
	}
	pack_begin_line = 0;
	#pragma endregion

	#pragma region <Set the glue in all the unset boxes of the current list 805>
	q = link(head); s = head;
	while (q != null) {
		if(!is_char_node(q))
			if (type(q) == unset_node)
				#pragma region <Set the unset box q and the unset boxes in it 807>
			{
				if (mode == -vmode) {
					type(q) = hlist_node; width(q) = width(p);
				}
				else {
					type(q) = vlist_node; height(q) = height(p);
				}
				glue_order(q) = glue_order(p); glue_sign(q) = glue_sign(p); glue_set(q) = glue_set(p);
				shift_amount(q) = o; r = link(list_ptr(q)); s = link(list_ptr(p));
				do {
					#pragma region <Set the glue in node r and change it from an unset node 808>
					n = span_count(r); t = width(s); w = t; u = hold_head;
					while (n > min_quarterword) {
						decr(n);
						#pragma region <Append tabskip glue and an empty box to list u, and update s and t as the prototype.. 809>
						s = link(s); v = glue_ptr(s); link(u) = new_glue(v); u = link(u); subtype(u) = tab_skip_code + 1;
						t += width(v);
						if (glue_sign(p) == stretching) {
							if (stretch_order(v) == glue_order(p)) {
							
								// Check for overflow
								float ftemp = round(_float(glue_set(p)) * stretch(v));
								if(ftemp > 2147483583 || ftemp < -2147483583) {
									printf("Overflow in 809.\n");
									exit(1);
								}
								/////////////////////////
								
								t += (scaled)ftemp;
							}
						}
						else if (glue_sign(p) == shrinking) {
							if(shrink_order(v) == glue_order(p)) {
							
								// Check for overflow
								float ftemp = round(_float(glue_set(p)) * shrink(v));
								if(ftemp > 2147483583 || ftemp < -2147483583) {
									printf("Overflow in 809.\n");
									exit(1);
								}
								/////////////////////////
								
								t -= (scaled)ftemp;
							}
						}
						s = link(s); link(u) = new_null_box(); u = link(u); t += width(s);
						if (mode == -vmode) width(u) = width(s);
						else {
							type(u) = vlist_node; height(u) = width(s);
						}
						#pragma endregion
					}
					if (mode == -vmode)
						#pragma region <Make the unset node r into an hlist_node of width w, setting the glue .. 810>
					{
						height(r) = height(q); depth(r) = depth(q);
						if (t == width(r)) {
							glue_sign(r) = normal; glue_order(r) = normal;
							set_glue_ratio_zero(glue_set(r));
						}
						else if (t > width(r)) {
							glue_sign(r) = stretching;
							if (glue_stretch(r) == 0) set_glue_ratio_zero(glue_set(r));
							else glue_set(r) = unfloat(float(t - width(r)) / glue_stretch(r));
						}
						else {
							glue_order(r) = glue_sign(r); glue_sign(r) = shrinking;
							if (glue_shrink(r) == 0) set_glue_ratio_zero(glue_set(r));
							else if (glue_order(r) == normal && width(r) - t > glue_shrink(r))
								set_glue_ratio_one(glue_set(r));
							else glue_set(r) = unfloat(float(width(r) - t) / glue_shrink(r));
						}
						width(r) = w; type(r) = hlist_node;
					}
						#pragma endregion
					else
						#pragma region <Make the unset node r into a vlist_node of height w, setting the glue.. 811>
					{
						width(r) = width(q);
						if (t == height(r)) {
							glue_sign(r) = normal; glue_order(r) = normal; set_glue_ratio_zero(glue_set(r));
						}
						else if (t > height(r)) {
							glue_sign(r) = stretching;
							if (glue_stretch(r) == 0) set_glue_ratio_zero(glue_set(r));
							else glue_set(r) = unfloat(float(t - height(r)) / glue_stretch(r));
						}
						else {
							glue_order(r) = glue_sign(r); glue_sign(r) = shrinking;
							if (glue_shrink(r) == 0) set_glue_ratio_zero(glue_set(r));
							else if (glue_order(r) == normal && (height(r) - t > glue_shrink(r)))
								set_glue_ratio_one(glue_set(r));
							else glue_set(r) = unfloat(float(height(r) - t) / glue_shrink(r));
						}
						height(r) = w; type(r) = vlist_node;
					}
						#pragma endregion
					shift_amount(r) = 0;
					if (u != hold_head) {
						link(u) = link(r); link(r) = link(hold_head); r = u;
					}

					#pragma endregion
					r = link(link(r)); s = link(link(s));
				} while (!(r == null));
			}
				#pragma endregion
			else if (type(q) == rule_node)
				#pragma region <Make the running dimensions in rule q extend to the boundaries of the alignment 806>
			{
				if (is_running(width(q))) width(q) = width(p);
				if (is_running(height(q))) height(q) = height(p);
				if (is_running(depth(q))) depth(q) = depth(p);
				if (o != 0) {
					r = link(q); link(q) = null; q = hpack(q, 0, additional); shift_amount(q) = o; link(q) = r;
					link(s) = q;
				}
			}
				#pragma endregion
		s = q; q = link(q);
	}
	#pragma endregion

	flush_node_list(p); pop_alignment();
	#pragma region <Insert the current list into its environment 812>
	aux_save = aux; p = link(head); q = tail; pop_nest();
	if (mode == mmode)
		#pragma region <Finish an alignment in a display 1206>
	{
		do_assignments();
		if (cur_cmd != math_shift)
			#pragma region <pontificate about improper alignment in display 1207>
		{
			print_err(TEX_STRING("Missing $$ inserted"));
			help2(TEX_STRING("Displays can use special alignments (like \eqalignno)"),
				TEX_STRING("only if nothing but the alignment itself is between $$'s."));
			back_error();
		}
			#pragma endregion
		else
			#pragma region <Check that another $ follows 1197>
		{
			get_x_token();
			if (cur_cmd != math_shift) {
				print_err(TEX_STRING("Display math should end with $$"));
				help2(TEX_STRING("The `$' that I just saw supposedly matches a previous `$$'."),
					TEX_STRING("So I shall assume that you typed `$$' both times."));
				back_error();
			}
		}
			#pragma endregion
		pop_nest(); tail_append(new_penalty(pre_display_penalty));
		tail_append(new_param_glue(above_display_skip_code)); link(tail) = p;
		if (p != null) tail = q;
		tail_append(new_penalty(post_display_penalty)); tail_append(new_param_glue(below_display_skip_code));
		prev_depth = aux_save.sc; resume_after_display();
	}
		#pragma endregion
	else {
		aux = aux_save; link(tail) = p;
		if (p != null) tail = q;
		if (mode == vmode) build_page();
	}
	#pragma endregion
}

// 1184
pointer fin_mlist(pointer p)
{
	pointer q;
	if (incompleat_noad != null) 
		#pragma region <Compleat the incompleat noad 1185>
	{
		math_type(denominator(incompleat_noad)) = sub_mlist;
		info(denominator(incompleat_noad)) = link(head);
		if (p == null) q = incompleat_noad;
		else {
			q = info(numerator(incompleat_noad));
			if (type(q) != left_noad) confusion(TEX_STRING("right"));
			info(numerator(incompleat_noad)) = link(q);
			link(q) = incompleat_noad;
			link(incompleat_noad) = p;
		}
	}
		#pragma endregion
	else {
		link(tail) = p; q = link(head);
	}
	pop_nest();
	return q;
}

// 259
pointer id_lookup(int j, int l)
{
	int h, d;
	pointer p, k;

	#pragma region	<Compute the hash code h 261>
	h = buffer[j];
	for (k = j + 1; k <= j + l - 1; k++) {
		h = h + h + buffer[k];
		while (h >= hash_prime)
			h = h - hash_prime;
	}
	#pragma endregion

	p = h + hash_base;
	while (1) {
		if (text(p) > 0) {
			if (length(text(p)) == l) {
				if (str_eq_buf(text(p), j))
					goto found;
			}
		}
		if (next(p) == 0) {
			if (no_new_control_sequence)
				p = undefined_control_sequence;
			else 
				#pragma region   <Insert a new control sequence after p, then make p point to it 260>
			{
				if (text(p) > 0) {
					do {
						if (hash_is_full)
							overflow(TEX_STRING("hash size"), hash_size);
						decr(hash_used);
					} while (text(hash_used) != 0);
					next(p) = hash_used;
					p = hash_used;
				}
				str_room(l); d = cur_length;
				while (pool_ptr > str_start[str_ptr]) {
					decr(pool_ptr); str_pool[pool_ptr + l] = str_pool[pool_ptr];
				}
				for (k = j; k <= j + l - 1; k++) append_char(buffer[k]);
				text(p) = make_string(); pool_ptr = pool_ptr + d;
				//stat
#ifndef NO_STAT
				incr(cs_count);
#endif
				//tats
			}
				#pragma endregion
			goto found;
		}
		p = next(p);
	}
found:
	return p;
}

// 274
void new_save_level(group_code c)
{
	check_full_save_stack;
	save_type(save_ptr) = level_boundary; save_level(save_ptr) = (quarterword)cur_group;
	save_index(save_ptr) = cur_boundary;
	if (cur_level == max_quarterword)
		overflow(TEX_STRING("grouping levels"), max_quarterword - min_quarterword);
	cur_boundary = save_ptr; incr(cur_level); incr(save_ptr); cur_group = c;
}

// 281
void unsave()
{
	pointer p;
	quarterword l;
	halfword t;
	if (cur_level > level_one) {
		decr(cur_level);
		#pragma region <Clear off top level form save_stack 282>
		while (1) {
			decr(save_ptr);
			if (save_type(save_ptr) == level_boundary) goto done;
			p = save_index(save_ptr);
			if (save_type(save_ptr) == insert_token)
				#pragma region <Insert token p into TeXs input 326>
			{
				t = cur_tok; cur_tok = p; back_input(); cur_tok = t;
			}
				#pragma endregion
			else {
				if (save_type(save_ptr) == restore_old_value) {
					l = save_level(save_ptr); decr(save_ptr);
				}
				else save_stack[save_ptr] = eqtb[undefined_control_sequence];

				#pragma region <Store save_stack[save_ptr] in eqtb[p], unless eqtb[p] holds a global value 283>
				if(p < int_base)
					if (eq_level(p) == level_one) {
						eq_destroy(save_stack[save_ptr]);
						//stat
#ifndef NO_STAT
						if (tracing_restores > 0) restore_trace(p, TEX_STRING("retaining"));
#endif
						//tats
					}
					else {
						eq_destroy(eqtb[p]);
						eqtb[p] = save_stack[save_ptr];
						//stat
#ifndef NO_STAT
						if (tracing_restores > 0) restore_trace(p, TEX_STRING("restoring"));
#endif
						//tats
					}
				else if (xeq_level[p] != level_one) {
					eqtb[p] = save_stack[save_ptr]; xeq_level[p] = l;
					//stat
#ifndef NO_STAT
					if (tracing_restores > 0) restore_trace(p, TEX_STRING("restoring"));
#endif
					//tats
				}
				else {
					//stat
#ifndef NO_STAT
					if (tracing_restores > 0) restore_trace(p, TEX_STRING("retaining"));
#endif
					//tats
				}
				#pragma endregion
			}
		}
	done:
		cur_group = (group_code)save_level(save_ptr); cur_boundary = save_index(save_ptr);
		#pragma endregion
	}
	else confusion(TEX_STRING("curlevel"));
}


// 237
void print_param(int n)
{
	switch (n) {
	case pretolerance_code: print_esc(TEX_STRING("pretolerance")); break;
	case tolerance_code: print_esc(TEX_STRING("tolerance")); break;
	case line_penalty_code: print_esc(TEX_STRING("linepenalty")); break;
	case hyphen_penalty_code: print_esc(TEX_STRING("hyphenpenalty")); break;
	case ex_hyphen_penalty_code: print_esc(TEX_STRING("exhyphenpenalty")); break;
	case club_penalty_code: print_esc(TEX_STRING("clubpenalty")); break;
	case widow_penalty_code: print_esc(TEX_STRING("widowpenalty")); break;
	case display_widow_penalty_code: print_esc(TEX_STRING("displaywidowpenalty")); break;
	case broken_penalty_code: print_esc(TEX_STRING("brokenpenalty")); break;
	case bin_op_penalty_code: print_esc(TEX_STRING("binoppenalty")); break;
	case rel_penalty_code: print_esc(TEX_STRING("relpenalty")); break;
	case pre_display_penalty_code: print_esc(TEX_STRING("predisplaypenalty")); break;
	case post_display_penalty_code: print_esc(TEX_STRING("postdisplaypenalty")); break;
	case inter_line_penalty_code: print_esc(TEX_STRING("interlinepenalty")); break;
	case double_hyphen_demerits_code: print_esc(TEX_STRING("doublehyphendemerits")); break;
	case final_hyphen_demerits_code: print_esc(TEX_STRING("finalhyphendemerits")); break;
	case adj_demerits_code: print_esc(TEX_STRING("adjdemerits")); break;
	case mag_code: print_esc(TEX_STRING("mag")); break;
	case delimiter_factor_code: print_esc(TEX_STRING("delimiterfactor")); break;
	case looseness_code: print_esc(TEX_STRING("looseness")); break;
	case time_code: print_esc(TEX_STRING("time")); break;
	case day_code: print_esc(TEX_STRING("day")); break;
	case month_code: print_esc(TEX_STRING("month")); break;
	case year_code: print_esc(TEX_STRING("year")); break;
	case show_box_breadth_code: print_esc(TEX_STRING("showboxbreadth")); break;
	case show_box_depth_code: print_esc(TEX_STRING("showboxdepth")); break;
	case hbadness_code: print_esc(TEX_STRING("hbadness")); break;
	case vbadness_code: print_esc(TEX_STRING("vbadness")); break;
	case pausing_code: print_esc(TEX_STRING("pausing")); break;
	case tracing_online_code: print_esc(TEX_STRING("tracingonline")); break;
	case tracing_macros_code: print_esc(TEX_STRING("tracingmacros")); break;
	case tracing_stats_code: print_esc(TEX_STRING("tracingstats")); break;
	case tracing_paragraphs_code: print_esc(TEX_STRING("tracingparagraphs")); break;
	case tracing_pages_code: print_esc(TEX_STRING("tracingpages")); break;
	case tracing_output_code: print_esc(TEX_STRING("tracingoutput")); break;
	case tracing_lost_chars_code: print_esc(TEX_STRING("tracinglostchars")); break;
	case tracing_commands_code: print_esc(TEX_STRING("tracingcommands")); break;
	case tracing_restores_code: print_esc(TEX_STRING("tracingrestores")); break;
	case uc_hyph_code: print_esc(TEX_STRING("uchyph")); break;
	case output_penalty_code: print_esc(TEX_STRING("outputpenalty")); break;
	case max_dead_cycles_code: print_esc(TEX_STRING("maxdeadcycles")); break;
	case hang_after_code: print_esc(TEX_STRING("hangafter")); break;
	case floating_penalty_code: print_esc(TEX_STRING("floatingpenalty")); break;
	case global_defs_code: print_esc(TEX_STRING("globaldefs")); break;
	case cur_fam_code: print_esc(TEX_STRING("fam")); break;
	case escape_char_code: print_esc(TEX_STRING("escapechar")); break;
	case default_hyphen_char_code: print_esc(TEX_STRING("defaulthyphenchar")); break;
	case default_skew_char_code: print_esc(TEX_STRING("defaultskewchar")); break;
	case end_line_char_code: print_esc(TEX_STRING("endlinechar")); break;
	case new_line_char_code: print_esc(TEX_STRING("newlinechar")); break;
	case language_code: print_esc(TEX_STRING("language")); break;
	case left_hyphen_min_code: print_esc(TEX_STRING("lefthyphenmin")); break;
	case right_hyphen_min_code: print_esc(TEX_STRING("righthyphenmin")); break;
	case holding_inserts_code: print_esc(TEX_STRING("holdinginserts")); break;
	case error_context_lines_code: print_esc(TEX_STRING("errorcontextlines")); break;
	default:
		print(TEX_STRING("[unknown integer parameter!]"));
		break;
	}
}

// 247
void print_length_param(int n)
{
	switch (n) {
	case par_indent_code: print_esc(TEX_STRING("parindent")); break;
	case math_surround_code: print_esc(TEX_STRING("mathsurround")); break;
	case line_skip_limit_code: print_esc(TEX_STRING("lineskiplimit")); break;
	case hsize_code: print_esc(TEX_STRING("hsize")); break;
	case vsize_code: print_esc(TEX_STRING("vsize")); break;
	case max_depth_code: print_esc(TEX_STRING("maxdepth")); break;
	case split_max_depth_code: print_esc(TEX_STRING("splitmaxdepth")); break;
	case box_max_depth_code: print_esc(TEX_STRING("boxmaxdepth")); break;
	case hfuzz_code: print_esc(TEX_STRING("hfuzz")); break;
	case vfuzz_code: print_esc(TEX_STRING("vfuzz")); break;
	case delimiter_shortfall_code: print_esc(TEX_STRING("delimitershortfall")); break;
	case null_delimiter_space_code: print_esc(TEX_STRING("nulldelimiterspace")); break;
	case script_space_code: print_esc(TEX_STRING("scriptspace")); break;
	case pre_display_size_code: print_esc(TEX_STRING("predisplaysize")); break;
	case display_width_code: print_esc(TEX_STRING("displaywidth")); break;
	case display_indent_code: print_esc(TEX_STRING("displayindent")); break;
	case overfull_rule_code: print_esc(TEX_STRING("overfullrule")); break;
	case hang_indent_code: print_esc(TEX_STRING("hangindent")); break;
	case h_offset_code: print_esc(TEX_STRING("hoffset")); break;
	case v_offset_code: print_esc(TEX_STRING("voffset")); break;
	case emergency_stretch_code: print_esc(TEX_STRING("emergencystretch")); break;
	default:
		print(TEX_STRING("[unknown dimen parameter!]"));
		break;
	}
}


//252
//stat
#ifndef NO_STAT
void show_eqtb(pointer n)
{
	if (n < active_base) print_char(TEX_STRING("?"));
	else if (n < glue_base)
		#pragma region <Show equivalent n, in region 1 or 2 223>
	{
		sprint_cs(n); print_char(TEX_STRING("="));
		print_cmd_chr(eq_type(n), equiv(n));
		if (eq_type(n) >= call) {
			print_char(TEX_STRING(":")); show_token_list(link(equiv(n)), null, 32);
		}
	}
		#pragma endregion
	else if(n<local_base)
		#pragma region <Show equivalent n, in region 3 229>
		if (n < skip_base) {
			print_skip_param(n - glue_base); print_char(TEX_STRING("="));
			if (n < glue_base + thin_mu_skip_code) print_spec(equiv(n), TEX_STRING("pt"));
			else print_spec(equiv(n), TEX_STRING("mu"));
		}
		else if (n < mu_skip_base) {
			print_esc(TEX_STRING("skip"));
			print_int(n - skip_base);
			print_char(TEX_STRING("=")); 
			print_spec(equiv(n), TEX_STRING("pt"));
		}
		else {
			print_esc(TEX_STRING("muskip")); print_int(n - mu_skip_base);
			print_char(TEX_STRING("="));
			print_spec(equiv(n), TEX_STRING("mu"));
		}
		#pragma endregion
	else if(n<int_base)
		#pragma region <Show equivalent n, in region 4 233>
		if (n == par_shape_loc) {
			print_esc(TEX_STRING("parshape"));
			print_char(TEX_STRING("="));
			if (par_shape_ptr == null) print_char(TEX_STRING("0"));
			else print_int(info(par_shape_ptr));
		}
		else if (n < toks_base) {
			print_cmd_chr(assign_toks, n); print_char(TEX_STRING("="));
			if (equiv(n) != null) show_token_list(link(equiv(n)), null, 32);
		}
		else if (n < box_base) {
			print_esc(TEX_STRING("toks")); print_int(n - toks_base);
			print_char(TEX_STRING("="));
			if (equiv(n) != null) show_token_list(link(equiv(n)), null, 32);
		}
		else if (n < cur_font_loc) {
			print_esc(TEX_STRING("box")); print_int(n - box_base);
			print_char(TEX_STRING("="));
			if (equiv(n) == null) print(TEX_STRING("void"));
			else {
				depth_threshold = 0; breadth_max = 1; show_node_list(equiv(n));
			}
		}
		else if(n<cat_code_base) 
			#pragma region <Show the font identifier in eqtb[n] 234>
		{
			if (n == cur_font_loc) print(TEX_STRING("current font"));
			else if (n < math_font_base + 16) {
				print_esc(TEX_STRING("textfont")); print_int(n - math_font_base);
			}
			else if (n < math_font_base + 32) {
				print_esc(TEX_STRING("scriptfont")); print_int(n - math_font_base - 16);
			}
			else {
				print_esc(TEX_STRING("scriptscriptfont")); print_int(n - math_font_base - 32);
			}
			print_char(TEX_STRING("="));
			print_esc(hash[font_id_base + equiv(n)].rh);
		}
			#pragma endregion
		else 
			#pragma region <Show the halfword code in eqtb[n] 235>
			if (n < math_code_base) {
				if (n < lc_code_base) {
					print_esc(TEX_STRING("catcode")); print_int(n - cat_code_base);
				}
				else if (n < uc_code_base) {
					print_esc(TEX_STRING("lccode")); print_int(n - lc_code_base);
				}
				else if (n < sf_code_base) {
					print_esc(TEX_STRING("uccode")); print_int(n - uc_code_base);
				}
				else {
					print_esc(TEX_STRING("sfcode")); print_int(n - sf_code_base);
				}
				print_char(TEX_STRING("=")); print_int(equiv(n));
			}
			else {
				print_esc(TEX_STRING("mathcode")); print_int(n - math_code_base);
				print_char(TEX_STRING("="));
				print_int(ho(equiv(n)));
			}
			#pragma endregion
		#pragma endregion
	else if(n<dimen_base)
		#pragma region <Show equivalent n, in region 5 242>
	{
		if (n < count_base) print_param(n - int_base);
		else if (n < del_code_base) {
			print_esc(TEX_STRING("count")); print_int(n - count_base);
		}
		else {
			print_esc(TEX_STRING("delcode")); print_int(n - del_code_base);
		}
		print_char(TEX_STRING("=")); print_int(eqtb[n].an_int);
	}
		#pragma endregion
	else if(n<=eqtb_size)
		#pragma region <Show equivalent n, in region 6 251>
	{
		if (n < scaled_base) print_length_param(n - dimen_base);
		else {
			print_esc(TEX_STRING("dimen")); print_int(n - scaled_base);
		}
		print_char(TEX_STRING("=")); print_scaled(eqtb[n].sc);
		print(TEX_STRING("pt"));
	}
	#pragma endregion
	else print_char(TEX_STRING("?"));
}
#endif
//tats



//stat
#ifndef NO_STAT
void restore_trace(pointer p, str_number s)
{
	begin_diagnostic();
	print_char(TEX_STRING("{"));
	print(s);
	print_char(TEX_STRING(" ")); show_eqtb(p);
	print_char(TEX_STRING("}"));
	end_diagnostic(false);
}
#endif
//tats


//1064
void off_save()
{
	pointer p;
	if (cur_group == bottom_level)
		#pragma region <Drop current token and complain that it was unmatched 1066>
	{
		print_err(TEX_STRING("Extra ")); print_cmd_chr(cur_cmd, cur_chr);
		help1(TEX_STRING("Things are pretty mixed up, but I think the worst is over."));
		error();
	}
		#pragma endregion
	else {
		back_input(); p = get_avail(); link(temp_head) = p; print_err(TEX_STRING("Missing "));
		#pragma region <Prepare to insert a token that matches cur_group, and print what it is 1065>
		switch (cur_group) {
		case semi_simple_group:
			info(p) = cs_token_flag + frozen_end_group;
			print_esc(TEX_STRING("endgroup"));
			break;
		case math_shift_group:
			info(p) = math_shift_token + TEX_STRING("$");
			print_char(TEX_STRING("$"));
			break;
		case math_left_group:
			info(p) = cs_token_flag + frozen_right; link(p) = get_avail();
			p = link(p);
			info(p) = other_token + TEX_STRING(".");
			print_esc(TEX_STRING("right."));
			break;
		default:
			info(p) = right_brace_token + TEX_STRING("}");
			print_char(TEX_STRING("}"));
			break;
		}
		#pragma endregion

		print(TEX_STRING(" inserted")); ins_list(link(temp_head));
		help5(TEX_STRING("I've inserted something that you may have forgotten."),
			TEX_STRING("(See the <inserted text> above.)"),
			TEX_STRING("With luck, this will get me unwedged. But if you"),
			TEX_STRING("really didn't forget anything, try typing `2' now; then"),
			TEX_STRING("my insertion and my current dilemma will both disappear."));
		error();
	}
}

// 1068
void handle_right_brace()
{
	pointer p, q;
	scaled d;
	int f;
	switch (cur_group) {
	case simple_group:
		unsave();
		break;
	case bottom_level:
		print_err(TEX_STRING("Too many }'s"));
		help2(TEX_STRING("You've closed more groups than you opened."),
			TEX_STRING("Such booboos are generally harmless, so keep going."));
		error();
		break;
	case semi_simple_group:
	case math_shift_group:
	case math_left_group:
		extra_right_brace();
		break;
	#pragma region <Cases of handle_right_brace where a right_brace triggers a delayed action 1085>
	case hbox_group:
		package(0);
		break;
	case adjusted_hbox_group:
		adjust_tail = adjust_head; package(0);
		break;
	case vbox_group:
		end_graf();
		package(0);
		break;
	case vtop_group:
		end_graf();
		package(vtop_code);
		break;

		//1100
	case insert_group:
		end_graf(); q = split_top_skip; add_glue_ref(q); d = split_max_depth;
		f = floating_penalty; unsave(); decr(save_ptr);
		p = vpack(link(head), 0,additional); pop_nest();
		if (saved(0) < 255) {
			tail_append(get_node(ins_node_size)); type(tail) = ins_node; subtype(tail) = qi(saved(0));
			height(tail) = height(p) + depth(p); ins_ptr(tail) = list_ptr(p); split_top_ptr(tail) = q;
			depth(tail) = d; float_cost(tail) = f;
		}
		else {
			tail_append(get_node(small_node_size)); type(tail) = adjust_node;
			subtype(tail) = 0;
			adjust_ptr(tail) = list_ptr(p); delete_glue_ref(q);
		}
		free_node(p, box_node_size);
		if (nest_ptr == 0)
			build_page();
		break;
	case output_group:
		#pragma region <Resume the page builder after an output routine ahs come to an end 1026>
		if (loc != null || (token_type != output_text && token_type != backed_up))
			#pragma region <Recover from an unbalanced output routine 1027>
		{
			print_err(TEX_STRING("Unbalanced output routine"));
			help2(TEX_STRING("Your sneaky output routine has problematic {'s and/or }'s."),
				TEX_STRING("I can't handle that very well; good luck."));
			error();
			do {
				get_token();
			} while (!(loc == null));
		}
			#pragma endregion
		end_token_list();
		end_graf(); unsave(); output_active = false; insert_penalties = 0;
		#pragma region <Ensure that box 255 is empty after output 1028>
		if (box(255) != null) {
			print_err(TEX_STRING("Output routine didn't use all of ")); 
			print_esc(TEX_STRING("box")); print_int(255);
			help3(TEX_STRING("Your \output commands should empty \box255,"),
				TEX_STRING("e.g., by saying `\shipout\box255'."),
				TEX_STRING("Proceed; I'll discard its present contents."));
			box_error(255);
		}
		#pragma endregion
		if (tail != head) {
			link(page_tail) = link(head); page_tail = tail;
		}
		if (link(page_head) != null) {
			if (link(contrib_head) == null) contrib_tail = page_tail;
			link(page_tail) = link(contrib_head); link(contrib_head) = link(page_head); link(page_head) = null;
			page_tail = page_head;
		}
		pop_nest();
		build_page();
		#pragma endregion
		break;

		//1118
	case disc_group:
		build_discretionary();
		break;

		//1132
	case align_group:
		back_input(); cur_tok = cs_token_flag + frozen_cr; print_err(TEX_STRING("Missing "));
		print_esc(TEX_STRING("cr")); 
		print(TEX_STRING(" inserted"));
		help1(TEX_STRING("I'm guessing that you meant to end an alignment here."));
		ins_error();
		break;

		// 1133
	case no_align_group:
		end_graf();
		unsave();
		align_peek();
		break;
		//1168
	case vcenter_group:
		end_graf();
		unsave();
		save_ptr -= 2;
		p = vpack(link(head), saved(1), saved(0)); pop_nest(); tail_append(new_noad()); type(tail) = vcenter_noad;
		math_type(nucleus(tail)) = sub_box; info(nucleus(tail)) = p;
		break;
		//1173
	case math_choice_group:
		build_choices();
		break;
		//1186
	case math_group:
		unsave(); decr(save_ptr);
		math_type(saved(0)) = sub_mlist; p = fin_mlist(null); info(saved(0)) = p;
		if(p!=null)
			if(link(p)==null)
				if (type(p) == ord_noad) {
					if(math_type(subscr(p))==empty)
						if (math_type(supscr(p)) == empty) {
							mem[saved(0)].hh = mem[nucleus(p)].hh; free_node(p, noad_size);
						}
				}
				else if(type(p) == accent_noad)
					if(saved(0) == nucleus(tail))
						if (type(tail) == ord_noad) 
							#pragma region <Replace the tail of the list by p 1187>
						{
							q = head;
							while (link(q) != tail) q = link(q);
							link(q) = p; free_node(tail, noad_size); tail = p;
						}
							#pragma endregion
						
		break;
	#pragma endregion
	default:
		confusion(TEX_STRING("rightbrace"));
		break;
	}
}

//131
//init
#ifndef NO_INIT
void sort_avail()
{
	pointer p, q, r;
	pointer old_rover;

	p = get_node(010000000000);
	p = rlink(rover); rlink(rover) = max_halfword; old_rover = rover;
	while (p != old_rover) 
		#pragma region <Sort p into the list starting at rover and advance p to rlink(p) 132>
	{
		if (p < rover) {
			q = p; p = rlink(q); rlink(q) = rover; rover = q;
		}
		else {
			q = rover;
			while (rlink(q) < p) q = rlink(q);
			
			r = rlink(p); rlink(p) = rlink(q); rlink(q) = p; p = r;
		}
	}
		#pragma endregion

	p = rover;
	while (rlink(p) != max_halfword) {
		llink(rlink(p)) = p; p = rlink(p);
	}
	rlink(p) = rover; llink(rover) = p;
}
#endif
//tini


// 264
//init
#ifndef NO_INIT
void primitive(str_number s, quarterword c, halfword o)
{
	pool_pointer k;
	small_number j;
	small_number l;
	if (s < 256) {
		cur_val = s + single_base;
	}
	else {
		k = str_start[s]; l = str_start[s + 1] - k;
		for (j = 0; j <= l - 1; j++)
			buffer[j] = so(str_pool[k + j]);
		cur_val = id_lookup(0, l);
		flush_string; text(cur_val) = s;
	}
	eq_level(cur_val) = level_one; eq_type(cur_val) = c; equiv(cur_val) = o;
}
#endif
//tini

// 534
void open_log_file()
{
	unsigned int old_setting;
	int k;
	int l;
	char months[37]; // 1..36
	old_setting = selector;
	if (job_name == 0) job_name = TEX_STRING("texput");
	pack_job_name(TEX_STRING(".log"));
	while (!a_open_out(&log_file)) 
		#pragma region <Try to get a different log file name 535>
	{
		
		selector = term_only; prompt_file_name(TEX_STRING("transcript file name"),
			TEX_STRING(".log"));

	}
		#pragma endregion

	log_name = a_make_name_string(log_file); selector = log_only; log_opened = true;


	#pragma region <Print the banner line, including the date and time 536>
	wlog_s(banner); slow_print(format_ident); print(TEX_STRING("  "));
	print_int(day); print_char(TEX_STRING(" "));
	strcpy(months, "JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC");
	months[36] = 0;
	for (k = 3 * month - 2; k <= 3 * month; k++) wlog_c(months[k-1]);
	print_char(TEX_STRING(" "));
	print_int(year); print_char(TEX_STRING(" "));
	print_two(_time / 60); print_char(TEX_STRING(":"));
	print_two(_time % 60);
	#pragma endregion

	input_stack[input_ptr] = cur_input;
	print_nl(TEX_STRING("**")); l = input_stack[0].limit_field;
	if (buffer[l] == end_line_char)
		decr(l);
	for (k = 1; k <= l; k++)
		print(buffer[k]);
	print_ln();
	selector = old_setting + 2;
	
}

// 525
str_number make_name_string()
{
	int k;
	if (pool_ptr + strlen(name_of_file.get_c_str()) > pool_size || str_ptr == max_strings || cur_length > 0)
		return TEX_STRING("?");
	else {
		for (k = 1; k <= (int)strlen(name_of_file.get_c_str()); k++) append_char(xord[name_of_file[k]]);
		return make_string();
	}
}

str_number a_make_name_string(alpha_file f)
{
	return make_name_string();
}
str_number b_make_name_string(byte_file f)
{
	return make_name_string();
}
str_number w_make_name_string(word_file f)
{
	return make_name_string();
}


// 679
void append_to_vlist(pointer b)
{
	scaled d;
	pointer p;
	if (prev_depth > ignore_depth) {
		d = width(baseline_skip) - prev_depth - height(b);
		if (d < line_skip_limit) p = new_param_glue(line_skip_code);
		else {
			p = new_skip_param(baseline_skip_code);
			width(temp_ptr) = d;
		}
		link(tail) = p; tail = p;
	}
	link(tail) = b; tail = b; prev_depth = depth(b);
}


// 699
void print_size(int s)
{
	if (s == text_size) print_esc(TEX_STRING("textfont"));
	else if (s == script_size) print_esc(TEX_STRING("scriptfont"));
	else print_esc(TEX_STRING("scriptscriptfont"));
}

void initialize()
{
	//int i;
	int k;
	hyph_pointer z;
	// 21,24
	setup_char_arrays();
	//74
	interaction = error_stop_mode;
	
	// 77
	deletions_allowed = true;
	set_box_allowed = true;
	error_count = 0;

	// 80
	help_ptr = 0;
	use_err_help = false;

	// 97
	interrupt = 0;
	OK_to_interrupt = true;

	// 166
	//debug
#ifndef NO_DEBUG	
	was_mem_end = mem_min;
	was_lo_max = mem_min;
	was_hi_min = mem_max;
	panicking = false;
#endif	
	//gubed

	// 215
	nest_ptr = 0; max_nest_stack = 0; mode = vmode; head = contrib_head; tail = contrib_head;
	prev_depth = ignore_depth; mode_line = 0; prev_graf = 0; shown_mode = 0;

	#pragma region Start a new current page 991>
	page_contents = empty; page_tail = page_head; link(page_head) = null;
	last_glue = max_halfword; last_penalty = 0; last_kern = 0; page_depth = 0; page_max_depth = 0;
	#pragma endregion


	// 254
	for (k = int_base; k <= eqtb_size; k++)
		xeq_level[k] = level_one;

	// 257
	no_new_control_sequence = true;
	next(hash_base) = 0; text(hash_base) = 0;
	for (k = hash_base + 1; k <= undefined_control_sequence - 1; k++)
		hash[k] = hash[hash_base];

	// 272
	save_ptr = 0; cur_level = level_one; cur_group = bottom_level; cur_boundary = 0;
	max_save_stack = 0;

	// 287
	mag_set = 0;


	// 383
	top_mark = null; first_mark = null; bot_mark = null; split_first_mark = null;
	split_bot_mark = null;

	// 439
	cur_val = 0; cur_val_level = int_val; radix = 0; cur_order = normal;

	// 481
	for (k = 0; k <= 16; k++)
		read_open[k] = closed;

	// 490
	cond_ptr = null;
	if_limit = normal; cur_if = 0; if_line = 0;

	// 521
	strcpy(TEX_format_default.get_c_str(),"plain.fmt");

	// 551
	for (k = font_base; k <= font_max; k++)
		font_used[k] = false;

	// 556
	null_character.b0 = min_quarterword; null_character.b1 = min_quarterword;
	null_character.b2 = min_quarterword; null_character.b3 = min_quarterword;


	// 593
	total_pages = 0; max_v = 0; max_h = 0; max_push = 0; last_bop = -1; doing_leaders = false;
	dead_cycles = 0; cur_s = -1;

	// 596
	half_buf = dvi_buf_size / 2; dvi_limit = dvi_buf_size; dvi_ptr = 0; dvi_offset = 0;
	dvi_gone = 0;


	// 606
	down_ptr = null; right_ptr = null;

	// 648
	adjust_tail = null; last_badness = 0;

	// 662
	pack_begin_line = 0;

	// 685
	empty_field.rh = empty; empty_field.lh = null;
	null_delimiter.b0 = 0; null_delimiter.b1 = min_quarterword;
	null_delimiter.b2 = 0; null_delimiter.b3 = min_quarterword;

	// 771
	align_ptr = null; cur_align = null; cur_span = null; cur_loop = null;
	cur_head = null; cur_tail = null;

	// 928
	for (z = 0; z <= hyph_size; z++) {
		hyph_word[z] = 0; hyph_list[z] = null;
	}
	hyph_count = 0;

	// 990
	output_active = false;
	insert_penalties = 0;

	// 1033
	ligature_present = false;
	cancel_boundary = false;
	lft_hit = false;
	rt_hit = false;
	ins_disc = false;


	// 1267
	after_token = 0;

	// 1282
	long_help_seen = false;

	// 1300
	format_ident = 0;

	// 1343
	for (k = 0; k <= 17; k++)
		write_open[k] = false;


	#pragma region <initialize table entry done by INITEX only 164>
	// init
#ifndef NO_INIT
	// 164
	for (k = mem_bot + 1; k <= lo_mem_stat_max; k++) {
		mem[k].sc = 0;
	}
	k = mem_bot;
	while (k <= lo_mem_stat_max) {
		glue_ref_count(k) = null + 1;
		stretch_order(k) = normal;
		shrink_order(k) = normal;
		k = k + glue_spec_size;
	}
	stretch(fil_glue) = unity; stretch_order(fil_glue) = fil;
	stretch(fill_glue) = unity; stretch_order(fill_glue) = fill;
	stretch(ss_glue) = unity; stretch_order(ss_glue) = fil;
	shrink(ss_glue) = unity; shrink_order(ss_glue) = fil;
	stretch(fil_neg_glue) = -unity; stretch_order(fil_neg_glue) = fil;
	rover = lo_mem_stat_max + 1; link(rover) = empty_flag;
	node_size(rover) = 1000;
	llink(rover) = rover; rlink(rover) = rover;
	lo_mem_max = rover + 1000; link(lo_mem_max) = null; info(lo_mem_max) = null;
	for (k = hi_mem_stat_min; k <= mem_top; k++) mem[k] = mem[lo_mem_max];

	#pragma region	<Initialize the special list heads and constant nodes 790>
	info(omit_template) = end_template_token;
	//797
	link(end_span) = max_quarterword + 1; info(end_span) = null;

	//820
	type(last_active) = hyphenated; line_number(last_active) = max_halfword;
	subtype(last_active) = 0;

	//981
	subtype(page_ins_head) = qi(255); type(page_ins_head) = split_up;
	link(page_ins_head) = page_ins_head;

	//988
	type(page_head) = glue_node; subtype(page_head) = normal;
	#pragma endregion

	avail = null; mem_end = mem_top; hi_mem_min = hi_mem_stat_min;
	var_used = lo_mem_stat_max + 1 - mem_bot; dyn_used = hi_mem_stat_usage;

	//222
	eq_type(undefined_control_sequence) = undefined_cs;
	equiv(undefined_control_sequence) = null;
	eq_level(undefined_control_sequence) = level_zero;
	for (k = active_base; k <= undefined_control_sequence - 1; k++) eqtb[k] = eqtb[undefined_control_sequence];

	// 228
	equiv(glue_base) = zero_glue; eq_level(glue_base) = level_one; eq_type(glue_base) = glue_ref;
	for (k = glue_base + 1; k <= local_base - 1; k++) eqtb[k] = eqtb[glue_base];
	glue_ref_count(zero_glue) = glue_ref_count(zero_glue) + local_base - glue_base;

	par_shape_ptr = null; eq_type(par_shape_loc) = shape_ref; eq_level(par_shape_loc) = level_one;
	for (k = output_routine_loc; k <= toks_base + 255; k++) eqtb[k] = eqtb[undefined_control_sequence];
	box(0) = null; eq_type(box_base) = box_ref; eq_level(box_base) = level_one;
	for (k = box_base + 1; k <= box_base + 255; k++) eqtb[k] = eqtb[box_base];
	cur_font = null_font; eq_type(cur_font_loc) = data; eq_level(cur_font_loc) = level_one;
	for (k = math_font_base; k <= math_font_base + 47; k++) eqtb[k] = eqtb[cur_font_loc];
	equiv(cat_code_base) = 0; eq_type(cat_code_base) = data; eq_level(cat_code_base) = level_one;
	for (k = cat_code_base + 1; k <= int_base - 1; k++) eqtb[k] = eqtb[cat_code_base];
	for (k = 0; k <= 255; k++) {
		cat_code(k) = other_char; math_code(k) = hi(k); sf_code(k) = 1000;
	}
	cat_code(carriage_return) = car_ret; cat_code(TEX_STRING(" ")) = spacer;
	cat_code(TEX_STRING("\")) = escape;
	cat_code(TEX_STRING("%")) = comment; cat_code(invalid_code) = invalid_char;
	cat_code(null_code) = ignore;
	for (k = TEX_STRING("0");
		k <= TEX_STRING("9"); k++) math_code(k) = hi(k + var_code);
	for (k = TEX_STRING("A");
		k <= TEX_STRING("Z"); k++) {
		cat_code(k) = letter; 
		cat_code(k + TEX_STRING("a") -
			                            TEX_STRING("A")) = letter;
		math_code(k) = hi(k + var_code + 0x100);
		math_code(k + TEX_STRING("a") -
			TEX_STRING("A")) = 
			hi(k + TEX_STRING("a") -
				TEX_STRING("A") + var_code + 0x100);
		lc_code(k) = k + TEX_STRING("a") - 
			TEX_STRING("A");
		lc_code(k + TEX_STRING("a") - 
			TEX_STRING("A")) = k + 
			TEX_STRING("a") - 
			TEX_STRING("A");
		uc_code(k) = k; uc_code(k + TEX_STRING("a") - 
			TEX_STRING("A")) = k;
		sf_code(k) = 999;
	}

	// 240
	for (k = int_base; k <= del_code_base - 1; k++) eqtb[k].an_int = 0;
	mag = 1000; tolerance = 10000; hang_after = 1; max_dead_cycles = 25;
	escape_char = TEX_STRING("\");
	end_line_char = carriage_return;
	for (k = 0; k <= 255; k++) del_code(k) = -1;
	del_code(TEX_STRING(".")) = 0;

	//250
	for (k = dimen_base; k <= eqtb_size; k++) eqtb[k].sc = 0;

	//258
	hash_used = frozen_control_sequence;
	cs_count = 0;
	eq_type(frozen_dont_expand) = dont_expand;
	text(frozen_dont_expand) = TEX_STRING("notexpanded:");

	// 552
	font_ptr = null_font; fmem_ptr = 7; font_name[null_font] = TEX_STRING("nullfont");
	font_area[null_font] = TEX_STRING("");
	hyphen_char[null_font] = TEX_STRING("-"); skew_char[null_font] = -1;
	bchar_label[null_font] = non_address;
	font_bchar[null_font] = non_char; font_false_bchar[null_font] = non_char;
	font_bc[null_font] = 1;
	font_ec[null_font] = 0; font_size[null_font] = 0; font_dsize[null_font] = 0;
	char_base[null_font] = 0;
	width_base[null_font] = 0; height_base[null_font] = 0; depth_base[null_font] = 0;
	italic_base[null_font] = 0; lig_kern_base[null_font] = 0; kern_base[null_font] = 0;
	exten_base[null_font] = 0; font_glue[null_font] = null; font_params[null_font] = 7;
	param_base[null_font] = -1;
	for (k = 0; k <= 6; k++) font_info[k].sc = 0;

	//946
	for (k = -trie_op_size; k <= trie_op_size; k++) trie_op_hash[k] = 0;
	for (k = 0; k <= 255; k++) trie_used[k] = min_quarterword;
	trie_op_ptr = 0;

	// 951
	trie_not_ready = true; trie_root = 0; trie_c[0] = si(0); trie_ptr = 0;

	//1216
	text(frozen_protection) = TEX_STRING("inaccessible");

	//1301
	format_ident = TEX_STRING(" (INITEX)");

	//1369
	text(end_write) = TEX_STRING("endwrite"); eq_level(end_write) = level_one; eq_type(end_write) = outer_call;
	equiv(end_write) = null;

#endif
//tini
	#pragma endregion

}


// 694
void print_style(int c)
{
	switch (c / 2) {
	case 0: print_esc(TEX_STRING("displaystyle")); break;
	case 1: print_esc(TEX_STRING("textstyle")); break;
	case 2: print_esc(TEX_STRING("scriptstyle")); break;
	case 3: print_esc(TEX_STRING("scriptscriptstyle")); break;
	default: print(TEX_STRING("Unknown style!")); break;
	}
}

// 82
void error()
{
	ASCII_code c;
	int s1, s2, s3, s4;

	if (history < error_message_issued)
		history = error_message_issued;
	print_char(TEX_STRING("."));
	show_context();
	if (interaction == error_stop_mode) 
		#pragma region <get users advise and return 83>
		while (1) {
mycontinue:
			clear_for_error_prompt();
			prompt_input(TEX_STRING("? "));
			if (last == first)
				return;
			c = buffer[first];
			if (c >= TEX_STRING("a")) c = c + TEX_STRING("A") -	TEX_STRING("a");
			#pragma region <Interpret code c and return if done 84>
			switch (c) {
				case TEX_STRING("0"):
				case TEX_STRING("1"):
				case TEX_STRING("2"):
				case TEX_STRING("3"):
				case TEX_STRING("4"):
				case TEX_STRING("5"):
				case TEX_STRING("6"):
				case TEX_STRING("7"):
				case TEX_STRING("8"):
				case TEX_STRING("9"):
					if (deletions_allowed)
						#pragma region <Delete c - character 0 tokens and goto continue 88>
					{
						
						s1 = cur_tok; s2 = cur_cmd; s3 = cur_chr; s4 = align_state; align_state = 1000000;
						OK_to_interrupt = false;
						if (last > first + 1 && buffer[first + 1] >= TEX_STRING("0") && buffer[first + 1] <=
							TEX_STRING("9"))
							c = c * 10 + buffer[first + 1] - TEX_STRING("0") * 11;
						else
							c = c - TEX_STRING("0");
						while (c > 0) {
							get_token();
							decr(c);
						}
						cur_tok = s1; cur_cmd = s2; cur_chr = s3; align_state = s4; OK_to_interrupt = true;
						help2(TEX_STRING("I have just deleted some text, as you asked."),
							TEX_STRING("You can now delete more, or insert, or whatever."));
						show_context();
						goto mycontinue;
					}
						#pragma endregion
					break;

					//debug
#ifndef NO_DEBUG					
				case TEX_STRING("D"):
					debug_help();
					goto mycontinue;
					break;
#endif					
					//gubed

				case TEX_STRING("E"):
					if (base_ptr > 0) {
						ed_name_start = str_start[edit_file.name_field];
						ed_name_length = str_start[edit_file.name_field+1] - str_start[edit_file.name_field];
						edit_line = line;
						jump_out();
					}
					break;
					
				case TEX_STRING("H"):
					#pragma region <Print help information and continue 89>
					if (use_err_help) {
						give_err_help();
						use_err_help = false;
					}
					else {
						if (help_ptr == 0)
							help2(TEX_STRING("Sorry, I don't know how to help in this situation."),
								TEX_STRING("Maybe you should try asking a human?"));
						do {
							decr(help_ptr);
							print(help_line[help_ptr]); print_ln();
						} while (help_ptr != 0);
					}
					help4(TEX_STRING("Sorry, I already gave what help I could..."),
						TEX_STRING("Maybe you should try asking a human?"),
						TEX_STRING("An error might have occurred before I noticed any problems."),
						TEX_STRING("``If all else fails, read the instructions.''"));
					goto mycontinue;
					#pragma endregion
					break;
				case TEX_STRING("I"):
					#pragma region <Introduce new material from the terminal and return 87>
					begin_file_reading();
					if (last > first + 1) {
						loc = first + 1;
						buffer[first] = TEX_STRING(" ");
					}
					else {
						prompt_input(TEX_STRING("insert>")); loc = first;
					}
					first = last; cur_input.limit_field = last - 1;
					return;
					#pragma endregion
					break;
				case TEX_STRING("Q"):
				case TEX_STRING("R"):
				case TEX_STRING("S"):
					#pragma region <Change the interaction level and return 86>
					error_count = 0;
					interaction = batch_mode + c - TEX_STRING("Q");
					print(TEX_STRING("OK, entering "));
					switch (c) {
						case TEX_STRING("Q"):
							print_esc(TEX_STRING("batchmode"));
							decr(selector);
							break;
						case TEX_STRING("R"):
							print_esc(TEX_STRING("nonstopmode"));
							break;
						case TEX_STRING("S"):
							print_esc(TEX_STRING("scrollmode"));
							break;
					}
					print(TEX_STRING("...")); print_ln();
					update_terminal();
					return;
					#pragma endregion
					break;
				case TEX_STRING("X"):
					interaction = scroll_mode;
					jump_out();
					break;
				default:
					break;
			}

			#pragma region <Print the menu of available options 85>
			{
				print(TEX_STRING("Type <return> to proceed, S to scroll future error messages,"));
				print_nl(TEX_STRING("R to run without stopping, Q to run quietly,"));
				print_nl(TEX_STRING("I to insert something, "));
				if (base_ptr > 0)
					print(TEX_STRING("E to edit your file,"));
				if (deletions_allowed)
					print_nl(TEX_STRING("1 or ... or 9 to ignore the next 1 to 9 tokens of input,"));
				print_nl(TEX_STRING("H for help, X to quit."));
			}
			#pragma endregion

			#pragma endregion
		}
		#pragma endregion

	incr(error_count);
	if (error_count == 100) {
		print_nl(TEX_STRING("(That makes 100 errors; please try again.)"));
		history = fatal_error_stop;
		jump_out();
	}
	#pragma region <Put help message on the transcript file 90>
	if (interaction > batch_mode) decr(selector);
	if (use_err_help) {
		print_ln(); give_err_help();
	}
	else
		while (help_ptr > 0) {
			decr(help_ptr); print_nl(help_line[help_ptr]);
		}
	print_ln();
	if (interaction > batch_mode) incr(selector);
	print_ln();
	#pragma endregion


}


// 91
void int_error(int n)
{
	print(TEX_STRING(" ("));
	print_int(n);
	print_char(TEX_STRING(")"));
	error();
}

// 204
pointer copy_node_list(pointer p)
{
	pointer h;
	pointer q;
	pointer r;
	unsigned char words; // 0..5

	h = get_avail(); q = h;
	while (p != null) {
		#pragma region <Make a copy of node p in node r 205>
		words = 1;
		if (is_char_node(p)) r = get_avail();
		else 
			#pragma region <Case statement to copy different types and set words to the number of initial words not yet copied 206>
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case unset_node:
				r = get_node(box_node_size); mem[r + 6] = mem[p + 6];
				mem[r + 5] = mem[p + 5];
				list_ptr(r) = copy_node_list(list_ptr(p));
				words = 5;
				break;
			case rule_node:
				r = get_node(rule_node_size); words = rule_node_size;
				break;
			case ins_node:
				r = get_node(ins_node_size); mem[r + 4] = mem[p + 4]; add_glue_ref(split_top_ptr(p));
				ins_ptr(r) = copy_node_list(ins_ptr(p));
				words = ins_node_size - 1;
				break;
			case whatsit_node:
				#pragma region <Make a partial copy of whatsit node p and make r point to it; set words.. 1357>
				switch (subtype(p)) {
				case open_node:
					r = get_node(open_node_size); words = open_node_size;
					break;
				case write_node:
				case special_node:
					r = get_node(write_node_size);
					add_token_ref(write_tokens(p));
					words = write_node_size;
					break;
				case close_node:
				case language_node:
					r = get_node(small_node_size); words = small_node_size;
					break;
				default:
					confusion(TEX_STRING("ext2"));
					break;
				}
				#pragma endregion
				break;
			case glue_node:
				r = get_node(small_node_size); add_glue_ref(glue_ptr(p)); glue_ptr(r) = glue_ptr(p);
				leader_ptr(r) = copy_node_list(leader_ptr(p));
				break;
			case kern_node:
			case math_node:
			case penalty_node:
				r = get_node(small_node_size); words = small_node_size;
				break;
			case ligature_node:
				r = get_node(small_node_size); mem[lig_char(r)] = mem[lig_char(p)];
				lig_ptr(r) = copy_node_list(lig_ptr(p));
				break;
			case disc_node:
				r = get_node(small_node_size); pre_break(r) = copy_node_list(pre_break(p));
				post_break(r) = copy_node_list(post_break(p));
				break;
			case mark_node:
				r = get_node(small_node_size); add_token_ref(mark_ptr(p));
				words = small_node_size;
				break;
			case adjust_node:
				r = get_node(small_node_size); adjust_ptr(r) = copy_node_list(adjust_ptr(p));
				break;
			default:
				confusion(TEX_STRING("copying"));
				break;
			}
			#pragma endregion

		while (words > 0) {
			decr(words); mem[r + words] = mem[p + words];
		}
		#pragma endregion
		link(q) = r; q = r; p = link(p);
	}
	link(q) = null; q = link(h); free_avail(h); 
	return q;
}

// 225
void print_skip_param(int n)
{
	switch (n) {
	case line_skip_code:
		print_esc(TEX_STRING("lineskip"));
		break;
	case baseline_skip_code:
		print_esc(TEX_STRING("baselineskip"));
		break;
	case par_skip_code:
		print_esc(TEX_STRING("parskip"));
		break;
	case above_display_skip_code:
		print_esc(TEX_STRING("abovedisplayskip"));
		break;
	case below_display_skip_code:
		print_esc(TEX_STRING("belowdisplayskip"));
		break;
	case above_display_short_skip_code:
		print_esc(TEX_STRING("abovedisplayshortskip"));
		break;
	case below_display_short_skip_code:
		print_esc(TEX_STRING("belowdisplayshortskip"));
		break;
	case left_skip_code:
		print_esc(TEX_STRING("leftskip"));
		break;
	case right_skip_code:
		print_esc(TEX_STRING("rightskip"));
		break;
	case top_skip_code:
		print_esc(TEX_STRING("topskip"));
		break;
	case split_top_skip_code:
		print_esc(TEX_STRING("splittopskip"));
		break;
	case tab_skip_code:
		print_esc(TEX_STRING("tabskip"));
		break;
	case space_skip_code:
		print_esc(TEX_STRING("spaceskip"));
		break;
	case xspace_skip_code:
		print_esc(TEX_STRING("xspaceskip"));
		break;
	case par_fill_skip_code:
		print_esc(TEX_STRING("parfillskip"));
		break;
	case thin_mu_skip_code:
		print_esc(TEX_STRING("thinmuskip"));
		break;
	case med_mu_skip_code:
		print_esc(TEX_STRING("medmuskip"));
		break;
	case thick_mu_skip_code:
		print_esc(TEX_STRING("thickmuskip"));
		break;
	default:
		print(TEX_STRING("[unknown glue parameter!]"));
		break;
	}
}

// 245
void begin_diagnostic()
{
	old_setting = selector;
	if (tracing_online <= 0 && selector == term_and_log) {
		decr(selector);
		if (history == spotless)
			history = warning_issued;
	}
}
void end_diagnostic(bool blank_line)
{
	print_nl(TEX_STRING(""));
	if (blank_line)
		print_ln();
	selector = old_setting;
}


// 262
void print_cs(int p)
{
	if (p < hash_base)
		if (p >= single_base)
			if (p == null_cs) {
				print_esc(TEX_STRING("csname"));
				print_esc(TEX_STRING("endcsname"));
				print_char(TEX_STRING(" "));
			}
			else {
				print_esc(p - single_base);
				if (cat_code(p - single_base) == letter)
					print_char(TEX_STRING(" "));
			}

		else if (p < active_base) print_esc(TEX_STRING("IMPOSSIBLE."));
		else print(p - active_base);

	else if (p >= undefined_control_sequence)
		print_esc(TEX_STRING("IMPOSSIBLE."));
	else if (text(p) < 0 || text(p) >= str_ptr) print_esc(TEX_STRING("NONEXISTENT."));
	else {
		print_esc(text(p));
		print_char(TEX_STRING(" "));
	}
}

// 288
void prepare_mag()
{
	if (mag_set > 0 && mag != mag_set) {
		print_err(TEX_STRING("Incompatible magnification ("));
		print_int(mag);
		print(TEX_STRING(");"));
		print_nl(TEX_STRING(" the previous value will be retained"));
		help2(TEX_STRING("I can handle only one magnification ratio per job. So I've"),
			TEX_STRING("reverted to the magnification you used earlier on this run."));
		int_error(mag_set); geq_word_define(int_base + mag_code, mag_set);
	}
	if (mag <= 0 || mag > 32768) {
		print_err(TEX_STRING("Illegal magnification has been changed to 1000"));
		help1(TEX_STRING("The magnification ratio must be between 1 and 32768."));
		int_error(mag);
		geq_word_define(int_base + mag_code, 1000);
	}
	mag_set = mag;
}

// 379
void insert_relax()
{
	cur_tok = cs_token_flag + cur_cs;
	back_input();
	cur_tok = cs_token_flag + frozen_relax;
	back_input();
	token_type = inserted;
}




// 464
pointer str_toks(pool_pointer b)
{
	pointer p;
	pointer q;
	halfword t;
	pool_pointer k;

	str_room(1); p = temp_head; link(p) = null; k = b;
	while (k < pool_ptr) {
		t = so(str_pool[k]);
		if (t == TEX_STRING(" "))
			t = space_token;
		else t = other_token + t;
		store_new_token(t); incr(k);
	}
	pool_ptr = b; 
	return p;
}

// 405
void scan_optional_equals()
{
	#pragma region <Get the next non blank non call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_tok != other_token + TEX_STRING("="))
		back_input();
}

// 448
void scan_dimen(bool mu, bool inf, bool shortcut)
{
	bool negative;
	int f;

	#pragma region <Local variables for dimension calculations 450>
	unsigned int num, denom;
	small_number k, kk;
	pointer p, q;
	scaled v;
	int save_cur_val;
	#pragma endregion

	f = 0; arith_error = false; cur_order = normal; negative = false;

	if (!shortcut) {
		#pragma region <Get the next non-blank non-sign token; set negative appropriately 441>
		negative = false;
		do {
			#pragma region <Get the next non-blank non-call token 406>
			do {
				get_x_token();
			} while (!(cur_cmd != spacer));
			#pragma endregion
			if (cur_tok == other_token + TEX_STRING("-")) {
				negative = !negative; cur_tok = other_token + TEX_STRING("+");
			}
		} while (!(cur_tok != other_token + TEX_STRING("+")));
		#pragma endregion
		if (cur_cmd >= min_internal && cur_cmd <= max_internal) 
			#pragma region <Fetch an internal dimension and goto attach_sign, or fetch an internal integer 449>
		{
			if (mu) {
				scan_something_internal(mu_val, false);
				#pragma region <Coerce glue to dimension 451>
				if (cur_val_level >= glue_val) {
					v = width(cur_val); delete_glue_ref(cur_val); cur_val = v;
				}
				#pragma endregion
				if (cur_val_level == mu_val) goto attach_sign;
				if (cur_val_level != int_val) mu_error();
			}
			else {
				scan_something_internal(dimen_val, false);
				if (cur_val_level == dimen_val) goto attach_sign;
			}
		}
			#pragma endregion
		else {
			back_input();
			if (cur_tok == continental_point_token)
				cur_tok = point_token;
			if (cur_tok != point_token)
				scan_int();
			else {
				radix = 10;
				cur_val = 0;
			}
			if (cur_tok == continental_point_token)
				cur_tok = point_token;
			if (radix == 10 && cur_tok == point_token) 
				#pragma region <Scan decimal fraction 452>
			{
				k = 0; p = null; get_token();
				while (1) {
					get_x_token();
					if (cur_tok > zero_token + 9 || cur_tok < zero_token) goto done1;
					if (k < 17) {
						q = get_avail(); link(q) = p; info(q) = cur_tok - zero_token; p = q; incr(k);
					}
				}
			done1:
				for (kk = k; kk >= 1; kk--) {
					
					// overflow check
					if (info(p) > 255) {
						printf("overflow in 452\n");
						exit(1);
					}
					//////////////////
					
					dig[kk - 1] = (unsigned char)info(p); q = p; p = link(p); free_avail(q);
				}
				f = round_decimals(k);
				if (cur_cmd != spacer) back_input();
			}
				#pragma endregion
			
		}
	}
	if (cur_val < 0) {
		negative = !negative; negate(cur_val);
	}

	#pragma region <Scan units and set cur_val to x*(cur_val+f/2^16) wehre there are x sp per unit; goto attach_sign if... 453>
	if (inf)
		#pragma region <Scan for fil units; goto attach_fraction if found 454>
		if (scan_keyword(TEX_STRING("fil"))) {
			cur_order = fil;
			while (scan_keyword(TEX_STRING("l"))) {
				if (cur_order == filll) {
					print_err(TEX_STRING("Illegal unit of measure ("));
					print(TEX_STRING("replaced by filll)"));
					help1(TEX_STRING("I dddon't go any higher than filll.")); error();
				}
				else incr(cur_order);
			}
			goto attach_fraction;
		}
		#pragma endregion

	#pragma region <Scan for units that are internal dimensions; goto attach_sign with cur_val set if found 455>
	save_cur_val = cur_val;
	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	if (cur_cmd < min_internal || cur_cmd > max_internal) back_input();
	else {
		if (mu) {
			scan_something_internal(mu_val, false);
			#pragma region <Coerce glue to a dimension 451>
			if (cur_val_level >= glue_val) {
				v = width(cur_val); delete_glue_ref(cur_val); cur_val = v;
			}
			#pragma endregion
			if (cur_val_level != mu_val) mu_error();
		}
		else scan_something_internal(dimen_val, false);
		v = cur_val; goto found;
	}
	if (mu) goto not_found;
	if (scan_keyword(TEX_STRING("em")))
		v = quad(cur_font);
	else if (scan_keyword(TEX_STRING("ex")))
		v = x_height(cur_font);
	else goto not_found;

	#pragma region <Scan an optional space 443>
	get_x_token();
	if (cur_cmd != spacer)
		back_input();
	#pragma endregion
found:
		 cur_val = nx_plus_y(save_cur_val, v, xn_over_d(v, f, 0200000)); goto attach_sign;
not_found:

	#pragma endregion

	if (mu)
		#pragma region <Scan for mu units and goto attach_fraction 456>
	if (scan_keyword(TEX_STRING("mu"))) goto attach_fraction;
	else {
		print_err(TEX_STRING("Illegal unit of measure ("));
		print(TEX_STRING("mu inserted)"));
		help4(TEX_STRING("The unit of measurement in math glue must be mu."),
			TEX_STRING("To recover gracefully from this error, it's best to"),
			TEX_STRING("delete the erroneous units; e.g., type `2' to delete"),
			TEX_STRING("two letters. (See Chapter 27 of The TeXbook.)"));
		error(); goto attach_fraction;
	}
		#pragma endregion

	if (scan_keyword(TEX_STRING("true")))
		#pragma region <Adjust for magnification ratio 457>
	{
		prepare_mag();
		if (mag != 1000) {
			cur_val = xn_over_d(cur_val, 1000, mag); f = (1000 * f + 0200000 * _remainder) / mag;
			cur_val = cur_val + (f / 0200000); f = f % 0200000;
		}
	}
		#pragma endregion

	if (scan_keyword(TEX_STRING("pt"))) goto attach_fraction;

	#pragma region <Scan for all other units and adjust cur_val... 458>
	if (scan_keyword(TEX_STRING("in"))) set_conversion(7227, 100);
	else if (scan_keyword(TEX_STRING("pc"))) set_conversion(12, 1);
	else if (scan_keyword(TEX_STRING("cm"))) set_conversion(7227, 254);
	else if (scan_keyword(TEX_STRING("mm"))) set_conversion(7227, 2540);
	else if (scan_keyword(TEX_STRING("bp"))) set_conversion(7227, 7200);
	else if (scan_keyword(TEX_STRING("dd"))) set_conversion(1238, 1157);
	else if (scan_keyword(TEX_STRING("cc"))) set_conversion(14856, 1157);
	else if (scan_keyword(TEX_STRING("sp"))) goto done;
	else
		#pragma region <Complain about unknown unit and goto done2 459>
	{
		print_err(TEX_STRING("Illegal unit of measure ("));
		print(TEX_STRING("pt inserted)"));
		help6(TEX_STRING("Dimensions can be in units of em, ex, in, pt, pc,"),
			TEX_STRING("cm, mm, dd, cc, bp, or sp; but yours is a new one!"), 
			TEX_STRING("I'll assume that you meant to say pt, for printer's points."), 
			TEX_STRING("To recover gracefully from this error, it's best to"), 
			TEX_STRING("delete the erroneous units; e.g., type `2' to delete"), 
			TEX_STRING("two letters. (See Chapter 27 of The TeXbook.)"));		
		error();
		goto done2;
	}
		#pragma endregion

	cur_val = xn_over_d(cur_val, num, denom); f = (num*f + 0200000 * _remainder) / denom;
	cur_val = cur_val + (f / 0200000); f = f % 0200000;
done2:

	#pragma endregion

attach_fraction:
	if (cur_val >= 040000) arith_error = true;
	else cur_val = cur_val * unity + f;
done:


#pragma endregion

	#pragma region <Scan an optional space 443>
		 get_x_token();
		 if (cur_cmd != spacer)
			 back_input();
	#pragma endregion


attach_sign:
	if (arith_error || myabs(cur_val) >= 010000000000)
		#pragma region <Report that this dimension is out of range 460>
	{
		print_err(TEX_STRING("Dimension too large"));
		help2(TEX_STRING("I can't work with sizes bigger than about 19 feet."),
			TEX_STRING("Continue and I'll use the largest value I can."));
		error();
		cur_val = max_dimen; arith_error = false;
	}
		#pragma endregion
	if (negative)
		negate(cur_val);
}

// 461
void scan_glue(small_number level)
{
	bool negative;
	pointer q;
	bool mu;

	mu = (level == mu_val);
	#pragma region <Get the next non-blank non-sign token; set negative appropriately 441>
	negative = false;
	do {
		#pragma region <Get the next non-blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion
		if (cur_tok == other_token + TEX_STRING("-")) {
			negative = !negative; cur_tok = other_token + TEX_STRING("+");
		}
	} while (!(cur_tok != other_token + TEX_STRING("+")));
	#pragma endregion
	if (cur_cmd >= min_internal && cur_cmd <= max_internal) {
		scan_something_internal(level, negative);
		if (cur_val_level >= glue_val) {
			if (cur_val_level != level) mu_error();
			return;
		}
		if (cur_val_level == int_val) scan_dimen(mu, false, true);
		else if (level == mu_val) mu_error();
	}
	else {
		back_input(); scan_dimen(mu, false, false);
		if (negative) negate(cur_val);
	}
	#pragma region <Create a new glue specification whose width is cur_val; scan for its stretch and shrink components 462>
	q = new_spec(zero_glue); width(q) = cur_val;
	if (scan_keyword(TEX_STRING("plus"))) {
		scan_dimen(mu, true, false); stretch(q) = cur_val; stretch_order(q) = cur_order;
	}
	if (scan_keyword(TEX_STRING("minus"))) {
		scan_dimen(mu, true, false); shrink(q) = cur_val; shrink_order(q) = cur_order;
	}
	cur_val = q;
	#pragma endregion

}

//1229
void trap_zero_glue()
{
	if (width(cur_val) == 0 && stretch(cur_val) == 0 && shrink(cur_val) == 0) {
		add_glue_ref(zero_glue); delete_glue_ref(cur_val); cur_val = zero_glue;
	}
}

// 465
pointer the_toks()
{
	unsigned int old_setting;
	pointer p, q, r;
	pool_pointer b;

	get_x_token();
	scan_something_internal(tok_val, false);
	if (cur_val_level >= ident_val) 
		#pragma region <Copy the token list 466>
	{
		p = temp_head; link(p) = null;
		if (cur_val_level == ident_val)
			store_new_token(cs_token_flag + cur_val);
		else if (cur_val != null) {
			r = link(cur_val);
			while (r != null) {
				store_new_token(info(r)); r = link(r);
			}
		}
		return p;
	}
		#pragma endregion
	else {
		old_setting = selector; selector = new_string; b = pool_ptr;
		switch (cur_val_level) {
		case int_val:
			print_int(cur_val);
			break;
		case dimen_val:
			print_scaled(cur_val); print(TEX_STRING("pt"));
			break;
		case glue_val:
			print_spec(cur_val, TEX_STRING("pt")); delete_glue_ref(cur_val);
			break;
		case mu_val:
			print_spec(cur_val, TEX_STRING("mu")); delete_glue_ref(cur_val);
			break;
		}
		selector = old_setting;
		return str_toks(b);
	}
}
// 467
void ins_the_toks()
{
	link(garbage) = the_toks(); ins_list(link(temp_head));
}


// 470
void conv_toks()
{
	unsigned int old_setting;
	int c;
	small_number save_scanner_status;
	pool_pointer b;

	c = cur_chr;
	#pragma region <Scan the argument for command c 471>
	switch (c) {
	case number_code:
	case roman_numeral_code:
		scan_int();
		break;
	case string_code:
	case meaning_code:
		save_scanner_status = scanner_status; scanner_status = normal;
		get_token(); scanner_status = save_scanner_status;
		break;
	case font_name_code:
		scan_font_ident();
		break;
	case job_name_code:
		if (job_name == 0) open_log_file();
		break;
	}
	#pragma endregion

	old_setting = selector; selector = new_string; b = pool_ptr;
	#pragma region <Print the result of command c 472>
	switch (c) {
	case number_code: print_int(cur_val); break;
	case roman_numeral_code: print_roman_int(cur_val); break;
	case string_code:
		if (cur_cs != 0) sprint_cs(cur_cs);
		else print_char((ASCII_code)cur_chr);
		break;
	case meaning_code: print_meaning(); break;
	case font_name_code:
		print(font_name[cur_val]);
		if (font_size[cur_val] != font_dsize[cur_val]) {
			print(TEX_STRING(" at ")); print_scaled(font_size[cur_val]);
			print(TEX_STRING("pt"));
		}
		break;
	case job_name_code: print(job_name); break;
	}
	#pragma endregion

	selector = old_setting; link(garbage) = str_toks(b); ins_list(link(temp_head));
}

// 494
void pass_text()
{
	int l;
	small_number save_scanner_status;

	save_scanner_status = scanner_status; scanner_status = skipping; l = 0; skip_line = line;

	while (1) {
		get_next();
		if (cur_cmd == fi_or_else) {
			if (l == 0) goto done;
			if (cur_chr == fi_code) decr(l);
		}
		else if (cur_cmd == if_test) incr(l);
	}
done: scanner_status = save_scanner_status;
}


// 497
void change_if_limit(small_number l, pointer p)
{
	pointer q;
	if (p == cond_ptr)
		if_limit = l;
	else {
		q = cond_ptr;
		while (1) {
			if (q == null)
				confusion(TEX_STRING("if"));
			if (link(q) == p) {
				type(q) = l;
				return;
			}
			q = link(q);
		}
	}
}

// 498
void conditional()
{
	bool b;
	unsigned char r;
	int m, n;
	pointer p, q;
	small_number save_scanner_status;
	pointer save_cond_ptr;
	small_number this_if;

	#pragma region <Push the condition stack 495>
	p = get_node(if_node_size); link(p) = cond_ptr; type(p) = if_limit;
	subtype(p) = cur_if;
	if_line_field(p) = if_line; cond_ptr = p; cur_if = cur_chr; if_limit = if_code; if_line = line;
	#pragma endregion

	save_cond_ptr = cond_ptr; this_if = cur_chr;
	#pragma region <Either process ifcase or set b to the value of a boolean condition 501>
	switch (this_if) {
	case if_char_code:
	case if_cat_code:
		#pragma region <Test if two characters match 506>
		get_x_token_or_active_char;
		if (cur_cmd > active_char || cur_chr > 255) {
			m = relax; n = 256;
		}
		else {
			m = cur_cmd; n = cur_chr;
		}
		get_x_token_or_active_char;
		if (cur_cmd > active_char || cur_chr > 255) {
			cur_cmd = relax; cur_chr = 256;
		}
		if (this_if == if_char_code) b = (n == cur_chr); else b = (m == cur_cmd);
		#pragma endregion
		break;
	case if_int_code:
	case if_dim_code:
		#pragma region <Test relation between integers or dimensions 503>
		if (this_if == if_int_code) scan_int();
		else scan_normal_dimen;
		n = cur_val;
		#pragma region <Get the next non-blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion
		if (cur_tok >= other_token + TEX_STRING("<") &&
			cur_tok <= other_token + TEX_STRING(">"))
			r = cur_tok - other_token;
		else {
			print_err(TEX_STRING("Missing = inserted for "));
			print_cmd_chr(if_test, this_if);
			help1(TEX_STRING("I was expecting to see `<', `=', or `>'. Didn't."));
			back_error();
			r = TEX_STRING("=");
		}
		if (this_if == if_int_code) scan_int();
		else scan_normal_dimen;
		switch (r) {
		case TEX_STRING("<"): b = (n < cur_val); break;
		case TEX_STRING("="): b = (n == cur_val); break;
		case TEX_STRING(">"): b = (n > cur_val); break;
		}
		#pragma endregion
		break;
	case if_odd_code:
		#pragma region <Test if an integer is odd 504>
		scan_int();
		b = myodd(cur_val);
		#pragma endregion
		break;
	case if_vmode_code: b = (myabs(mode) == vmode);
		break;
	case if_hmode_code: b = (myabs(mode) == hmode);
		break;
	case if_mmode_code: b = (myabs(mode) == mmode);
		break;
	case if_inner_code: b = (mode < 0);
		break;
	case if_void_code:
	case if_hbox_code:
	case if_vbox_code:
		#pragma region <Test box register status 505>
		scan_eight_bit_int(); p = box(cur_val);
		if (this_if == if_void_code) b = (p == null);
		else if (p == null) b = false;
		else if (this_if == if_hbox_code) b = (type(p) == hlist_node);
		else b = (type(p) == vlist_node);
		#pragma endregion
		break;

	case ifx_code:
		#pragma region <Test if two tokens match 507>
		save_scanner_status = scanner_status; scanner_status = normal; get_next(); n = cur_cs;
		p = cur_cmd; q = cur_chr; get_next();
		if (cur_cmd != p) b = false;
		else if (cur_cmd < call) b = (cur_chr == q);
		else
			#pragma region <Test if two macro texts match 508>
		{
			p = link(cur_chr); q = link(equiv(n));
			if (p == q) b = true;
			else {
				while (p != null && q != null)
					if (info(p) != info(q)) p = null;
					else {
						p = link(p); q = link(q);
					}
				b = ((p == null) && (q == null));
			}
		}
			#pragma endregion
		scanner_status = save_scanner_status;
		#pragma endregion
		break;
	case if_eof_code:
		scan_four_bit_int(); b = (read_open[cur_val] == closed);
		break;

	case if_true_code: b = true;
		break;
	case if_false_code: b = false;
		break;
	case if_case_code:
		#pragma region <Select the appropriate case and return or goto common_ending 509>
		scan_int(); n = cur_val;
		if (tracing_commands > 1) {
			begin_diagnostic();
			print(TEX_STRING("{case ")); print_int(n);
			print_char(TEX_STRING("}"));
			end_diagnostic(false);
		}
		while (n != 0) {
			pass_text();
			if (cond_ptr == save_cond_ptr)
				if (cur_chr == or_code) decr(n);
				else goto common_ending;
			else if (cur_chr == fi_code)
				#pragma region <Pop the condition stack 496>
			{
				p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
				cond_ptr = link(p); free_node(p, if_node_size);
			}
				#pragma endregion

		}
		change_if_limit(or_code, save_cond_ptr); return;
		#pragma endregion
		break;
	}

	#pragma endregion
	if (tracing_commands > 1) 
		#pragma region <Display the value of b 502>
	{
		begin_diagnostic();
		if (b) print(TEX_STRING("{true}"));
		else print(TEX_STRING("{false}"));
		end_diagnostic(false);
	}
		#pragma endregion
	
	if (b) {
		change_if_limit(else_code, save_cond_ptr);
		return;
	}

	#pragma region <skip to else or fi then goto common_ending 500>
	while (1) {
		pass_text();
		if (cond_ptr == save_cond_ptr) {
			if (cur_chr != or_code) goto common_ending;
			print_err(TEX_STRING("Extra ")); 
			print_esc(TEX_STRING("or"));
			help1(TEX_STRING("I'm ignoring this; it doesn't match any \if."));
			error();
		}
		else if (cur_chr == fi_code)
			#pragma region <Pop the condition stack 496>
		{
			p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
			cond_ptr = link(p); free_node(p, if_node_size);
		}
			#pragma endregion
	}
	#pragma endregion
common_ending:
	if (cur_chr == fi_code)
		#pragma region <Pop the condition stack 496>
	{
		p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
		cond_ptr = link(p); free_node(p, if_node_size);
	}
		#pragma endregion
	else
		if_limit = fi_code;
}


// 366
void expand()
{
	halfword t;
	pointer p, q, r;
	int j;
	int cv_backup;
	small_number cvl_backup, radix_backup, co_backup;
	pointer backup_backup;
	small_number save_scanner_status;

	cv_backup = cur_val; cvl_backup = cur_val_level; radix_backup = radix;
	co_backup = cur_order;
	backup_backup = link(backup_head);
	if (cur_cmd < call) 
		#pragma region <Expand a nonmacro 367>
	{
		if (tracing_commands > 1) show_cur_cmd_chr();
		switch (cur_cmd) {
		case top_bot_mark:
			#pragma region <Insert the appropriate mark text into the scanner 386>
			if (cur_mark[cur_chr] != null) begin_token_list(cur_mark[cur_chr], mark_text);
			#pragma endregion
			break;
		case expand_after:
			#pragma region <Expand the token after the next token 368>
			get_token(); t = cur_tok; get_token();
			if (cur_cmd > max_command)
				expand();
			else back_input();
			cur_tok = t;
			back_input();
			#pragma endregion
			break;
		case no_expand:
			#pragma region <Suppress expansion of the next token 369>
			save_scanner_status = scanner_status; scanner_status = normal;
			get_token();
			scanner_status = save_scanner_status; t = cur_tok;
			back_input();
			if (t >= cs_token_flag) {
				p = get_avail(); info(p) = cs_token_flag + frozen_dont_expand;
				link(p) = loc;
				start = p;
				loc = p;
			}
			#pragma endregion
			break;
		case cs_name:
			#pragma region <Manufacture a control sequence name 372>
			r = get_avail(); p = r;
			do {
				get_x_token();
				if (cur_cs == 0) store_new_token(cur_tok);
			} while (!(cur_cs != 0));
			if (cur_cmd != end_cs_name) 
				#pragma region <Complain about missing endcsname 373>
			{
				print_err(TEX_STRING("Missing "));
				print_esc(TEX_STRING("endcsname"));
				print(TEX_STRING(" inserted"));
				help2(TEX_STRING("The control sequence marked <to be read again> should"),
					TEX_STRING("not appear between \csname and \endcsname."));
				back_error();
			}
				#pragma endregion

			#pragma region <Look up the characters of list r in the hash table, and set cur_cs 374>
			j = first; p = link(r);
			while (p != null) {
				if (j >= max_buf_stack) {
					max_buf_stack = j + 1;
					if (max_buf_stack == buf_size) overflow(TEX_STRING("buffer size"), buf_size);
				}
				buffer[j] = info(p) % 0400; incr(j); p = link(p);
			}
			if (j > first + 1) {
				no_new_control_sequence = false; cur_cs = id_lookup(first, j - first);
				no_new_control_sequence = true;
			}
			else if (j == first) cur_cs = null_cs;
			else cur_cs = single_base + buffer[first];
			#pragma endregion

			flush_list(r);
			if (eq_type(cur_cs) == undefined_cs) {
				eq_define(cur_cs, relax, 256);
			}
			cur_tok = cur_cs + cs_token_flag; back_input();
			#pragma endregion
			break;
		case convert:
			conv_toks();
			break;
		case the:
			ins_the_toks();
			break;
		case if_test:
			conditional();
			break;
		case fi_or_else:
			#pragma region <Terminate the current conditional and skip to fi 510>
			if (cur_chr > if_limit)
				if (if_limit == if_code) insert_relax();
				else {
					print_err(TEX_STRING("Extra ")); print_cmd_chr(fi_or_else, cur_chr);
					help1(TEX_STRING("I'm ignoring this; it doesn't match any \if."));
					error();
				}
			else {
				while (cur_chr != fi_code) pass_text();
				#pragma region <Pop the condition stack 496>
				p = cond_ptr; if_line = if_line_field(p); cur_if = subtype(p); if_limit = type(p);
				cond_ptr = link(p); free_node(p, if_node_size);
				#pragma endregion
			}
			#pragma endregion
			break;
		case input:
			#pragma region <Initiate or terminate input from a file 378>
			if (cur_chr > 0) force_eof = true;
			else if (name_in_progress) insert_relax();
			else
				start_input();
			#pragma endregion
			break;
		default:
			#pragma region <Complain about an undefined macro 370>
			print_err(TEX_STRING("Undefined control sequence"));
			help5(TEX_STRING("The control sequence at the end of the top line"),
				TEX_STRING("of your error message was never \def'ed. If you have"),
				TEX_STRING("misspelled it (e.g., `\hobx'), type `I' and the correct"),
				TEX_STRING("spelling (e.g., `I\hbox'). Otherwise just continue,"),
				TEX_STRING("and I'll forget about whatever was undefined."));
			error();
			#pragma endregion
			break;
		}
	}
		#pragma endregion
	else if (cur_cmd < end_template) macro_call();
	else 
		#pragma region <Insert a token containing frozen_endv 375>
	{
		cur_tok = cs_token_flag + frozen_endv;
		back_input();
	}
#pragma endregion

	cur_val = cv_backup; cur_val_level = cvl_backup; radix = radix_backup; cur_order = co_backup;
	link(backup_head) = backup_backup;
}

// 389
void macro_call()
{
	pointer r, p, q, s, t, u, v, rbrace_ptr;
	small_number n;
	halfword unbalance;
	halfword m;
	pointer ref_count;
	small_number save_scanner_status;
	pointer save_warning_index;
	ASCII_code match_chr;

	save_scanner_status = scanner_status; save_warning_index = warning_index;
	warning_index = cur_cs; ref_count = cur_chr; r = link(ref_count); n = 0;
	if (tracing_macros > 0) 
		#pragma region <Show the text of the macro being expanded 401>	
	{
		begin_diagnostic();
		print_ln();
		print_cs(warning_index);
		token_show(ref_count);
		end_diagnostic(false);
	}
		#pragma endregion

	if (info(r) != end_match_token) 
		#pragma region <Scan the parameters and make link(r) pont to the macro body;.. 391>
	{
		scanner_status = matching; unbalance = 0; long_state = eq_type(cur_cs);
		if (long_state >= outer_call)
			long_state = long_state - 2;
		do {
			link(temp_head) = null;
			if (info(r) > match_token + 255 || info(r) < match_token)
				s = null;
			else {
				match_chr = info(r) - match_token;
				s = link(r);
				r = s;
				p = temp_head;
				m = 0;
			}
			#pragma region <Scan a parameter until its delimiter string has been found; or if s = null.. 392>
		mycontinue:
			get_token();
			if (cur_tok == info(r)) 
				#pragma region <Advance r; goto found if the parameter delimiter has been fully matched.. 394>
			{
				r = link(r);
				if (info(r) >= match_token && info(r) <= end_match_token) {
					if (cur_tok < left_brace_limit) decr(align_state);
					goto found;
				}
				else goto mycontinue;
			}
				#pragma endregion

			#pragma region <Contribute the recently matched tokens to the current paramter, and goto continue if a partial match... 397>			
			if (s != r)
				if (s == null)
					#pragma region <Report an improper use of the macro and abort 398>
				{
					print_err(TEX_STRING("Use of "));
					sprint_cs(warning_index);
					print(TEX_STRING(" doesn't match its definition"));
					help4(TEX_STRING("If you say, e.g., `\def\a1{...}', then you must always"),
						TEX_STRING("put `1' after `\a', since control sequence names are"),
						TEX_STRING("made up of letters only. The macro here has not been"),
						TEX_STRING("followed by the required stuff, so I'm ignoring it."));
					error();
					goto _exit;
				}
					#pragma endregion
				else {
					t = s;
					do {
						store_new_token(info(t)); incr(m); u = link(t); v = s;
						while (1) {
							if (u == r)
								if (cur_tok != info(v)) goto done;
								else {
									r = link(v); goto mycontinue;
								}
							if (info(u) != info(v)) goto done;
							u = link(u); v = link(v);
						}
					done: t = link(t);
					} while (!(t == r));
					r = s;
				}

			#pragma endregion
			if (cur_tok == par_token)
				if (long_state != long_call) 
					#pragma region <Report a runaway argument and abort 396>
				{
					if (long_state == call) {
						runaway();
						print_err(TEX_STRING("Paragraph ended before ")); sprint_cs(warning_index);
						print(TEX_STRING(" was complete"));
						help3(TEX_STRING("I suspect you've forgotten a `}', causing me to apply this"),
							TEX_STRING("control sequence to too much text. How can we recover?"),
							TEX_STRING("My plan is to forget the whole thing and hope for the best."));
						back_error();
					}
					pstack[n] = link(temp_head); align_state -= unbalance;
					for (m = 0; m <= n; m++) flush_list(pstack[m]);
					goto _exit;
				}
					#pragma endregion
			if (cur_tok < right_brace_limit)
				if (cur_tok < left_brace_limit) 
					#pragma region <Contribute an entire group to the current paramter 399>
				{

					unbalance = 1;
					while (1) {
						store_new_token(cur_tok); get_token();
						if(cur_tok == par_token)
							if (long_state != long_call)
								#pragma region <Report a runaway argument and abort 396>
							{
								if (long_state == call) {
									runaway();
									print_err(TEX_STRING("Paragraph ended before ")); sprint_cs(warning_index);
									print(TEX_STRING(" was complete"));
									help3(TEX_STRING("I suspect you've forgotten a `}', causing me to apply this"),
										TEX_STRING("control sequence to too much text. How can we recover?"),
										TEX_STRING("My plan is to forget the whole thing and hope for the best."));
									back_error();
								}
								pstack[n] = link(temp_head); align_state -= unbalance;
								for (m = 0; m <= n; m++) flush_list(pstack[m]);
								goto _exit;
							}
								#pragma endregion
						if(cur_tok < right_brace_limit)
							if (cur_tok < left_brace_limit) incr(unbalance);
							else {
								decr(unbalance);
								if (unbalance == 0) goto done1;
							}
					}
				done1: rbrace_ptr = p; store_new_token(cur_tok);
				}
					#pragma endregion
				else
					#pragma region <Report an extra right brace and goto continue 395>
				{
					back_input();
					print_err(TEX_STRING("Argument of "));
					sprint_cs(warning_index);
					print(TEX_STRING(" has an extra }"));
					help6(TEX_STRING("I've run across a `}' that doesn't seem to match anything."),
						TEX_STRING("For example, `\def\a#1{...}' and `\a}' would produce"),
						TEX_STRING("this error. If you simply proceed now, the `\par' that"),
						TEX_STRING("I've just inserted will cause me to report a runaway"),
						TEX_STRING("argument that might be the root of the problem. But if"),
						TEX_STRING("your `}' was spurious, just type `2' and it will go away."));
					incr(align_state);
					long_state = call; cur_tok = par_token;
					ins_error();
					goto mycontinue;
				}
					#pragma endregion
			else 
				#pragma region <Store the current token but goto continue if it is a blank sapce that woudl become an undelmited paramter 393>
			{
				if (cur_tok == space_token)
					if (info(r) <= end_match_token)
						if (info(r) >= match_token)
							goto mycontinue;
				store_new_token(cur_tok);
			}
				#pragma endregion
			
			incr(m);
			if (info(r) > end_match_token)
				goto mycontinue;
			if (info(r) < match_token)
				goto mycontinue;
		found:
			if (s != null) 
				#pragma region <Tidy up the parameter just scanned and tuck it away 400>
			{
				if (m == 1 && info(p) < right_brace_limit && p != temp_head) {
					link(rbrace_ptr) = null; free_avail(p); p = link(temp_head);
					pstack[n] = link(p); free_avail(p);
				}
				else pstack[n] = link(temp_head);
				incr(n);
				if (tracing_macros > 0) {
					begin_diagnostic(); print_nl(match_chr); print_int(n); print(TEX_STRING("<-"));
					show_token_list(pstack[n - 1], null, 1000); end_diagnostic(false);
				}
			}
				#pragma endregion

			#pragma endregion

		} while (!(info(r) == end_match_token));

	}
		#pragma endregion

	#pragma region <Feed the macro body and its parameters to the scanner 390>
	while (state == token_list && loc == null && token_type != v_template)
		end_token_list();
	begin_token_list(ref_count, macro); name = warning_index; loc = link(r);
	if (n > 0) {
		if (param_ptr + n > max_param_stack) {
			max_param_stack = param_ptr + n;
			if (max_param_stack > param_size) overflow(TEX_STRING("parameter stack size"), param_size);
		}
		for (m = 0; m <= n - 1; m++) param_stack[param_ptr + m] = pstack[m];
		param_ptr += n;
	}
	#pragma endregion

_exit:
	scanner_status = save_scanner_status; warning_index = save_warning_index;
}

void get_x_token()
{
restart:
	get_next();
	if (cur_cmd <= max_command)
		goto done;
	if (cur_cmd >= call)
		if (cur_cmd < end_template)
			macro_call();
		else {
			cur_cs = frozen_endv;
			cur_cmd = endv;
			goto done;
		}
	else
		expand();
	goto restart;
done:
	if (cur_cs == 0)
		cur_tok = (cur_cmd * 0400) + cur_chr;
	else
		cur_tok = cs_token_flag + cur_cs;
}

// 944
// init
#ifndef NO_INIT
quarterword new_trie_op(small_number d, small_number n, quarterword v)
{
	int h; //-trie_op_size..trie_op_size
	quarterword u;
	unsigned l; // 0..trie_op_size

	h = myabs(n + 313 * d + 361 * v + 1009 * cur_lang) % (trie_op_size + trie_op_size) - trie_op_size;
	while (1) {
		l = trie_op_hash[h];
		if (l == 0) {
			if (trie_op_ptr == trie_op_size) overflow(TEX_STRING("pattern memory ops"), trie_op_size);
			u = trie_used[cur_lang];
			if (u == max_quarterword)
				overflow(TEX_STRING("pattern memory ops per language"), max_quarterword - min_quarterword);
			incr(trie_op_ptr); incr(u); trie_used[cur_lang] = u; hyf_distance[trie_op_ptr] = d;
			hyf_num[trie_op_ptr] = n; hyf_next[trie_op_ptr] = v; trie_op_lang[trie_op_ptr] = cur_lang;
			trie_op_hash[h] = trie_op_ptr; trie_op_val[trie_op_ptr] = u; return u;
		}
		if (hyf_distance[l] == d && hyf_num[l] == n && hyf_next[l] == v && trie_op_lang[l] == cur_lang) {
			return trie_op_val[l];
		}
		if (h > -trie_op_size) decr(h); else h = trie_op_size;
	}
}


// 948
trie_pointer trie_node(trie_pointer p)
{
	trie_pointer h;
	trie_pointer q;
	trie_pointer retval;
	h = myabs(trie_c[p] + 1009 * trie_o[p] + 2718 * trie_l[p] + 3142 * trie_r[p]) % trie_size;
	while (1) {
		q = trie_hash[h];
		if (q == 0) {
			trie_hash[h] = p; retval = p; return retval;
		}
		if (trie_c[q] == trie_c[p] && trie_o[q] == trie_o[p] && trie_l[q] == trie_l[p] && trie_r[q] == trie_r[p]) {
			retval = q; return retval;
		}
		if (h > 0) decr(h); else h = trie_size;
	}
}

// 949
trie_pointer compress_trie(trie_pointer p)
{
	trie_pointer retval;
	if (p == 0) retval = 0;
	else {
		trie_l[p] = compress_trie(trie_l[p]); trie_r[p] = compress_trie(trie_r[p]);
		retval = trie_node(p);
	}
	return retval;
}

// 953
void first_fit(trie_pointer p)
{
	trie_pointer h;
	trie_pointer z;
	trie_pointer q;
	ASCII_code c;
	trie_pointer l, r;
	int ll; // 1..256

	c = so(trie_c[p]); z = trie_min[c];
	while (1) {
		h = z - c;
		#pragma region Ensure that trie_max >= h+256 954>
		if (trie_max < h + 256) {
			if (trie_size <= h + 256) overflow(TEX_STRING("pattern memory"), trie_size);
			do {
				incr(trie_max); trie_taken[trie_max] = false; trie_link(trie_max) = trie_max + 1;
				trie_back(trie_max) = trie_max - 1;
			} while (!(trie_max == h + 256));
		}
		#pragma endregion
		if (trie_taken[h]) goto not_found;
		#pragma region <If all characters of the family fit relative to h, then goto found otherwise goto not_found 955>
		q = trie_r[p];
		while (q > 0) {
			if (trie_link(h + so(trie_c[q])) == 0) goto not_found;
			q = trie_r[q];
		}
		goto found;
		#pragma endregion

	not_found:
		z = trie_link(z);
	}
found:
	#pragma region <Pack the family into trie relative to h 956>
	trie_taken[h] = true; trie_ref[p] = h; q = p;
	do {
		z = h + so(trie_c[q]); l = trie_back(z); r = trie_link(z); trie_back(r) = l; trie_link(l) = r;
		trie_link(z) = 0;
		if (l < 256) {
			if (z < 256) ll = z;
			else ll = 256;
			do {
				trie_min[l] = r; incr(l);
			} while (!(l == ll));
		}
		q = trie_r[q];
	} while (!(q == 0));
	#pragma endregion
}

// 957
void trie_pack(trie_pointer p)
{
	trie_pointer q;
	do {
		q = trie_l[p];
		if (q > 0 && trie_ref[q] == 0) {
			first_fit(q); trie_pack(q);
		}
		p = trie_r[p];
	} while (!(p == 0));
}

// 959
void trie_fix(trie_pointer p)
{
	trie_pointer q;
	ASCII_code c;
	trie_pointer z;
	z = trie_ref[p];
	do {
		q = trie_l[p]; c = so(trie_c[p]); trie_link(z + c) = trie_ref[q]; trie_char(z + c) = qi(c);
		trie_op(z + c) = trie_o[p];
		if (q > 0) trie_fix(q);
		p = trie_r[p];
	} while (!(p == 0));
}


//960
void new_patterns()
{
	unsigned char k, l;
	bool digit_sensed;
	quarterword v;
	trie_pointer p, q;
	bool first_child;
	ASCII_code c;

	if (trie_not_ready) {
		set_cur_lang;
		scan_left_brace();
		#pragma region <Enter all of the patterns into a linked trie, until coming to a right brace 961>
		k = 0; hyf[0] = 0; digit_sensed = false;
		while (1) {
			get_x_token();
			switch (cur_cmd) {
			case letter:
			case other_char:
				#pragma region <Append a new letter of a hyphen level 962>
				if (digit_sensed || cur_chr < TEX_STRING("0") || 
					cur_chr > TEX_STRING("9")) {
					if (cur_chr == TEX_STRING(".")) cur_chr = 0;
					else {
						cur_chr = lc_code(cur_chr);
						if (cur_chr == 0) {
							print_err(TEX_STRING("Nonletter"));
							help1(TEX_STRING("(See Appendix H.)"));
							error();
						}
					}
					if (k < 63) {
						incr(k); hc[k] = cur_chr; hyf[k] = 0; digit_sensed = false;
					}
				}
				else if (k < 63) {
					hyf[k] = cur_chr - TEX_STRING("0"); digit_sensed = true;
				}
				#pragma endregion
				break;
			case spacer:
			case right_brace:
				if (k > 0)
					#pragma region <Insert a new pattern into the linked trie 963>
				{
					#pragma region <Compute the trie op code, v, and set l = 0 965>
					if (hc[1] == 0) hyf[0] = 0;
					if (hc[k] == 0) hyf[k] = 0;
					l = k; v = min_quarterword;
					while (1) {
						if (hyf[l] != 0) v = new_trie_op(k - l, hyf[l], v);
						if (l > 0) decr(l); else goto done1;
					}
				done1:

					#pragma endregion
					q = 0; hc[0] = cur_lang;
					while (l <= k) {
						c = hc[l]; incr(l); p = trie_l[q]; first_child = true;
						while (p > 0 && c > so(trie_c[p])) {
							q = p; p = trie_r[q]; first_child = false;
						}
						if (p == 0 || c < so(trie_c[p]))
							#pragma region <Insert a new trie node between q and p, and make p point to it 964>
						{
							if (trie_ptr == trie_size) overflow(TEX_STRING("pattern memory"), trie_size);
							incr(trie_ptr); trie_r[trie_ptr] = p; p = trie_ptr; trie_l[p] = 0;
							if (first_child) trie_l[q] = p; else trie_r[q] = p;
							trie_c[p] = si(c); trie_o[p] = min_quarterword;
						}
							#pragma endregion
						q = p;
					}
					if (trie_o[q] != min_quarterword) {
						print_err(TEX_STRING("Duplicate pattern"));
						help1(TEX_STRING("(See Appendix H.)"));
						error();
					}
					trie_o[q] = v;
				}
					#pragma endregion
				if (cur_cmd == right_brace) goto done;
				k = 0; hyf[0] = 0; digit_sensed = false;
				break;
			default:
				print_err(TEX_STRING("Bad "));
				print_esc(TEX_STRING("patterns"));
				help1(TEX_STRING("(See Appendix H.)"));
				error();
				break;
			}
		}
	done:
		;
		#pragma endregion
	}
	else {
		print_err(TEX_STRING("Too late for "));
		print_esc(TEX_STRING("patterns"));
		help1(TEX_STRING("All patterns must be given before typesetting begins."));
		error();
		link(garbage) = scan_toks(false, false); flush_list(def_ref);
	}
}


// 966
void init_trie()
{
	trie_pointer p;
	int j, k, t;
	trie_pointer r, s;
	two_halves h;

	#pragma region <Get ready to compress the trie 952>

	#pragma region <Sort the hyphenation op tables into proper order 945>
	op_start[0] = -min_quarterword;
	for (j = 1; j <= 255; j++) op_start[j] = op_start[j - 1] + qo(trie_used[j - 1]);
	for (j = 1; j <= trie_op_ptr; j++) trie_op_hash[j] = op_start[trie_op_lang[j]] + trie_op_val[j];
	for (j = 1; j <= trie_op_ptr; j++)
		while (trie_op_hash[j] > (unsigned)j) {
			k = trie_op_hash[j];
			t = hyf_distance[k]; hyf_distance[k] = hyf_distance[j]; hyf_distance[j] = t;
			t = hyf_num[k]; hyf_num[k] = hyf_num[j]; hyf_num[j] = t;
			t = hyf_next[k]; hyf_next[k] = hyf_next[j]; hyf_next[j] = t;
			trie_op_hash[j] = trie_op_hash[k]; trie_op_hash[k] = k;
		}
	#pragma endregion

	for (p = 0; p <= trie_size; p++) trie_hash[p] = 0;
	trie_root = compress_trie(trie_root);
	for (p = 0; p <= trie_ptr; p++) trie_ref[p] = 0;
	for (p = 0; p <= 255; p++) trie_min[p] = p + 1;
	trie_link(0) = 1; trie_max = 0;
	#pragma endregion

	if (trie_root != 0) {
		first_fit(trie_root); trie_pack(trie_root);
	}
	#pragma region <Move the data into trie 958>
	h.rh = 0; h.b0 = min_quarterword; h.b1 = min_quarterword;
	if (trie_root == 0) {
		for (r = 0; r <= 256; r++) trie[r] = h;
		trie_max = 256;
	}
	else {
		trie_fix(trie_root);
		r = 0;
		do {
			s = trie_link(r); trie[r] = h; r = s;
		} while (!(r > trie_max));
	}
	trie_char(0) = qi(TEX_STRING("?"));
	#pragma endregion

	trie_not_ready = false;
}

#endif
// tini

// 1215
void get_r_token()
{
restart:
	do {
		get_token();
	} while (!(cur_tok != space_token));
	if (cur_cs == 0 || cur_cs > frozen_control_sequence) {
		print_err(TEX_STRING("Missing control sequence inserted"));
		help5(TEX_STRING("Please don't say `\def cs{...}', say `\def\cs{...}'."),
			TEX_STRING("I've inserted an inaccessible control sequence so that your"),
			TEX_STRING("definition will be completed without mixing me up too badly."),
			TEX_STRING("You can recover graciously from this error, if you're"),
			TEX_STRING("careful; see exercise 27.2 in The TeXbook."));
		if (cur_cs == 0)
			back_input();
		cur_tok = cs_token_flag + frozen_protection;
		ins_error();
		goto restart;
	}
}

// 323
void begin_token_list(pointer p, quarterword t)
{
	push_input;
	state = token_list;
	start = p;
	token_type = (enum_token_type)t;
	if (t >= macro) {
		add_token_ref(p);
		if (t == macro) param_start = param_ptr;
		else {
			loc = link(p);
			if (tracing_macros > 1) {
				begin_diagnostic();
				print_nl(TEX_STRING(""));
				switch (t) {
				case mark_text: print_esc(TEX_STRING("mark")); break;
				case write_text: print_esc(TEX_STRING("write")); break;
				default:
					print_cmd_chr(assign_toks, t - output_text + output_routine_loc);
					break;
				}
				print(TEX_STRING("->")); token_show(p);
				end_diagnostic(false);
			}
		}
	}
	else
		loc = p;
}

// 324
void end_token_list()
{
	if (token_type >= backed_up) {
		if (token_type <= inserted)
			flush_list(start);
		else {
			delete_token_ref(start);
			if (token_type == macro)
				while (param_ptr > param_start) {
					decr(param_ptr); flush_list(param_stack[param_ptr]);
				}
		}
	}
	else if (token_type == u_template)
		if (align_state > 500000) align_state = 0;
		else fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));

	pop_input; check_interrupt;
}

//381
void x_token()
{
	while (cur_cmd > max_command) {
		expand(); get_next();
	}
	if (cur_cs == 0) cur_tok = (cur_cmd * 0400) + cur_chr;
	else cur_tok = cs_token_flag + cur_cs;
}

// 403
void scan_left_brace()
{
	#pragma region <Get the next non-blank non relax non-call token 404>
	do 
	{
		get_x_token();
	} while (!(cur_cmd != spacer && cur_cmd != relax));
	#pragma endregion

	if (cur_cmd != left_brace) {
		print_err(TEX_STRING("Missing { inserted"));
		help4(TEX_STRING("A left brace was mandatory here, so I've put one in."),
			TEX_STRING("You might want to delete and/or insert some corrections"),
			TEX_STRING("so that I will find a matching right brace soon."),
			TEX_STRING("(If you're confused by all this, try typing `I}' now.)"));
		back_error();
		cur_tok = left_brace_token + TEX_STRING("{");
		cur_cmd = left_brace; cur_chr = TEX_STRING("{"); incr(align_state);
	}
}

// 473
pointer scan_toks(bool macro_def, bool xpand)
{
	halfword t;
	halfword s;
	pointer p;
	pointer q;
	halfword unbalance;
	halfword hash_brace;
	if (macro_def)
		scanner_status = defining;
	else
		scanner_status = absorbing;
	warning_index = cur_cs;
	def_ref = get_avail();
	token_ref_count(def_ref) = null;
	p = def_ref;
	hash_brace = 0;
	t = zero_token;
	if (macro_def) {
		#pragma region <Scan and build the parameter part of the macro definition 474>
		while (1) {
			get_token();
			if (cur_tok < right_brace_limit) goto done1;
			if (cur_cmd == mac_param)
				#pragma region <If the next character is a parameter number.. 476>
			{
				s = match_token + cur_chr;
				get_token();
				if (cur_cmd == left_brace) {
					hash_brace = cur_tok; store_new_token(cur_tok); store_new_token(end_match_token);
					goto done;
				}
				if (t == zero_token + 9) {
					print_err(TEX_STRING("You already have nine parameters"));
					help1(TEX_STRING("I'm going to ignore the # sign you just used."));
					error();
				}
				else {
					incr(t);
					if (cur_tok != t) {
						print_err(TEX_STRING("Parameters must be numbered consecutively"));
						help2(TEX_STRING("I've inserted the digit you should have used after the #."),
							TEX_STRING("Type `1' to delete what you did use."));
						back_error();
					}
					cur_tok = s;
				}
			}
				#pragma endregion
			store_new_token(cur_tok);
		}
	done1: store_new_token(end_match_token);
		if (cur_cmd == right_brace)
			#pragma region Express shock at the missing left brace; goto found 475
		{
			print_err(TEX_STRING("Missing { inserted")); incr(align_state);
			help2(TEX_STRING("Where was the left brace? You said something like `\def\a}',"),
				TEX_STRING("which I'm going to interpret as `\def\a{}'."));
			error();
			goto found;
		}
			#pragma endregion
		done:;
		#pragma endregion
	}
	else
		scan_left_brace();

	#pragma region <Scan and build the body of the token list; goto found when finished 477>
	unbalance = 1;
	while (1) {
		if(xpand)
			#pragma region <Expand the next part of the input 478>
		{
			while (1) {
				get_next();
				if (cur_cmd <= max_command) goto done2;
				if (cur_cmd != the) expand();
				else {
					q = the_toks();
					if (link(temp_head) != null) {
						link(p) = link(temp_head); p = q;
					}
				}
			}
		done2:		x_token();
		}
			#pragma endregion
		else get_token();
		if (cur_tok < right_brace_limit)
			if (cur_cmd < right_brace) incr(unbalance);
			else {
				decr(unbalance);
				if (unbalance == 0) goto found;
			}
		else if(cur_cmd == mac_param)
			if(macro_def) 
				#pragma region <Look for parameter number or .. 479>
			{
				s = cur_tok;
				if (xpand) get_x_token();
				else get_token();
				if(cur_cmd != mac_param)
					if (cur_tok <= zero_token || cur_tok > t) {
						print_err(TEX_STRING("Illegal parameter number in definition of "));
						sprint_cs(warning_index);
						help3(TEX_STRING("You meant to type ## instead of #, right?"),
							TEX_STRING("Or maybe a } was forgotten somewhere earlier, and things"),
							TEX_STRING("are all screwed up? I'm going to assume that you meant ##."));
						back_error();
						cur_tok = s;
					}
					else cur_tok = out_param_token - TEX_STRING("0") + cur_chr;
			}
				#pragma endregion
		store_new_token(cur_tok);
	}
	#pragma endregion

found:
	scanner_status = normal;
	if (hash_brace != 0)
		store_new_token(hash_brace);
	return p;
}

// 482
void read_toks(int n, pointer r)
{
	pointer p;
	pointer q;
	int s;
	small_number m;

	scanner_status = defining;
	warning_index = r;
	def_ref = get_avail();
	token_ref_count(def_ref) = null;
	p = def_ref;
	store_new_token(end_match_token);
	if (n < 0 || n>15)
		m = 16;
	else
		m = n;
	s = align_state; align_state = 1000000;
	do {
		#pragma region <Input and store tokens from the next line of the file 483>
		begin_file_reading();
		name = m + 1;
		if (read_open[m] == closed)
			#pragma region <Input for read from the terminal 484>
		{

			if (interaction > nonstop_mode) {
				if (n < 0)
					prompt_input(TEX_STRING(""));
				else {
					wake_up_terminal();
					print_ln();
					sprint_cs(r);
					prompt_input(TEX_STRING("="));
					n = -1;
				}
			}
			else
				fatal_error(TEX_STRING("*** (cannot \read from terminal in nonstop modes)"));
		}
			#pragma endregion
		else if (read_open[m] == just_open) 
			#pragma region <Input the first line of read_file[m] 485>
		{			

			if (input_ln(read_file[m], false)) read_open[m] = normal;
			else {
				a_close(read_file[m]); read_open[m] = closed;
			}

		}
			#pragma endregion
		else
			#pragma region <Input the next line from read_file[m] 486>
		{
			if (!input_ln(read_file[m], true)) {
				a_close(read_file[m]); read_open[m] = closed;
				if (align_state != 1000000) {
					runaway();
					print_err(TEX_STRING("File ended within "));
					print_esc(TEX_STRING("read"));
					help1(TEX_STRING("This \read has unbalanced braces."));
					align_state = 1000000;
					error();
				}
			}
		}
			#pragma endregion
		limit = last;
		if (end_line_char_inactive)
			decr(limit);
		else
			buffer[limit] = end_line_char;
		first = limit + 1; loc = start; state = new_line;
		while (1) {
			get_token();
			if (cur_tok == 0)
				goto done;
			if (align_state < 1000000) {
				do {
					get_token();
				} while (!(cur_tok == 0));
				align_state = 1000000;
				goto done;
			}
			store_new_token(cur_tok);
		}
	done:
		end_file_reading();
		#pragma endregion
	} while (!(align_state == 1000000));
	cur_val = def_ref; scanner_status = normal; align_state = s;
}

// 581
void char_warning(internal_font_number f, eight_bits c)
{
	if (tracing_lost_chars > 0) {
		begin_diagnostic();
		print_nl(TEX_STRING("Missing character: There is no "));
		print_ASCII(c);
		print(TEX_STRING(" in font "));
		slow_print(font_name[f]); 
		print_char(TEX_STRING("!"));
		end_diagnostic(false);
	}
}

//582
pointer new_character(internal_font_number f, eight_bits c)
{
	pointer p;
	if(font_bc[f] <= c)
		if(font_ec[f]>=c)
			if (char_exists(char_info(f, qi(c)))) {
				p = get_avail(); font(p) = f; character(p) = qi(c); return p;
			}
	char_warning(f, c); return null;
}

// 526
void scan_file_name()
{
	name_in_progress = true;
	begin_name();
	#pragma region <Get the next non_blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion
	while (1) {
		if (cur_cmd > other_char || cur_chr > 255) {
			back_input();
			goto done;
		}
		if (!more_name((ASCII_code)cur_chr))
			goto done;
		get_x_token();
	}
done:
	end_name();
	name_in_progress = false;
}

// 560
internal_font_number read_font_info(pointer u, str_number nom, str_number aire, scaled s)
{
	font_index k;
	bool file_opened;
	halfword lf, lh, bc, ec, nw, nh, nd, ni, nl, nk, ne, np;
	internal_font_number f;
	internal_font_number g;
	eight_bits a, b, c, d;
	four_quarters qw;
	scaled sw;
	int bch_label;
	int bchar; // 0.. 256
	scaled z;
	int alpha;
	unsigned char beta;

	g = null_font;
	#pragma region <Read and check the font data; abort if the TFM file is malformed; .. and goto done 562>

	#pragma region<Open tfm_file for input 563>
	file_opened = false;
	pack_file_name(nom, aire, TEX_STRING(".tfm"));
	if (!b_open_in(&tfm_file)) _abort;
	file_opened = true;
	#pragma endregion

	#pragma region <Read the TFM size fields 565>
	read_sixteen(lf);
	read_sixteen(lh);
	read_sixteen(bc);
	read_sixteen(ec);
	if (bc > ec + 1 || ec > 255) _abort;
	if (bc > 255) {
		bc = 1; ec = 0;
	}
	read_sixteen(nw); read_sixteen(nh); read_sixteen(nd); read_sixteen(ni);
	read_sixteen(nl); read_sixteen(nk); read_sixteen(ne); read_sixteen(np);
	if (lf != 6 + lh + (ec - bc + 1) + nw + nh + nd + ni + nl + nk + ne + np) _abort;
	if (nw == 0 || nh == 0 || nd == 0 || ni == 0) _abort;
	#pragma endregion

	#pragma region <Use size fields to allocate font information 566>
	lf = lf - 6 - lh;
	if (np < 7) lf = lf + 7 - np;
	if (font_ptr == font_max || fmem_ptr + lf > font_mem_size) 
		#pragma region <Apologize for not loading the font, goto done 567>
	{
		start_font_error_message; print(TEX_STRING(" not loaded: Not enough room left"));
		help4(TEX_STRING("I'm afraid I won't be able to make use of this font,"),
			TEX_STRING("because my memory for character-size data is too small."),
			TEX_STRING("If you're really stuck, ask a wizard to enlarge me."),
			TEX_STRING("Or maybe try `I\font<same font id>=<name of loaded font>'."));
		error();
		goto done;
	}
		#pragma endregion
	f = font_ptr + 1; char_base[f] = fmem_ptr - bc; width_base[f] = char_base[f] + ec + 1;
	height_base[f] = width_base[f] + nw; depth_base[f] = height_base[f] + nh;
	italic_base[f] = depth_base[f] + nd; lig_kern_base[f] = italic_base[f] + ni;
	kern_base[f] = lig_kern_base[f] + nl - kern_base_offset;
	exten_base[f] = kern_base[f] + kern_base_offset + nk; param_base[f] = exten_base[f] + ne;
	#pragma endregion

	#pragma region <read the TFM header 568>
	if (lh < 2) _abort;
	store_four_quarters(font_check[f]);
	read_sixteen(z);
	
	z = z * 0400 + fgetc(tfm_file); z = (z * 020) + (fgetc(tfm_file) / 020);
	if (z < unity) _abort;
	while (lh > 2) {
		fgetc(tfm_file); fgetc(tfm_file); fgetc(tfm_file); fgetc(tfm_file);
		decr(lh);
	}
	font_dsize[f] = z;
	if (s != -1000)
		if (s >= 0) z = s;
		else z = xn_over_d(z, -s, 1000);
	font_size[f] = z;
	#pragma endregion

	#pragma region <read character data 569>
	for (k = fmem_ptr; k <= width_base[f] - 1; k++) {
		store_four_quarters(font_info[k].qqqq);
		if (a >= nw || b / 020 >= nh || b % 020 >= nd || c / 4 >= ni) _abort;
		switch (c % 4) {
		case lig_tag:if (d >= nl)_abort; break;
		case ext_tag:if (d >= ne) _abort; break;
		case list_tag:
			#pragma region <Check for charlist cycle 570>
			check_byte_range(d);
			while (d < current_character_being_worked_on) {
				qw = char_info(f, d);
				if (char_tag(qw) != list_tag) goto not_found;
				d = qo(rem_byte(qw));
			}
			if (d == current_character_being_worked_on) _abort;
		not_found:
			#pragma endregion
			break;
		default:
			//do_nothing
			break;
		}
	}
	#pragma endregion

	#pragma region <read box dimensions 571>
	{
		#pragma region <Replace z by z prime and compute alpha, beta 572>
		{
			alpha = 16;
			while (z >= 040000000) {
				z = z / 2; alpha = alpha + alpha;
			}
			beta = 256 / alpha; alpha = alpha * z;
		}
		#pragma endregion
		for (k = width_base[f]; k <= lig_kern_base[f] - 1; k++) store_scaled(font_info[k].sc);
		if (font_info[width_base[f]].sc != 0) _abort;
		if (font_info[height_base[f]].sc != 0) _abort;
		if (font_info[depth_base[f]].sc != 0) _abort;
		if (font_info[italic_base[f]].sc != 0) _abort;
	}
	#pragma endregion

	#pragma region <read ligature/kern program 573>
	bch_label = 077777; bchar = 256;
	if (nl > 0) {
		for (k = lig_kern_base[f]; k <= kern_base[f] + kern_base_offset - 1;k++) {
			store_four_quarters(font_info[k].qqqq);
			if (a > 128) {
				if (256 * c + d >= nl) _abort;
				if (a == 255)
					if (k == lig_kern_base[f]) bchar = b;
			}
			else {
				if (b != bchar) check_existence(b);
				if (c < 128) check_existence(d);
				else if (256 * (c - 128) + d >= nk) _abort;
				if (a < 128)
					if (k - lig_kern_base[f] + a + 1 >= nl) _abort;
			}
		}
		if (a == 255) bch_label = 256 * c + d;
	}
	for (k = kern_base[f] + kern_base_offset; k <= exten_base[f] - 1; k++)
		store_scaled(font_info[k].sc);
	#pragma endregion

	#pragma region <read extensible chracter recipes 574>
	for (k = exten_base[f]; k <= param_base[f] - 1; k++) {
		store_four_quarters(font_info[k].qqqq);
		if (a != 0) check_existence(a);
		if (b != 0) check_existence(a);
		if (c != 0) check_existence(a);
		check_existence(d);
		
	}
	#pragma endregion

	#pragma region <read font parameters 575>
	{
		for(k=1;k<=np;k++)
			if (k == 1) {
				sw = fgetc(tfm_file);
				if (sw > 127) sw = sw - 256;
				sw = sw * 0400 + fgetc(tfm_file);
				sw = sw * 0400 + fgetc(tfm_file);
				font_info[param_base[f]].sc = (sw * 020) + (fgetc(tfm_file) / 020);
			}
			else store_scaled(font_info[param_base[f] + k - 1].sc);
		if (feof(tfm_file)) _abort;
		for (k = np + 1; k <= 7; k++) font_info[param_base[f] + k - 1].sc = 0;
	}
	#pragma endregion

	#pragma region <Make final adjustments and goto done 576>
	if (np >= 7)font_params[f] = np; else font_params[f] = 7;
	hyphen_char[f] = default_hyphen_char; skew_char[f] = default_skew_char;
	if (bch_label < nl) bchar_label[f] = bch_label + lig_kern_base[f];
	else bchar_label[f] = non_address;
	font_bchar[f] = qi(bchar); font_false_bchar[f] = qi(bchar);
	if(bchar<=ec)
		if (bchar >= bc) {
			qw = char_info(f, bchar);
			if (char_exists(qw)) font_false_bchar[f] = non_char;
		}

	// overflow check
	if (bc < 0 || bc > 255 || ec < 0 || ec > 255) {
		printf("overflow in 576\n");
		exit(1);
	}
	/////////////////
	
	font_name[f] = nom; font_area[f] = aire; font_bc[f] = (eight_bits)bc; font_ec[f] = (eight_bits)ec;
	font_glue[f] = null; adjust(char_base); adjust(width_base); adjust(lig_kern_base);
	adjust(kern_base); adjust(exten_base);
	decr(param_base[f]); fmem_ptr += lf; font_ptr = f; g = f;
	goto done;
	#pragma endregion

	#pragma endregion


bad_tfm:
	#pragma region <Report that the font wont be loaded 561>
	start_font_error_message;
	if (file_opened) print(TEX_STRING(" not loadable: Bad metric (TFM) file"));
	else print(TEX_STRING(" not loadable: Metric (TFM) file not found"));
	help5(TEX_STRING("I wasn't able to read the size data for this font,"),
		TEX_STRING("so I will ignore the font specification."),
		TEX_STRING("[Wizards can fix TFM files using TFtoPL/PLtoTF.]"),
		TEX_STRING("You might try inserting a different font spec;"),
		TEX_STRING("e.g., type `I\font<same font id>=<substitute font name>'."));
	error();
	#pragma endregion
done:
	if (file_opened)
		b_close(tfm_file);
	return g;
}


// 615
void prune_movements(int l)
{
	pointer p;
	while (down_ptr != null) {
		if (location(down_ptr) < l) goto done;
		p = down_ptr; down_ptr = link(p); free_node(p, movement_node_size);
	}
done:
	while (right_ptr != null) {
		if (location(right_ptr) < l) return;
		p = right_ptr; right_ptr = link(p); free_node(p, movement_node_size);
	}
}

//619
void hlist_out()
{
	scaled base_line;
	scaled left_edge;
	scaled save_h, save_v;
	pointer this_box;
	glue_ord g_order;
	int g_sign; // normal..shrinking
	pointer p;
	int save_loc;
	pointer leader_box;
	scaled leader_wd;
	scaled lx;
	bool outer_doing_leaders;
	scaled edge;
	float glue_temp;
	float cur_glue;
	scaled cur_g;

	cur_g = 0; cur_glue = 0.0f; this_box = temp_ptr; g_order = glue_order(this_box);
	g_sign = glue_sign(this_box); p = list_ptr(this_box); incr(cur_s);
	if (cur_s > 0) dvi_out(dvi_op::push);
	if (cur_s > max_push) max_push = cur_s;
	save_loc = dvi_offset + dvi_ptr; base_line = cur_v; left_edge = cur_h;
	while (p != null)
		#pragma region <Output node p for hlist_out and move to the next node.. 620>
		reswitch:
		if(is_char_node(p))
		{
			synch_h; synch_v;
			do
			{
				f = font(p); c = character(p);
				if (f != dvi_f)
					#pragma region <Change font dvi_f to f 621>
				{
					if (!font_used[f]) {
						dvi_font_def(f); font_used[f] = true;
					}
					if (f <= 64 + font_base) dvi_out(f - font_base - 1 + dvi_op::fnt_num_0);
					else {
						dvi_out(dvi_op::fnt1); dvi_out(f - font_base - 1);
					}
					dvi_f = f;
				}
					#pragma endregion
				if (c >= qi(128)) dvi_out(dvi_op::set1);
				dvi_out(qo(c));
				cur_h += char_width(f, char_info(f, c)); p = link(p);
			} while (!(!is_char_node(p)));
			dvi_h = cur_h;
		}
		else
			#pragma region <Output the non-char node p for hlist_out and move to the next node 622>
		{
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
				#pragma region <Output a box in an hlist 623>
				if (list_ptr(p) == null) cur_h += width(p);
				else {
					save_h = dvi_h; save_v = dvi_v; cur_v = base_line + shift_amount(p);
					temp_ptr = p; edge = cur_h;
					if (type(p) == vlist_node) vlist_out(); else hlist_out();
					dvi_h = save_h; dvi_v = save_v; cur_h = edge + width(p); cur_v = base_line;
				}
				#pragma endregion
				break;
			case rule_node:
				rule_ht = height(p); rule_dp = depth(p); rule_wd = width(p); goto fin_rule;
				break;
			case whatsit_node:
				#pragma region <Output the whatsit node p in an hlist 1367>
				out_what(p);
				#pragma endregion
				break;
			case glue_node:
				#pragma region <Move right or output leaders 625>
				g = glue_ptr(p); rule_wd = width(g) - cur_g;
				if (g_sign != normal) {
					if (g_sign == stretching) {
						if (stretch_order(g) == g_order) {
							cur_glue += stretch(g);
							vet_glue(_float(glue_set(this_box)) * cur_glue);
							cur_g = (scaled)round(glue_temp);
						}
					}
					else if (shrink_order(g) == g_order) {
						cur_glue -= shrink(g);
						vet_glue(_float(glue_set(this_box)) * cur_glue);
						cur_g = (scaled)round(glue_temp);
					}
				}
				rule_wd += cur_g;
				if (subtype(p) >= a_leaders)
					#pragma region <Output leaders in an hlist, goto fin_rule if a rule or to next_p if done 626>
				{
					leader_box = leader_ptr(p);
					if (type(leader_box) == rule_node) {
						rule_ht = height(leader_box); rule_dp = depth(leader_box); goto fin_rule;
					}
					leader_wd = width(leader_box);
					if (leader_wd > 0 && rule_wd > 0) {
						rule_wd += 10;
						edge = cur_h + rule_wd; lx = 0;
						#pragma region <Let cur_h be the position of the first box, and set leader_wd +lx.. 627>
						if (subtype(p) == a_leaders) {
							save_h = cur_h; cur_h = left_edge + leader_wd * ((cur_h - left_edge) / leader_wd);
							if (cur_h < save_h) cur_h += leader_wd;
						}
						else {
							lq = rule_wd / leader_wd;
							lr = rule_wd % leader_wd;
							if (subtype(p) == c_leaders) cur_h += (lr / 2);
							else {
								lx = lr / (lq + 1); cur_h += ((lr - (lq - 1)*lx) / 2);
							}
						}
						#pragma endregion
						while (cur_h + leader_wd <= edge)
							#pragma region <Output a leader box at cur_h, then advance cur_h by leader_wd+lx 628>
						{
							cur_v = base_line + shift_amount(leader_box); synch_v; save_v = dvi_v;
							synch_h; save_h = dvi_h; temp_ptr = leader_box; outer_doing_leaders = doing_leaders;
							doing_leaders = true;
							if (type(leader_box) == vlist_node) vlist_out(); else hlist_out();
							doing_leaders = outer_doing_leaders; dvi_v = save_v; dvi_h = save_h; cur_v = base_line;
							cur_h = save_h + leader_wd + lx;
						}
							#pragma endregion
						cur_h = edge - 10; goto next_p;
					}
				}
				#pragma endregion
				goto move_past;

				#pragma endregion
				break;
			case kern_node:
			case math_node:
				cur_h += width(p);
				break;
			case ligature_node:
				#pragma region <Make node p look like a char_node and goto reswitch 652>
				mem[lig_trick] = mem[lig_char(p)]; link(lig_trick) = link(p); p = lig_trick; goto reswitch;
				#pragma endregion
				break;
			default:
				//do_nothing
				break;
			}
			goto next_p;

fin_rule:

			#pragma region <Output a rule in an hlist 624>
			if (is_running(rule_ht)) rule_ht = height(this_box);
			if (is_running(rule_dp)) rule_dp = depth(this_box);
			rule_ht += rule_dp;
			if (rule_ht > 0 && rule_wd > 0) {
				synch_h; cur_v = base_line + rule_dp; synch_v; dvi_out(dvi_op::set_rule); dvi_four(rule_ht);
				dvi_four(rule_wd); cur_v = base_line; dvi_h += rule_wd;
			}
			#pragma endregion
move_past:
			cur_h += rule_wd;
next_p:
			p = link(p);
		}
		#pragma endregion

		#pragma endregion

	prune_movements(save_loc);
	if (cur_s > 0) dvi_pop(save_loc);
	decr(cur_s);
}

//629
void vlist_out()
{
	scaled left_edge;
	scaled top_edge;
	scaled save_h, save_v;
	pointer this_box;
	glue_ord g_order;
	int g_sign; // normal..shrinking
	pointer p;
	int save_loc;
	pointer leader_box;
	scaled leader_ht;
	scaled lx;
	bool outer_doing_leaders;
	scaled edge;
	float glue_temp;
	float cur_glue;
	scaled cur_g;

	cur_g = 0; cur_glue = 0.0f; this_box = temp_ptr; g_order = glue_order(this_box);
	g_sign = glue_sign(this_box); p = list_ptr(this_box); incr(cur_s);
	if (cur_s > 0) dvi_out(dvi_op::push);
	if (cur_s > max_push) max_push = cur_s;
	save_loc = dvi_offset + dvi_ptr; left_edge = cur_h; cur_v = cur_v - height(this_box); top_edge = cur_v;
	while (p != null)
		#pragma region <Output node p for vlist_out and move to the next node, maintaining.. 630>
	{
		if (is_char_node(p)) 
			confusion(TEX_STRING("vlistout"));
		else
			#pragma region <Output the non-char node p for vlist_out 631>
		{
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
				#pragma region <Output a box in a vlist 632>
				if (list_ptr(p) == null) cur_v += height(p) + depth(p);
				else {
					cur_v += height(p); synch_v; save_h = dvi_h; save_v = dvi_v;
					cur_h = left_edge + shift_amount(p);
					temp_ptr = p;
					if (type(p) == vlist_node) vlist_out(); else hlist_out();
					dvi_h = save_h; dvi_v = save_v; cur_v = save_v + depth(p); cur_h = left_edge;
				}
				#pragma endregion
				break;
			case rule_node:
				rule_ht = height(p); rule_dp = depth(p); rule_wd = width(p); goto fin_rule;
				break;
			case whatsit_node:
				#pragma region <Output the whatsit node p in a vlist 1366>
				out_what(p);
				#pragma endregion
				break;
			case glue_node:
				#pragma region <Move down or output leaders 634>
				g = glue_ptr(p); rule_ht = width(g) - cur_g;
				if (g_sign != normal) {
					if (g_sign == stretching) {
						if (stretch_order(g) == g_order) {
							cur_glue += stretch(g);
							vet_glue(_float(glue_set(this_box)) * cur_glue);
							cur_g = (scaled)round(glue_temp);
						}
					}
					else if (shrink_order(g) == g_order) {
						cur_glue -= shrink(g);
						vet_glue(_float(glue_set(this_box)) * cur_glue);
						cur_g = (scaled)round(glue_temp);
					}
				}
				rule_ht += cur_g;
				if (subtype(p) >= a_leaders)
					#pragma region <Output leaders in a vlist, goto fin_rule if a rule or to next_p if done 635>
				{
					leader_box = leader_ptr(p);
					if (type(leader_box) == rule_node) {
						rule_wd = width(leader_box); rule_dp = 0; goto fin_rule;
					}
					leader_ht = height(leader_box) + depth(leader_box);
					if (leader_ht > 0 && rule_ht > 0) {
						rule_ht += 10;
						edge = cur_v + rule_ht; lx = 0;
						#pragma region <Let cur_v be the position of the first box, and set leader_ht+lx to.. 636>
						if (subtype(p) == a_leaders) {
							save_v = cur_v; cur_v = top_edge + leader_ht * ((cur_v - top_edge) / leader_ht);
							if (cur_v < save_v) cur_v += leader_ht;
						}
						else {
							lq = rule_ht / leader_ht;
							lr = rule_ht % leader_ht;
							if (subtype(p) == c_leaders) cur_v += (lr / 2);
							else {
								lx = lr / (lq + 1); cur_v += ((lr - (lq - 1)*lx) / 2);
							}
						}
						#pragma endregion
						while (cur_v + leader_ht <= edge)
							#pragma region <Output a leader box at cur_v, then advance cur_v by leader_ht+lx 637>
						{
							cur_h = left_edge + shift_amount(leader_box); synch_h; save_h = dvi_h;
							cur_v += height(leader_box); synch_v; save_v = dvi_v; temp_ptr = leader_box;
							outer_doing_leaders = doing_leaders; doing_leaders = true;
							if (type(leader_box) == vlist_node) vlist_out(); else hlist_out();
							doing_leaders = outer_doing_leaders; dvi_v = save_v; dvi_h = save_h; cur_h = left_edge;
							cur_v = save_v - height(leader_box) + leader_ht + lx;
						}
							#pragma endregion
					
						cur_v = edge - 10; goto next_p;
					}
				}
				#pragma endregion

				goto move_past;

				#pragma endregion
				break;
			case kern_node:
				cur_v += width(p);
				break;
			default:
				//do_nothing
				break;
			}
			goto next_p;

		fin_rule:
		#pragma region <Output a rule in a vlist, goto next_p 633>
			if (is_running(rule_wd)) rule_wd = width(this_box);
			rule_ht += rule_dp;
			cur_v += rule_ht;
			if (rule_ht > 0 && rule_wd > 0) {
				synch_h; synch_v; dvi_out(dvi_op::put_rule); dvi_four(rule_ht); dvi_four(rule_wd);
			}
			goto next_p;
		#pragma endregion

		move_past:
			cur_v += rule_ht;
		}
			#pragma endregion
	
		next_p:
			  p = link(p);
	}
		#pragma endregion

	prune_movements(save_loc);
	if (cur_s > 0) dvi_pop(save_loc);
	decr(cur_s);
}


// 638
void ship_out(pointer p)
{
	int page_loc;
	int j, k; // 0..9
	pool_pointer s;
	int old_setting; // 0..max_selector

	if (tracing_output > 0) {
		print_nl(TEX_STRING("")); print_ln(); print(TEX_STRING("Completed box being shipped out"));
	}
	if (term_offset > max_print_line - 9) print_ln();
	else if (term_offset > 0 || file_offset > 0) print_char(TEX_STRING(" "));
	print_char(TEX_STRING("[")); j = 9;
	while (count(j) == 0 && j > 0) decr(j);
	for (k = 0; k <= j; k++) {
		print_int(count(k));
		if (k < j) print_char(TEX_STRING("."));
	}
	update_terminal();
	if (tracing_output > 0) {
		print_char(TEX_STRING("]"));
		begin_diagnostic();
		show_box(p);
		end_diagnostic(true);
	}
	#pragma region <Ship box p out 640>

	#pragma region <Update the values of max_h and max_v; but if the page is too large, goto done 641>
	if (height(p) > max_dimen || depth(p) > max_dimen ||
		height(p) + depth(p) + v_offset > max_dimen || width(p) + h_offset > max_dimen) {
		print_err(TEX_STRING("Huge page cannot be shipped out"));
		help2(TEX_STRING("The page just created is more than 18 feet tall or"),
			TEX_STRING("more than 18 feet wide, so I suspect something went wrong."));
		error();
		if (tracing_output <= 0) {
			begin_diagnostic(); print_nl(TEX_STRING("The following box has been deleted:")); show_box(p);
			end_diagnostic(true);
		}
		goto done;
	}
	if (height(p) + depth(p) + v_offset > max_v) max_v = height(p) + depth(p) + v_offset;
	if (width(p) + h_offset > max_h) max_h = width(p) + h_offset;
	#pragma endregion

	#pragma region <Initialize variables as ship_out begins 617>
	dvi_h = 0; dvi_v = 0; cur_h = h_offset; dvi_f = null_font; ensure_dvi_open;
	if (total_pages == 0) {
		dvi_out(dvi_op::pre); dvi_out(id_byte);
		dvi_four(25400000); dvi_four(473628672);
		prepare_mag(); dvi_four(mag);
		old_setting = selector; selector = new_string; print(TEX_STRING(" TeX output ")); print_int(year);
		print_char(TEX_STRING(".")); print_two(month); print_char(TEX_STRING(".")); print_two(day); print_char(TEX_STRING(":"));
		print_two(_time / 60); print_two(_time % 60); selector = old_setting; dvi_out(cur_length);
		for (s = str_start[str_ptr]; s <= pool_ptr - 1; s++) dvi_out(so(str_pool[s]));
		pool_ptr = str_start[str_ptr];
	}
	#pragma endregion
	page_loc = dvi_offset + dvi_ptr; dvi_out(dvi_op::bop);
	for (k = 0; k <= 9; k++) dvi_four(count(k));
	dvi_four(last_bop); last_bop = page_loc; cur_v = height(p) + v_offset; temp_ptr = p;
	if (type(p) == vlist_node) vlist_out(); else hlist_out();
	dvi_out(dvi_op::eop); incr(total_pages); cur_s = -1;
done:

	#pragma endregion

	if (tracing_output <= 0) print_char(TEX_STRING("]"));
	dead_cycles = 0; update_terminal();
	#pragma region <Flush the box from memory, showing statistics if requested 639>
	//stat
#ifndef NO_STAT
	if (tracing_stats > 1) {
		print_nl(TEX_STRING("Memory usage before: ")); print_int(var_used); print_char(TEX_STRING("&"));
		print_int(dyn_used); print_char(TEX_STRING(";"));
	}
#endif
	//tats
	flush_node_list(p);
	//stat
#ifndef NO_STAT
	if (tracing_stats > 1) {
		print(TEX_STRING(" after: ")); print_int(var_used); print_char(TEX_STRING("&")); print_int(dyn_used);
		print(TEX_STRING("; still untouched: ")); print_int(hi_mem_min - lo_mem_max - 1); print_ln();
	}
#endif
	//tats
	#pragma endregion

}



// 1069
void extra_right_brace()
{
	print_err(TEX_STRING("Extra }, or forgotten "));
	switch (cur_group) {
	case semi_simple_group:
		print_esc(TEX_STRING("endgroup"));
		break;
	case math_shift_group:
		print_char(TEX_STRING("$"));
		break;
	case math_left_group:
		print_esc(TEX_STRING("right"));
		break;
		// NOTE: added default case here to prevent compiler warning
	default:
		break;
	}
	help5(TEX_STRING("I've deleted a group-closing symbol because it seems to be"),
		TEX_STRING("spurious, as in `$x}$'. But perhaps the } is legitimate and"),
		TEX_STRING("you forgot something else, as in `\hbox{$x}'. In such cases"),
		TEX_STRING("the way to recover is to insert both the forgotten and the"),
		TEX_STRING("deleted material, e.g., by typing `I$}'."));
	error();
}


// 668
pointer vpackage(pointer p, scaled h, small_number m, scaled l)
{
	pointer r;
	scaled w, d, x;
	scaled s;
	pointer g;
	glue_ord o;

	last_badness = 0; r = get_node(box_node_size); type(r) = vlist_node;
	subtype(r) = min_quarterword; shift_amount(r) = 0; list_ptr(r) = p;
	w = 0;
	#pragma region <Clear dimensions to zero 650>
	d = 0; x = 0; total_stretch[normal] = 0; total_shrink[normal] = 0; total_stretch[fil] = 0;
	total_shrink[fil] = 0; total_stretch[fill] = 0; total_shrink[fill] = 0; total_stretch[filll] = 0;
	total_shrink[filll] = 0;
	#pragma endregion

	while (p != 0) 
		#pragma region <Examine node p in the vlist, taking account of its effect on the dimensions of the new box; then advance p to the next node 669>
	{
		if (is_char_node(p)) confusion(TEX_STRING("vpack"));
		else
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
			case unset_node:
				#pragma region <Incorporate box dimensions into the dimensions of the vbox that will contain 670>
				x = x + d + height(p); d = depth(p);
				if (type(p) >= rule_node) s = 0;
				else
					s = shift_amount(p);
				if (width(p) + s > w) w = width(p) + s;
				#pragma endregion
				break;

			case whatsit_node:
				//<Incorporate a wahtsit node into a vbox 1359>
				// do_nothing

				break;

			case glue_node:
				#pragma region <Icorporate glue into the vertical totals 671>
				x = x + d; d = 0;
				g = glue_ptr(p); x = x + width(g);
				o = stretch_order(g); total_stretch[o] = total_stretch[o] + stretch(g); o = shrink_order(g);
				total_shrink[o] += shrink(g);
				if (subtype(p) >= a_leaders) {
					g = leader_ptr(p);
					if (width(g) > w) w = width(g);
				}
				#pragma endregion
				break;

			case kern_node:
				x = x + d + width(p); d = 0;
				break;

			default:
				break;
			}

		p = link(p);
	}
		#pragma endregion

	width(r) = w;
	if (d > l) {
		x = x + d - l; depth(r) = l;
	}
	else depth(r) = d;
	#pragma region <Determine the value of height(r) and the appropriate glue setting; then return or goto common_ending 672>
	if (m == additional) h = x + h;
	height(r) = h; x = h - x;
	if (x == 0) {
		glue_sign(r) = normal; glue_order(r) = normal; set_glue_ratio_zero(glue_set(r));
		goto _exit;
	}
	else if (x > 0) 
		#pragma region <Determine vertical glue stretch setting, then return or goto commond_ending 673>
	{
		#pragma region <Determine the stretch order 659>
		if (total_stretch[filll] != 0) o = filll;
		else if (total_stretch[fill] != 0) o = fill;
		else if (total_stretch[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion
		glue_order(r) = o; glue_sign(r) = stretching;
		if (total_stretch[o] != 0) glue_set(r) = unfloat(float(x) / total_stretch[o]);
		else {
			glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if(o == normal)
			if (list_ptr(r) != null) 
				#pragma region <Report an underfull vbox and goto common_ending, if this box is sufficiently bad 674>
			{
				last_badness = badness(x, total_stretch[normal]);
				if (last_badness > vbadness) {
					print_ln();
					if (last_badness > 100) print_nl(TEX_STRING("Underfull"));
					else print_nl(TEX_STRING("Loose"));
					print(TEX_STRING(" \vbox (badness ")); print_int(last_badness);
					goto common_ending;
				}
			}
				#pragma endregion
			
		goto _exit;
	}
		#pragma endregion
	else 
		#pragma region <Determine vertical glue shrink setting then return or goto common_ending 676>
	{
		#pragma region <Determine the shrink order 665>
		if (total_shrink[filll] != 0) o = filll;
		else if (total_shrink[fill] != 0) o = fill;
		else if (total_shrink[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion
		glue_order(r) = o; glue_sign(r) = shrinking;
		if (total_shrink[o] != 0) glue_set(r) = unfloat(float(-x) / total_shrink[o]);
		else {
			glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if (total_shrink[o] < -x && o == normal && list_ptr(r) != null) {
			last_badness = 1000000; set_glue_ratio_one(glue_set(r));

			#pragma region <Report an overfull vbox and goto common_ending, if this box is sufficiently bad 677>
			if (-x - total_shrink[normal] > vfuzz || vbadness < 100) {
				print_ln(); print_nl(TEX_STRING("Overfull \vbox (")); print_scaled(-x - total_shrink[normal]);
				print(TEX_STRING("pt too high")); goto common_ending;
			}
			#pragma endregion
		}
		else if(o == normal)
			if (list_ptr(r) != null) 
				#pragma region <Report a tight vbox and goto common_ending if this box is sufficienlty bad 678>
			{
				last_badness = badness(-x, total_shrink[normal]);
				if (last_badness > vbadness) {
					print_ln(); print_nl(TEX_STRING("Tight \vbox (badness "));
					print_int(last_badness);
					goto common_ending;
				}
			}
				#pragma endregion
			
		goto _exit;
	}
		#pragma endregion

	#pragma endregion

common_ending:

	#pragma region <Finish issuing a diagnostic message for an overfull or underfull vbox 675>
	if (output_active) print(TEX_STRING(") has occurred while \output is active"));
	else {
		if (pack_begin_line != 0) {
			print(TEX_STRING(") in alignment at lines ")); print_int(myabs(pack_begin_line));
			print(TEX_STRING("--"));
		}
		else print(TEX_STRING(") detected at line "));
		print_int(line); print_ln();
	}
	begin_diagnostic(); show_box(r); end_diagnostic(true);
	#pragma endregion

_exit:
	return r;
}

pointer vpack(halfword aa, scaled bb, small_number cc)
{
	return vpackage(aa, bb, cc, max_dimen);
}


// 645
void scan_spec(group_code c, bool three_codes)
{
	int s;
	unsigned char spec_code;
	if (three_codes)s = saved(0);
	if (scan_keyword(TEX_STRING("to"))) spec_code = exactly;
	else if (scan_keyword(TEX_STRING("spread"))) spec_code = additional;
	else {
		spec_code = additional; cur_val = 0; goto found;
	}
	scan_normal_dimen;
found:
	if (three_codes) {
		saved(0) = s; incr(save_ptr);
	}
	saved(0) = spec_code; saved(1) = cur_val; save_ptr += 2; new_save_level(c); scan_left_brace();
}


// 649
pointer hpack(pointer p, scaled w, small_number m)
{
	pointer r;
	pointer q;
	scaled h, d, x;
	scaled s;
	pointer g;
	glue_ord o;
	internal_font_number f;
	four_quarters i;
	eight_bits hd;

	last_badness = 0; r = get_node(box_node_size); type(r) = hlist_node;
	subtype(r) = min_quarterword; shift_amount(r) = 0; q = r + list_offset; link(q) = p;
	h = 0;
	#pragma region <Clear dimensions to zero 650>
	d = 0; x = 0; total_stretch[normal] = 0; total_shrink[normal] = 0; total_stretch[fil] = 0;
	total_shrink[fil] = 0; total_stretch[fill] = 0; total_shrink[fill] = 0; total_stretch[filll] = 0;
	total_shrink[filll] = 0;
	#pragma endregion

	while (p != null) 
		#pragma region <Examine node p in the hlist, taking account of its effect on the dimensions of the .. to the next node 651>
	{
	reswitch:
		while (is_char_node(p)) 
			#pragma region <Incorporate character dimensions into the dimensions of the hbox that will contain it, then move to the next node 654>
		{
			f = font(p); i = char_info(f, character(p)); hd = height_depth(i); x += char_width(f, i);
			s = char_height(f, hd); if (s > h) h = s;
			s = char_depth(f, hd); if (s > d) d = s;
			p = link(p);
		}
			#pragma endregion

		
		if (p != null) {
			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
			case unset_node:
				#pragma region <Incorporate box dimensions into the dimensions of the hbox that will contain it 653>
				x += width(p);
				if (type(p) >= rule_node) s = 0; else s = shift_amount(p);
				if (height(p) - s > h) h = height(p) - s;
				if (depth(p) + s > d) d = depth(p) + s;
				#pragma endregion
				break;
			case ins_node:
			case mark_node:
			case adjust_node:
				if (adjust_tail != null) 
					#pragma region <transfer node p to the adjustment list 655>
				{
					while (link(q) != p) q = link(q);
					if (type(p) == adjust_node) {
						link(adjust_tail) = adjust_ptr(p);
						while (link(adjust_tail) != null) adjust_tail = link(adjust_tail);
						p = link(p); free_node(link(q), small_node_size);
					}
					else {
						link(adjust_tail) = p; adjust_tail = p; p = link(p);
					}
					link(q) = p; p = q;
				}
					#pragma endregion
				break;
			case whatsit_node:
				//<Incorporate whatsit node into an hbox 1360>
				//do_nothing
				break;
			case glue_node:
				#pragma region <Incorporate glue into the horizontal totals 656>
				g = glue_ptr(p); x += width(g);
				o = stretch_order(g); total_stretch[o] += stretch(g); o = shrink_order(g);
				total_shrink[o] += shrink(g);
				if (subtype(p) >= a_leaders) {
					g = leader_ptr(p);
					if (height(g) > h) h = height(g);
					if (depth(g) > d) d = depth(g);
				}
				#pragma endregion
				break;
			case kern_node:
			case math_node:
				x += width(p);
				break;
			case ligature_node:
				#pragma region <Make node p look like a char_node and goto reswitch 652>
				mem[lig_trick] = mem[lig_char(p)]; link(lig_trick) = link(p); p = lig_trick;
				goto reswitch;
				#pragma endregion
				break;
			}
			p = link(p);
		}
	}
		#pragma endregion

	if (adjust_tail != null) link(adjust_tail) = null;
	height(r) = h; depth(r) = d;

	#pragma region <Determine the value of width(r)and the appropriate glue setting; then return or goto common_ending 657>
	if (m == additional) w += x;
	width(r) = w; x = w - x;
	if (x == 0) {
		glue_sign(r) = normal; glue_order(r) = normal; set_glue_ratio_zero(glue_set(r));
		goto _exit;
	}
	else if (x > 0) 
		#pragma region <Determine horizontal glue stretch setting, then return or goto common_ending 658>
	{
		#pragma region <Determine the stretch order 659>
		if (total_stretch[filll] != 0) o = filll;
		else if (total_stretch[fill] != 0) o = fill;
		else if (total_stretch[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion


		glue_order(r) = o; glue_sign(r) = stretching;
		if (total_stretch[o] != 0) glue_set(r) = unfloat(float(x) / total_stretch[o]);
		else { glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if(o==normal)
			if (list_ptr(r) != null)
				#pragma region <Report an underfull hbox and goto common_ending, if this box is sufficiently bad 660>
			{

				last_badness = badness(x, total_stretch[normal]);
				if (last_badness > hbadness) {
					print_ln();
					if (last_badness > 100) print_nl(TEX_STRING("Underfull")); 
					else print_nl(TEX_STRING("Loose"));
					print(TEX_STRING(" \hbox (badness ")); print_int(last_badness);
					goto common_ending;
				}
			}
				#pragma endregion
		goto _exit;
	}
		#pragma endregion
	else 
		#pragma region <Determine horizontal glue shrink setting, then return or goto common_ending 664>	
	{
		#pragma region <Determine the shrink order 665>
		if (total_shrink[filll] != 0) o = filll;
		else if (total_shrink[fill] != 0) o = fill;
		else if (total_shrink[fil] != 0) o = fil;
		else o = normal;
		#pragma endregion


		glue_order(r) = o; glue_sign(r) = shrinking;
		if (total_shrink[o] != 0) glue_set(r) = unfloat(float(-x) / total_shrink[o]);
		else { glue_sign(r) = normal; set_glue_ratio_zero(glue_set(r));
		}
		if (total_shrink[o] < -x && o == normal && list_ptr(r) != null) {
			last_badness = 1000000; set_glue_ratio_one(glue_set(r));
			#pragma region <Report and overfull hbox and goto common ending, if this box is sufficienlty bad 666>
			if (-x - total_shrink[normal] > hfuzz || hbadness < 100) {
				if (overfull_rule > 0 && -x - total_shrink[normal] > hfuzz) {
					while (link(q) != null) q = link(q);
					link(q) = new_rule(); width(link(q)) = overfull_rule;
				}
				print_ln(); print_nl(TEX_STRING("Overfull \hbox (")); print_scaled(-x - total_shrink[normal]);
				print(TEX_STRING("pt too wide"));
				goto common_ending;
			}
			#pragma endregion
		}
		else if(o==normal)
			if (list_ptr(r) != null) 
				#pragma region <Report a tight hbox and goto common_ending, if this box is suffiently bad 667>
			{
				last_badness = badness(-x, total_shrink[normal]);
				if (last_badness > hbadness) {
					print_ln();
					print_nl(TEX_STRING("Tight \hbox (badness ")); print_int(last_badness);
					goto common_ending;
				}
			}
				#pragma endregion

		goto _exit;
	}
		#pragma endregion


	#pragma endregion

common_ending:
	#pragma region <Finish issuing a diagnostic message for an overfull or underfull hbox 663>
	if (output_active) print(TEX_STRING(") has occurred while \output is active"));
	else {
		if (pack_begin_line != 0) {
			if (pack_begin_line > 0) print(TEX_STRING(") in paragraph at lines "));
			else print(TEX_STRING(") in alignment at lines "));
			print_int(myabs(pack_begin_line));
			print(TEX_STRING("--"));
		}
		else print(TEX_STRING(") detected at line "));
		print_int(line);
	}
	print_ln();
	font_in_short_display = null_font; short_display(list_ptr(r));
	print_ln();
	begin_diagnostic();
	show_box(r);
	end_diagnostic(true);
	#pragma endregion
	_exit:

	return r;
}

//829
void try_break(int pi, small_number break_type)
{
	pointer r;
	pointer prev_r;
	halfword old_l;
	bool no_break_yet;
	#pragma region <Other local variables for try_break 830>
	pointer prev_prev_r;
	pointer s;
	pointer q;
	pointer v;
	int t;
	internal_font_number f;
	halfword l;
	bool node_r_stays_active;
	scaled line_width;
	unsigned char fit_class; // very_loose_fit..tight_fit
	halfword b;
	int d;
	bool artificial_demerits;
	pointer save_link;
	scaled shortfall;
	#pragma endregion

	#pragma region <Make sure that pi is in the proper range 831>
	if (myabs(pi) >= inf_penalty)
		if (pi > 0) goto myexit;
		else pi = eject_penalty;
	#pragma endregion

	no_break_yet = true; prev_r = active; old_l = 0; do_all_six(copy_to_cur_active);
	while (1) {
	mycontinue:
		r = link(prev_r);
		#pragma region <If node r is of type delta_node ... 832>
		if (type(r) == delta_node) {
			do_all_six(update_width); prev_prev_r = prev_r; prev_r = r; goto mycontinue;
		}
		#pragma endregion
		
		#pragma region <If a line number class has ended, create new active nodes for the best feasible breaks in that class... 835>
		{
			l = line_number(r);
			if (l > old_l) {
				if (minimum_demerits < awful_bad && (old_l != easy_line || r == last_active))
					#pragma region <Create new active nodes for the best feasible breaks just found 836>
				{
					if (no_break_yet)
						#pragma region <Compute the values of break_width 837>
					{
						no_break_yet = false; do_all_six(set_break_width_to_background); s = cur_p;
						if(break_type > unhyphenated)
							if (cur_p != null)
								#pragma region <Compute the discretionary break_width values 840>
							{
								t = replace_count(cur_p); v = cur_p; s = post_break(cur_p);
								while (t > 0) {
									decr(t); v = link(v);
									#pragma region <Subtract the width of node v from break_width 841>
									if (is_char_node(v)) {
										f = font(v); break_width[1] -= char_width(f, char_info(f, character(v)));
									}
									else
										switch (type(v)) {
										case ligature_node:
											f = font(lig_char(v));
											break_width[1] -= char_width(f, char_info(f, character(lig_char(v))));
											break;
										case hlist_node:
										case vlist_node:
										case rule_node:
										case kern_node:
											break_width[1] -= width(v);
											break;
										default:
											confusion(TEX_STRING("disc1"));
											break;
										}
									#pragma endregion
								}
								while (s != null) {
									#pragma region <Add the width of node s to break_width 842>
									if (is_char_node(s)) {
										f = font(s); break_width[1] += char_width(f, char_info(f, character(s)));
									}
									else switch (type(s)) {
									case ligature_node:
										f = font(lig_char(s));
										break_width[1] += char_width(f, char_info(f, character(lig_char(s))));
										break;
									case hlist_node:
									case vlist_node:
									case rule_node:
									case kern_node:
										break_width[1] += width(s);
										break;
									default:
										confusion(TEX_STRING("disc2"));
										break;
									}
									#pragma endregion
									s = link(s);
								}
								break_width[1] += disc_width;
								if (post_break(cur_p) == null) s = link(v);
							}
								#pragma endregion
						while (s != null) {
							if (is_char_node(s)) goto done;
							switch (type(s)) {
							case glue_node:
								#pragma region <Subtract glue from break_width 838>
								v = glue_ptr(s); break_width[1] -= width(v);
								break_width[2 + stretch_order(v)] -= stretch(v);
								break_width[6] -= shrink(v);
								#pragma endregion
								break;
							case penalty_node:
								//do_nothing
								break;
							case math_node:
								break_width[1] -= width(s);
								break;
							case kern_node:
								if (subtype(s) != _explicit) goto done;
								else break_width[1] -= width(s);
								break;
							default:
								goto done;
								break;
							}
							s = link(s);
						}
					done:
						;
					}
						#pragma endregion

					#pragma region <Insert a delta node to prepare for breaks at cur_p 843>
					if (type(prev_r) == delta_node) {
						do_all_six(convert_to_break_width);
					}
					else if (prev_r == active) {
						do_all_six(store_break_width);
					}
					else {
						q = get_node(delta_node_size); link(q) = r; type(q) = delta_node;
						subtype(q) = 0;
						do_all_six(new_delta_to_break_width); link(prev_r) = q; prev_prev_r = prev_r; prev_r = q;
					}
					#pragma endregion

					if (myabs(adj_demerits) >= awful_bad - minimum_demerits) minimum_demerits = awful_bad - 1;
					else minimum_demerits += myabs(adj_demerits);
					for (fit_class = very_loose_fit; fit_class <= tight_fit; fit_class++) {
						if (minimal_demerits[fit_class] <= minimum_demerits)
							#pragma region <Insert a new active node from best_place[fit_class] to cur_p 845>
						{
							q = get_node(passive_node_size); link(q) = passive; passive = q; cur_break(q) = cur_p;
							//stat
#ifndef NO_STAT
							incr(pass_number); serial(q) = pass_number;
#endif
							//tats
							prev_break(q) = best_place[fit_class];
							q = get_node(active_node_size); break_node(q) = passive; line_number(q) = best_pl_line[fit_class] + 1;
							fitness(q) = fit_class;  type(q) = break_type; total_demerits(q) = minimal_demerits[fit_class];
							link(q) = r; link(prev_r) = q; prev_r = q;
							//stat
#ifndef NO_STAT							
							if (tracing_paragraphs > 0)
								#pragma region <Print symbolic description of the new break node 846>
							{
								print_nl(TEX_STRING("@@")); print_int(serial(passive));
								print(TEX_STRING(": line ")); print_int(line_number(q) - 1);
								print_char(TEX_STRING(".")); print_int(fit_class);
								if (break_type == hyphenated) print_char(TEX_STRING("-"));
								print(TEX_STRING(" t=")); print_int(total_demerits(q));
								print(TEX_STRING(" -> @@"));
								if (prev_break(passive) == null) print_char(TEX_STRING("0"));
								else print_int(serial(prev_break(passive)));
							}
								#pragma endregion
#endif
							//tats
						}
						#pragma endregion
						minimal_demerits[fit_class] = awful_bad;
					}
					minimum_demerits = awful_bad;
					#pragma region <Insert a delta node to prepare for the next active node 844>
					if (r != last_active) {
						q = get_node(delta_node_size); link(q) = r; type(q) = delta_node;
						subtype(q) = 0;
						do_all_six(new_delta_from_break_width); link(prev_r) = q; prev_prev_r = prev_r; prev_r = q;
					}
					#pragma endregion

				}
				#pragma endregion
				if (r == last_active) goto myexit;
				#pragma region <Compute the new line width 850>
				if (l > easy_line) {
					line_width = second_width; old_l = max_halfword - 1;
				}
				else {
					old_l = l;
					if (l > last_special_line) line_width = second_width;
					else if (par_shape_ptr == null) line_width = first_width;
					else line_width = mem[par_shape_ptr + 2 * l].sc;
				}
				#pragma endregion
			}
		}
		#pragma endregion

		#pragma region <Consider demerits for a line from r to cur_p ... 851>
		{
			artificial_demerits = false;
			shortfall = line_width - cur_active_width[1];
			if (shortfall > 0)
				#pragma region <Set the value of b to the badness for stretching the line.. 852>
				if (cur_active_width[3] != 0 || cur_active_width[4] != 0 || cur_active_width[5] != 0) {
					b = 0; fit_class = decent_fit;
				}
				else {
					if(shortfall>7230584)
						if (cur_active_width[2] < 1663497) {
							b = inf_bad; fit_class = very_loose_fit; goto done1;
						}
					b = badness(shortfall, cur_active_width[2]);
					if (b > 12)
						if (b > 99) fit_class = very_loose_fit;
						else fit_class = loose_fit;
					else fit_class = decent_fit;
				done1:
					;
				}
				#pragma endregion
			else
				#pragma region <Set the value of b to the badness for shrinking the line.. 853>
			{
				if (-shortfall > cur_active_width[6]) b = inf_bad + 1;
				else b = badness(-shortfall, cur_active_width[6]);
				if (b > 12) fit_class = tight_fit; else fit_class = decent_fit;
			}
				#pragma endregion
			if (b > inf_bad || pi == eject_penalty)
				#pragma region <Prepare to deactivate node r, and goto deactivate.. 854>
			{
				if (final_pass && minimum_demerits == awful_bad && link(r) == last_active && prev_r == active)
					artificial_demerits = true;
				else if (b > threshold) goto deactivate;
				node_r_stays_active = false;
			}
				#pragma endregion
			else {
				prev_r = r;
				if (b > threshold) goto mycontinue;
				node_r_stays_active = true;
			}
			#pragma region <Record a new feasible break 855>
			if (artificial_demerits) d = 0;
			else
				#pragma region <Compute the demerits, d, from r to cur_p 859>
			{
				d = line_penalty + b;
				if (myabs(d) >= 10000) d = 100000000; else d = d * d;
				if (pi != 0)
					if (pi > 0) d = d + pi * pi;
					else if (pi > eject_penalty) d = d - pi * pi;
				if (break_type == hyphenated && type(r) == hyphenated)
					if (cur_p != null) d = d + double_hyphen_demerits;
					else d = d + final_hyphen_demerits;
				if (myabs(fit_class - fitness(r)) > 1) d = d + adj_demerits;
			}
				#pragma endregion
			//stat
#ifndef NO_STAT
			if (tracing_paragraphs > 0)
				#pragma region <Print a symbolic description of this feasible break 856>
			{
				if (printed_node != cur_p)
					#pragma region <Print the list between printed_node and cur_p, then set printed_node = cur_p 857>
				{
					print_nl(TEX_STRING(""));
					if (cur_p == null) short_display(link(printed_node));
					else {
						save_link = link(cur_p); link(cur_p) = null; print_nl(TEX_STRING(""));
						short_display(link(printed_node)); link(cur_p) = save_link;
					}
					printed_node = cur_p;
				}
					#pragma endregion
				print_nl(TEX_STRING("@"));
				if (cur_p == null) print_esc(TEX_STRING("par"));
				else if (type(cur_p) != glue_node) {
					if (type(cur_p) == penalty_node) print_esc(TEX_STRING("penalty"));
					else if (type(cur_p) == disc_node) print_esc(TEX_STRING("discretionary"));
					else if (type(cur_p) == kern_node) print_esc(TEX_STRING("kern"));
					else print_esc(TEX_STRING("math"));
				}
				print(TEX_STRING(" via @@"));
				if (break_node(r) == null) print_char(TEX_STRING("0"));
				else print_int(serial(break_node(r)));
				print(TEX_STRING(" b="));
				if (b > inf_bad) print_char(TEX_STRING("*")); else print_int(b);
				print(TEX_STRING(" p=")); print_int(pi); 
				print(TEX_STRING(" d="));
				if (artificial_demerits) print_char(TEX_STRING("*")); else print_int(d);
			}
				#pragma endregion
#endif
			//tats
			d += total_demerits(r);
			if (d <= minimal_demerits[fit_class]) {
				minimal_demerits[fit_class] = d; best_place[fit_class] = break_node(r); best_pl_line[fit_class] = l;
				if (d < minimum_demerits) minimum_demerits = d;
			}
			#pragma endregion
			if (node_r_stays_active) goto mycontinue;
	deactivate:
			#pragma region <Deactivate node r 860>
			link(prev_r) = link(r); free_node(r, active_node_size);
			if (prev_r == active)
				#pragma region <Update the active widths, since the first active node has been deleted 861>
			{
				r = link(active);
				if (type(r) == delta_node) {
					do_all_six(update_active); do_all_six(copy_to_cur_active); link(active) = link(r);
					free_node(r, delta_node_size);
				}
			}
				#pragma endregion
			else if (type(prev_r) == delta_node) {
				r = link(prev_r);
				if (r == last_active) {
					do_all_six(downdate_width); link(prev_prev_r) = last_active;
					free_node(prev_r, delta_node_size); prev_r = prev_prev_r;
				}
				else if (type(r) == delta_node) {
					do_all_six(update_width); do_all_six(combine_two_deltas); link(prev_r) = link(r);
					free_node(r, delta_node_size);
				}
			}
			#pragma endregion
		}
		#pragma endregion
	}

myexit:
	; // need empty statement here if compiling without stat
	//stat
#ifndef NO_STAT
	#pragma region <Update the value of printed_node for symbolic displays 858>
	if (cur_p == printed_node)
		if (cur_p != null)
			if (type(cur_p) == disc_node) {
				t = replace_count(cur_p);
				while (t > 0) {
					decr(t); printed_node = link(printed_node);
				}
			}
	#pragma endregion
#endif
	//tats
}


// 1075
void box_end(int box_context)
{
	pointer p;
	if (box_context < box_flag) 
		#pragma region <Append box cur_box to the current list, shifted by box_context 1076>
	{
		if (cur_box != null) {
			shift_amount(cur_box) = box_context;
			if (myabs(mode) == vmode) {
				append_to_vlist(cur_box);
				if (adjust_tail != null) {
					if (adjust_head != adjust_tail) {
						link(tail) = link(adjust_head); tail = adjust_tail;
					}
					adjust_tail = null;
				}
				if (mode > 0) build_page();
			}
			else {
				if (myabs(mode) == hmode) space_factor = 1000;
				else {
					p = new_noad(); math_type(nucleus(p)) = sub_box; info(nucleus(p)) = cur_box;
					cur_box = p;
				}
				link(tail) = cur_box; tail = cur_box;
			}
		}
	}
		#pragma endregion
	else if (box_context < ship_out_flag) 
		#pragma region <Store cur_box in a box register 1077>
	{
		if (box_context < box_flag + 256) eq_define(box_base - box_flag + box_context, box_ref, cur_box);
		else geq_define(box_base - box_flag - 256 + box_context, box_ref, cur_box);
	}
		#pragma endregion
	else if(cur_box != null)
		if (box_context > ship_out_flag) 
			#pragma region <Append a new leader node that uses cur_box 1078>
		{
			#pragma region <Get the next non-blank non-relax non-call token 404>
			do
			{
				get_x_token();
			} while (!(cur_cmd != spacer && cur_cmd != relax));
			#pragma endregion
			if ((cur_cmd == hskip && myabs(mode) != vmode) || (cur_cmd == vskip && myabs(mode) == vmode)) {
				append_glue(); subtype(tail) = box_context - (leader_flag - a_leaders);
				leader_ptr(tail) = cur_box;
			}
			else {
				print_err(TEX_STRING("Leaders not followed by proper glue"));
				help3(TEX_STRING("You should say `\leaders <box or rule><hskip or vskip>'."),
					TEX_STRING("I found the <box or rule>, but there's no suitable"),
					TEX_STRING("<hskip or vskip>, so I'm ignoring these leaders."));
				back_error();
				flush_node_list(cur_box);
			}
		}
			#pragma endregion
		else ship_out(cur_box);
}


// 1086
void package(small_number c)
{
	scaled h;
	pointer p;
	scaled d;

	d = box_max_depth; unsave(); save_ptr = save_ptr - 3;
	if (mode == -hmode) cur_box = hpack(link(head), saved(2), saved(1));
	else {
		cur_box = vpackage(link(head), saved(2), saved(1), d);
		if (c == vtop_code) 
			#pragma region <Readjust the height and depth of cur_box for vtop 1087>
		{
			h = 0; p = list_ptr(cur_box);
			if (p != null)
				if (type(p) <= rule_node) h = height(p);
			depth(cur_box) = depth(cur_box) - h + height(cur_box); height(cur_box) = h;
		}
			#pragma endregion
	}
	pop_nest();
	box_end(saved(0));
}


// 597
void write_dvi(dvi_index a, dvi_index b)
{
	dvi_index k;
	for (k = a; k <= b;k++)
		fputc(dvi_buf[k], dvi_file);
}


// 598
void dvi_swap()
{
	if (dvi_limit == dvi_buf_size) {
		write_dvi(0, half_buf - 1); dvi_limit = half_buf; dvi_offset += dvi_buf_size;
		dvi_ptr = 0;
	}
	else {
		write_dvi(half_buf, dvi_buf_size - 1); dvi_limit = dvi_buf_size;
	}
	dvi_gone += half_buf;
}

// 600
void dvi_four(int x)
{
	if (x >= 0)
		dvi_out(x / 0100000000);
	else {
		x += 010000000000;
		x += 010000000000;
		dvi_out((x / 0100000000) + 128);
	}
	x %= 0100000000; dvi_out(x / 0200000); x %= 0200000; dvi_out(x / 0400);
	dvi_out(x % 0400);
}

// 601
void dvi_pop(int l)
{
	if (l == dvi_offset + dvi_ptr && dvi_ptr > 0)
		decr(dvi_ptr);
	else
		dvi_out(dvi_op::pop);
}

// 602
void dvi_font_def(internal_font_number f)
{
	pool_pointer k;
	dvi_out(dvi_op::fnt_def1); dvi_out(f - font_base - 1);
	dvi_out(qo(font_check[f].b0)); dvi_out(qo(font_check[f].b1)); dvi_out(qo(font_check[f].b2));
	dvi_out(qo(font_check[f].b3));
	dvi_four(font_size[f]); dvi_four(font_dsize[f]);
	dvi_out(length(font_area[f])); dvi_out(length(font_name[f]));
	#pragma region <Output the font name whose internal number is f 603>
	for (k = str_start[font_area[f]]; k <= str_start[font_area[f] + 1] - 1; k++)
		dvi_out(so(str_pool[k]));
	for (k = str_start[font_name[f]]; k <= str_start[font_name[f] + 1] - 1; k++)
		dvi_out(so(str_pool[k]));
	#pragma endregion
}


// 1333
void close_files_and_terminate()
{
	int k;
	#pragma region <finish the extensions 1378>
	for (k = 0; k < 16; k++) {
		if (write_open[k])
			a_close(write_file[k]);
	}
	#pragma endregion

	if (tracing_stats > 0)
		#pragma region <Output statistics about this job 1334>
		if (log_opened) {
			wlog_ln_s(" "); wlog_ln_s("Here is how much of TeX\'s memory you used:");
			{
				std::stringstream oss;
				oss << " " << str_ptr - init_str_ptr << " string";
				wlog_s(oss.str().c_str());
				if (str_ptr != init_str_ptr + 1) {
					wlog_s("s");
				}
			}
			{
				std::stringstream oss;
				oss << " out of " << max_strings - init_str_ptr;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << pool_ptr - init_pool_ptr << " string characters out of " << pool_size - init_pool_ptr;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << lo_mem_max - mem_min + mem_end - hi_mem_min + 2 << " words of memory out of ";
				oss << mem_end + 1 - mem_min;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << cs_count << " multiletter control sequences out of " << hash_size;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << fmem_ptr << " words of font info for " << font_ptr - font_base << " font";
				wlog_s(oss.str().c_str());
			}
			if (font_ptr != font_base + 1)
				wlog_s("s");
			{
				std::stringstream oss;
				oss << ", out of " << font_mem_size << " for " << font_max - font_base;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << hyph_count << " hyphenation exception";
				wlog_s(oss.str().c_str());
			}
			if (hyph_count != 1)
				wlog_s("s");
			{
				std::stringstream oss;
				oss << " out of " << hyph_size;
				wlog_ln_s(oss.str().c_str());
			}
			{
				std::stringstream oss;
				oss << " " << max_in_stack << "i," << max_nest_stack << "n," << max_param_stack << "p," <<
					max_buf_stack + 1 << "b," << max_save_stack + 6 << "s stack positions out of " <<
					stack_size << "i," << nest_size << "n," << param_size << "p," << buf_size << "b," << save_size << "s";
				wlog_ln_s(oss.str().c_str());
			}
		}
		#pragma endregion

	wake_up_terminal();
	
	#pragma region <Finish the DVI file 642>
	while (cur_s > -1) {
		if (cur_s > 0)
			dvi_out(dvi_op::pop);
		else {
			dvi_out(dvi_op::eop); incr(total_pages);
		}
		decr(cur_s);
	}
	if (total_pages == 0)
		print_nl(TEX_STRING("No pages of output."));
	else {
		dvi_out(dvi_op::post);
		dvi_four(last_bop); last_bop = dvi_offset + dvi_ptr - 5;
		dvi_four(25400000); dvi_four(473628672);
		prepare_mag(); dvi_four(mag);
		dvi_four(max_v); dvi_four(max_h);
		dvi_out(max_push / 256); dvi_out(max_push % 256);
		dvi_out((total_pages / 256) % 256); dvi_out(total_pages % 256);

		#pragma region <Output the font definitions for all fonts that were used 643
		while (font_ptr > font_base) {
			if (font_used[font_ptr])
				dvi_font_def(font_ptr);
			decr(font_ptr);
		}
		#pragma endregion

		dvi_out(dvi_op::post_post); dvi_four(last_bop); dvi_out(id_byte);
		k = 4 + ((dvi_buf_size - dvi_ptr) % 4);
		while (k > 0) {
			dvi_out(223);
			decr(k);
		}

		#pragma region <Empty the last bytes out of dvi_buf 599>
		if (dvi_limit == half_buf)
			write_dvi(half_buf, dvi_buf_size - 1);
		if (dvi_ptr > 0)
			write_dvi(0, dvi_ptr - 1);
		#pragma endregion

		print_nl(TEX_STRING("Output written on ")); slow_print(output_file_name);
		print(TEX_STRING(" (")); print_int(total_pages);
		print(TEX_STRING(" page"));
		if (total_pages != 1)
			print_char(TEX_STRING("s"));
		print(TEX_STRING(", ")); print_int(dvi_offset + dvi_ptr);
		print(TEX_STRING(" bytes).")); b_close(dvi_file);

	}
	#pragma endregion

	if (log_opened) {
		wlog_cr;
		a_close(log_file);
		selector -= 2;
		if (selector == term_only) {
			print_nl(TEX_STRING("Transcript written on "));
			slow_print(log_name);
			print_char('.');
		}
	}
	print_ln();
	if(ed_name_start != 0 && interaction > batch_mode)
		call_edit(&str_pool[ed_name_start], ed_name_length, edit_line);
}

//////////////////////////////////////////////////////////////////////////////
// Windows specific routine to open editor
//
void call_edit(packed_ASCII_code *filename, int fnlength, int linenumber)
{
	char *temp;
	char *command;
	char c;
	int sdone;
	int ddone;
	int i;
	
	char dvalue[] = "start \"\" \"C:\\Program Files (x86)\\Notepad++\\notepad++\" -n%d %s";
	char *texeditvalue = dvalue;
	sdone = ddone = 0;
	
	if(NULL != (temp = getenv("TEXEDIT")))
		texeditvalue = temp;
	
	if (NULL == (command = (char*)malloc(strlen(texeditvalue) + fnlength + 25))) {
		fprintf(stderr, "! Not enough memory to issue editor command\n");
		exit(1);
	}
	temp = command;
	while ((c = *texeditvalue++) != 0) {
		if (c == '%') {
			switch (c = *texeditvalue++) {
				case 'd':
					if(ddone) {
						fprintf(stderr, "! Line number cannot appear twice in editor command\n");
						exit(1);
					}
					sprintf(temp, "%d", linenumber);
					while (*temp != 0)
						temp++;
					ddone = 1;
					break;
				case 's':
					if (sdone) {
						fprintf(stderr, "! Filename cannot appear twice in editor command\n");
						exit(1);
					}
					i = 0;
					while (i < fnlength)
						*temp++ = filename[i++];
					sdone = 1;
					break;
				case 0:
					*temp++ = '%';
					texeditvalue--; // Back up to \0 to force termination
					break;
				default:
					*temp++ = '%';
					*temp++ = c;
					break;					
			}
		}
		else
			*temp++ = c;
	}
	*temp = 0;
	
	if (0 != system(command))
		fprintf(stderr, "! Trouble executing command %s\n", command);
	
	
	exit(1);
}

//////////////////////////////////////////////////////////////////////////////

// 292
void show_token_list(int p, int q, int l)
{
	int m, c;
	ASCII_code match_chr;
	ASCII_code n;
	match_chr = TEX_STRING("#");
	n = TEX_STRING("0");
	tally = 0;
	while (p != null && tally < l) {
		if (p == q)
			#pragma region <Do magic computation 320>
			set_trick_count;
			#pragma endregion

		#pragma region <Display token p, and return if there are problems 293>
		if (p < hi_mem_min || p > mem_end) {
			print_esc(TEX_STRING("CLOBBERED."));
			return;
		}
		if (info(p) >= cs_token_flag)
			print_cs(info(p) - cs_token_flag);
		else {
			m = info(p) / 0400; c = info(p) % 0400;
			if (info(p) < 0)
				print_esc(TEX_STRING("BAD."));
			else
				#pragma region <Display the token (m,c) 294>
				switch (m) {
					case left_brace:
					case right_brace:
					case math_shift:
					case tab_mark:
					case sup_mark:
					case sub_mark:
					case spacer:
					case letter:
					case other_char:
						print(c);
						break;
					case mac_param:
						print(c); print(c);
						break;
					case out_param:
						print(match_chr);
						if (c <= 9)
							print_char(c + TEX_STRING("0"));
						else {
							print_char(TEX_STRING("!"));
							return;
						}
						break;
					case match:
						match_chr = c;
						print(c);
						incr(n);
						print_char(n);
						if (n > TEX_STRING("9"))
							return;
						break;
					case end_match:
						print(TEX_STRING("->"));
						break;
					default:
						print_esc(TEX_STRING("BAD."));
						break;
				}
				#pragma endregion
		}
		#pragma endregion
		p = link(p);
	}
	if (p != null)
		print_esc(TEX_STRING("ETC."));
}

// 295
void token_show(pointer p)
{
	if (p != null)
		show_token_list(link(p), null, 10000000);
}

// 934
void new_hyph_exceptions()
{
	unsigned char n;
	unsigned char j;
	hyph_pointer h;
	str_number k;
	pointer p;
	pointer q;
	str_number s, t;
	pool_pointer u, v;

	scan_left_brace();
	set_cur_lang;
	#pragma region <Enter as many hyphenation exceptions as are listed, until coming to a right brace; then return 935>
	n = 0; p = null;
	while (1) {
		get_x_token();
	reswitch:
		switch (cur_cmd) {
		case letter:
		case other_char:
		case char_given:
			#pragma region <Append a new letter or hyphen 937>
			if (cur_chr == TEX_STRING("-"))
				#pragma region <Append the value n to list p 938>
			{
				if (n < 63) {
					q = get_avail(); link(q) = p; info(q) = n; p = q;
				}
			}
				#pragma endregion
			else {
				if (lc_code(cur_chr) == 0) {
					print_err(TEX_STRING("Not a letter"));
					help2(TEX_STRING("Letters in \hyphenation words must have \lccode>0."),
						TEX_STRING("Proceed; I'll ignore the character I just read."));
					error();
				}
				else if (n < 63) {
					incr(n); hc[n] = lc_code(cur_chr);
				}
			}
			#pragma endregion
			break;
		case char_num:
			scan_char_num(); cur_chr = cur_val; cur_cmd = char_given; goto reswitch;
			break;

		case spacer:
		case right_brace:
			if (n > 1)
				#pragma region <Enter a hyphenation exception 939>
			{
				incr(n); hc[n] = cur_lang; str_room(n); h = 0;
				for (j = 1; j <= n; j++) {
					h = (h + h + hc[j]) % hyph_size; append_char(hc[j]);
				}
				s = make_string();
				#pragma region <Insert the pair (s,p) into the exception table 940>
				if (hyph_count == hyph_size) overflow(TEX_STRING("exception dictionary"), hyph_size);
				incr(hyph_count);
				while (hyph_word[h] != 0) {
					#pragma region <If the string hyph_word[h] is less than or equal to s, interchange .. 941>
					k = hyph_word[h];
					if (length(k) < length(s)) goto found;
					if (length(k) > length(s)) goto not_found;
					u = str_start[k]; v = str_start[s];
					do {
						if (str_pool[u] < str_pool[v]) goto found;
						if (str_pool[u] > str_pool[v]) goto not_found;
						incr(u); incr(v);
					} while (!(u == str_start[k + 1]));
				found:
					q = hyph_list[h]; hyph_list[h] = p; p = q;
					t = hyph_word[h]; hyph_word[h] = s; s = t;
				not_found:

				#pragma endregion
					if (h > 0) decr(h); else h = hyph_size;
				}
				hyph_word[h] = s; hyph_list[h] = p;
				#pragma endregion
			}
				#pragma endregion
			if (cur_cmd == right_brace) return;
			n = 0; p = null;
			break;

		default:
			#pragma region <Give improper hyphenation error 936>
			print_err(TEX_STRING("Improper "));
			print_esc(TEX_STRING("hyphenation"));
			print(TEX_STRING(" will be flushed"));
			help2(TEX_STRING("Hyphenation exceptions must contain only letters"),
				TEX_STRING("and hyphens. But continue; I'll forgive and forget."));
			error();
			#pragma endregion
			break;
		}
	}
	#pragma endregion
}

//987
void freeze_page_specs(small_number s)
{
	page_contents = s; page_goal = vsize; page_max_depth = max_depth;
	page_depth = 0;
	do_all_six(set_page_so_far_zero); least_page_cost = awful_bad;
	//stat
#ifndef NO_STAT
	if (tracing_pages > 0) {
		begin_diagnostic();
		print_nl(TEX_STRING("%% goal height=")); print_scaled(page_goal);
		print(TEX_STRING(", max depth=")); print_scaled(page_max_depth);
		end_diagnostic(false);
	}
#endif
	//tats
}

// 992
void box_error(eight_bits n)
{
	error();
	begin_diagnostic();
	print_nl(TEX_STRING("The following box has been deleted:"));
	show_box(box(n));
	end_diagnostic(true);
	flush_node_list(box(n));
	box(n) = null;
}

// 993
void ensure_vbox(eight_bits n)
{
	pointer p;

	p = box(n);
	if(p!=null)
		if (type(p) == hlist_node) {
			print_err(TEX_STRING("Insertions can only be added to a vbox"));
			help3(TEX_STRING("Tut tut: You're trying to \insert into a"),
				TEX_STRING("\box register that now contains an \hbox."),
				TEX_STRING("Proceed, and I'll discard its present contents."));
			box_error(n);
		}
}

// 994
void build_page()
{
	pointer p;
	pointer q, r;
	int b, c;
	int pi;
	unsigned char n;
	scaled delta, h, w;

	if (link(contrib_head) == null || output_active)
		return;
	do {
	my_continue:
		p = link(contrib_head);
		#pragma region <Update the values of last_glue, last_penalty, and last_kern 996>
		if (last_glue != max_halfword)
			delete_glue_ref(last_glue);
		last_penalty = 0; last_kern = 0;
		if (type(p) == glue_node) {
			last_glue = glue_ptr(p); add_glue_ref(last_glue);
		}
		else {
			last_glue = max_halfword;
			if (type(p) == penalty_node)
				last_penalty = penalty(p);
			else if (type(p) == kern_node)
				last_kern = width(p);
		}
		#pragma endregion

		#pragma region <Move node p to the current page; if it is time for a page break, .. 997>

		#pragma region <If the current page is empty and ndoe p is to be deleted... 1000>

		switch (type(p)) {
		case hlist_node:
		case vlist_node:
		case rule_node:
			if (page_contents < box_there) 
				#pragma region <Initialize the current page, insert the topskip glue ahead of p and goto continue 1001>
			{
				if (page_contents == empty)
					freeze_page_specs(box_there);
				else
					page_contents = box_there;
				q = new_skip_param(top_skip_code);
				if (width(temp_ptr) > height(p))
					width(temp_ptr) -= height(p);
				else width(temp_ptr) = 0;
				link(q) = p; link(contrib_head) = q;
				goto my_continue;

			}
				#pragma endregion
			else
				#pragma region <Prepare to move a box or rule node to the current page then goto contribute 1002>
			{
				page_total += page_depth + height(p);
				page_depth = depth(p);
				goto contribute;
			}
				#pragma endregion
			break;
		case whatsit_node:
			//<Prepare to move whatsit p to the current page, then goto contribute 1364>
			goto contribute;
			break;

		case glue_node:
			if (page_contents < box_there)
				goto done1;
			else if (precedes_break(page_tail))
				pi = 0;
			else goto update_heights;
			break;

		case kern_node:
			if (page_contents < box_there)
				goto done1;
			else if (link(p) == null)
				return;
			else if (type(link(p)) == glue_node)
				pi = 0;
			else goto update_heights;
			break;
		case penalty_node:
			if (page_contents < box_there)
				goto done1;
			else pi = penalty(p);
			break;
		case mark_node:
			goto contribute;
			break;
		case ins_node:
			#pragma region <Append an insertion to the current page and goto contribute 1008>
			if (page_contents == empty)
				freeze_page_specs(inserts_only);
			n = subtype(p); r = page_ins_head;
			while (n >= subtype(link(r))) r = link(r);

			n = qo(n);
			if (subtype(r) != qi(n)) 
				#pragma region <Create a page insertion node with subtype(r) = qi(n), and include the correction for box n in the current page state 1009>
			{
				q = get_node(page_ins_node_size);
				link(q) = link(r); link(r) = q; r = q; subtype(r) = qi(n);
				type(r) = inserting; ensure_vbox(n);
				if (box(n) == null)
					height(r) = 0;
				else height(r) = height(box(n)) + depth(box(n));
				best_ins_ptr(r) = null;
				q = skip(n);
				if (count(n) == 1000)
					h = height(r);
				else h = x_over_n(height(r), 1000)*count(n);
				page_goal -= h + width(q);
				page_so_far[2 + stretch_order(q)] += stretch(q);
				page_shrink += shrink(q);
				if (shrink_order(q) != normal && shrink(q) != 0) {
					print_err(TEX_STRING("Infinite glue shrinkage inserted from "));
					print_esc(TEX_STRING("skip"));
					print_int(n);
					help3(TEX_STRING("The correction glue for page breaking with insertions"),
						TEX_STRING("must have finite shrinkability. But you may proceed,"),
						TEX_STRING("since the offensive shrinkability has been made finite."));
					error();
				}
			}
				#pragma endregion
			if (type(r) == split_up)
				insert_penalties += float_cost(p);
			else {
				last_ins_ptr(r) = p; delta = page_goal - page_total - page_depth + page_shrink;
				if (count(n) == 1000)
					h = height(p);
				else
					h = x_over_n(height(p), 1000)*count(n);
				if ((h <= 0 || h <= delta) && height(p) + height(r) <= dimen(n)) {
					page_goal -= h; height(r) += height(p);
				}
				else
					#pragma region <Find the best way to split the insertion and change type(r) to split_up 1010>
				{
					if (count(n) <= 0)
						w = max_dimen;
					else {
						w = page_goal - page_total - page_depth;
						if (count(n) != 1000)
							w = x_over_n(w, count(n)) * 1000;
					}
					if (w > dimen(n) - height(r))
						w = dimen(n) - height(r);
					q = vert_break(ins_ptr(p), w, depth(p)); height(r) += best_height_plus_depth;
					//stat
#ifndef NO_STAT
					if (tracing_pages > 0)
						#pragma region <Display the insertion split cost 1011>
					{
						
						begin_diagnostic(); print_nl(TEX_STRING("% split"));
						print_int(n); print(TEX_STRING(" to ")); print_scaled(w);
						print_char(TEX_STRING(",")); print_scaled(best_height_plus_depth);
						print(TEX_STRING(" p="));
						if (q == null) print_int(eject_penalty);
						else if (type(q) == penalty_node) print_int(penalty(q));
						else print_char(TEX_STRING("0"));
						end_diagnostic(false);
					}
						#pragma endregion
#endif
					//tats
					if (count(n) != 1000)
						best_height_plus_depth = x_over_n(best_height_plus_depth, 1000)*count(n);
					page_goal -= best_height_plus_depth; type(r) = split_up; broken_ptr(r) = q;
					broken_ins(r) = p;
					if (q == null)
						insert_penalties += eject_penalty;
					else if (type(q) == penalty_node)
						insert_penalties += penalty(q);
				}
					#pragma endregion
			}
			goto contribute;
			#pragma endregion
			break;

		default:
			confusion(TEX_STRING("page"));
			break;
		}
		#pragma endregion

		#pragma region <Check if node p is a new champion breakpont; then ... 1005>

		if (pi < inf_penalty) {
			#pragma region <Compute the badness b of the current page using awful_bad if the box is too full 1007>

			if (page_total < page_goal) {
				if (page_so_far[3] != 0 || page_so_far[4] != 0 || page_so_far[5] != 0)
					b = 0;
				else
					b = badness(page_goal - page_total, page_so_far[2]);
			}
			else if (page_total - page_goal > page_shrink)
				b = awful_bad;
			else
				b = badness(page_total - page_goal, page_shrink);
			#pragma endregion

			if (b < awful_bad) {
				if (pi <= eject_penalty)
					c = pi;
				else if (b < inf_bad)
					c = b + pi + insert_penalties;
				else
					c = deplorable;
			}
			else
				c = b;
			if (insert_penalties >= 10000)
				c = awful_bad;
			//stat
#ifndef NO_STAT
			if (tracing_pages > 0) 
				#pragma region <Display the page break cost 1006>
			{
				begin_diagnostic();
				print_nl(TEX_STRING("%"));
				print(TEX_STRING(" t="));
				print_totals();
				print(TEX_STRING(" g=")); print_scaled(page_goal);
				print(TEX_STRING(" b="));
				if (b == awful_bad)
					print_char(TEX_STRING("*"));
				else
					print_int(b);
				print(TEX_STRING(" p=")); print_int(pi);
				print(TEX_STRING(" c="));
				if (c == awful_bad)
					print_char(TEX_STRING("*"));
				else
					print_int(c);
				if (c <= least_page_cost)
					print_char(TEX_STRING("#"));
				end_diagnostic(false);
			}
				#pragma endregion
#endif
			//tats
			if (c <= least_page_cost) {
				best_page_break = p; best_size = page_goal; least_page_cost = c;
				r = link(page_ins_head);
				while (r != page_ins_head) {
					best_ins_ptr(r) = last_ins_ptr(r); r = link(r);
				}
			}
			if (c == awful_bad || pi <= eject_penalty) {
				fire_up(p);
				if (output_active)
					return;
				goto done;
			}
		}
		#pragma endregion

		if (type(p) < glue_node || type(p) > kern_node)
			goto contribute;

update_heights:
		#pragma region <Update the current page measurements with respect to the glue or kern specified by node p 1004>
		if (type(p) == kern_node)
			q = p;
		else {
			q = glue_ptr(p);
			page_so_far[2 + stretch_order(q)] += stretch(q);
			page_shrink += shrink(q);
			if (shrink_order(q) != normal && shrink(q) != 0) {
				print_err(TEX_STRING("Infinite glue shrinkage found on current page"));
				help4(TEX_STRING("The page about to be output contains some infinitely"),
					TEX_STRING("shrinkable glue, e.g., `\vss' or `\vskip 0pt minus 1fil'."),
					TEX_STRING("Such glue doesn't belong there; but you can safely proceed,"),
					TEX_STRING("since the offensive shrinkability has been made finite."));
				error();
				r = new_spec(q);
				shrink_order(r) = normal; delete_glue_ref(q); glue_ptr(p) = r; q = r;
			}
		}
		page_total += page_depth + width(q); page_depth = 0;
		#pragma endregion

contribute:
		#pragma region <Make sure that page_max_depth is not exceeded 1003>
		if (page_depth > page_max_depth) {
			page_total = page_total + page_depth - page_max_depth;
			page_depth = page_max_depth;
		}
		#pragma endregion

		#pragma region <Link node p into the current page and goto done 998>
		link(page_tail) = p; page_tail = p; link(contrib_head) = link(p); link(p) = null;
		goto done;
		#pragma endregion
done1:
		#pragma region <Recycle node p 999>
		link(contrib_head) = link(p); link(p) = null; flush_node_list(p);
		#pragma endregion
done:
		;

		#pragma endregion
	} while (!(link(contrib_head) == null));

	#pragma region <Make the contribution list empty by setting its tail to contrib_head 995>
	if (nest_ptr == 0)
		tail = contrib_head;
	else
		contrib_tail = contrib_head;
	#pragma endregion
}

// 1265
void new_interaction()
{
	print_ln();
	
	// Overflow check
	if (cur_chr > 255) {
		printf("overflow in 1265\n");
		exit(1);
	}
	///////////////////
	
	interaction = (unsigned char)cur_chr;
	#pragma region <Initialize the print selector based on interaction 75>
	if (interaction == batch_mode) selector = no_print; else selector = term_only;
	#pragma endregion
	if (log_opened)
		selector = selector + 2;
}

// 1049
void you_cant()
{
	print_err(TEX_STRING("You can't use `"));
	print_cmd_chr(cur_cmd, cur_chr);
	print(TEX_STRING("' in "));
	print_mode(mode);
}


// 1050
void report_illegal_case()
{
	you_cant();
	help4(TEX_STRING("Sorry, but I'm not programmed to handle this case;"),
		TEX_STRING("I'll just pretend that you didn't ask for it."),
		TEX_STRING("If you're in the wrong mode, you might be able to"),
		TEX_STRING("return to the right one by typing `I}' or `I$' or `I\par'."));
	error();
}

// 1051
bool privileged()
{
	if (mode > 0)
		return true;
	else {
		report_illegal_case();
		return false;
	}
}

// 1241
void fix_date_and_time()
{
	time_t unixtime;
	time(&unixtime);
	struct tm *tm_struct = localtime(&unixtime);
	
	_time = tm_struct->tm_hour*60+tm_struct->tm_min;
	day = tm_struct->tm_mday;
	month = tm_struct->tm_mon + 1;
	year = 1900 + tm_struct->tm_year;
}

// 1257
void new_font(small_number a)
{
	pointer u;
	scaled s;
	internal_font_number f;
	str_number t;
	unsigned int old_setting;
	str_number flushable_string;

	if (job_name == null)
		open_log_file();
	get_r_token();
	u = cur_cs;
	if (u >= hash_base)
		t = text(u);
	else if (u >= single_base) 
		if (u == null_cs)
			t = TEX_STRING("FONT");
		else
			t = u - single_base;
	
	else {
		old_setting = selector; selector = new_string; print(TEX_STRING("FONT"));
		print(u - active_base);
		selector = old_setting; str_room(1); t = make_string();
	}
	define(u, set_font, null_font); scan_optional_equals(); scan_file_name();

	#pragma region <Scan the font size specification 1258>
	name_in_progress = true;
	if (scan_keyword(TEX_STRING("at"))) {
		//<Put the (positive) at size int s 1259>
		scan_normal_dimen; s = cur_val;
		if (s <= 0 || s >= 01000000000) {
			print_err(TEX_STRING("Improper `at' size ("));
			print_scaled(s); print(TEX_STRING("pt), replaced by 10pt"));
			help2(TEX_STRING("I can only handle fonts at positive sizes that are"),
				TEX_STRING("less than 2048pt, so I've changed what you said to 10pt."));
			error();
			s = 10 * unity;
		}
	}
	else if (scan_keyword(TEX_STRING("scaled"))) {
		scan_int(); s = -cur_val;
		if (cur_val <= 0 || cur_val > 32768) {
			print_err(TEX_STRING("Illegal magnification has been changed to 1000"));
			help1(TEX_STRING("The magnification ratio must be between 1 and 32768."));
			int_error(cur_val);
			s = -1000;
		}
	}
	else
		s = -1000;
	name_in_progress = false;

	#pragma endregion
	
	#pragma region <If this font has already been loaded set f to the internal font number and goto common_ending 1260>
	flushable_string = str_ptr - 1;
	for (f = font_base + 1; f <= font_ptr; f++)
		if (str_eq_str(font_name[f], cur_name) && str_eq_str(font_area[f], cur_area)) {
			if (cur_name == flushable_string) {
				flush_string; cur_name = font_name[f];
			}
			if (s > 0) {
				if (s == font_size[f]) goto common_ending;
			}
			else if (font_size[f] == xn_over_d(font_dsize[f], -s, 1000)) goto common_ending;
		}

	#pragma endregion

	f = read_font_info(u, cur_name, cur_area, s);

common_ending:
	equiv(u) = f; eqtb[font_id_base + f] = eqtb[u]; font_id_text(f) = t;
}

// 1338
// skip implementing this for now
// debug
#ifndef NO_DEBUG
void debug_help()
{
	int k, l, m, n;
	while (true)
	{
		wake_up_terminal(); print_nl(TEX_STRING("debug # (-1 to exit):")); update_terminal(); fscanf(term_in, "%d", &m); //read(term_in, m);
		if (m < 0) return;
		else if (m == 0)
		{
			/* NOTE: Do not know how this was used in Pascal Tex
			goto breakpoint; @\ {go to every label at least once}
			breakpoint: m = 0; @{'BREAKPOINT'@}@\
			*/
			// Instead print something and continue
			print_nl(TEX_STRING("Option 0 not implemented, sorry."));
			continue;
		}
		else {
			//read(term_in, n);
			fscanf(term_in, "%d", &n);
			switch (m)
			{
				#pragma region <Numbered cases for debug help 1339>
				case 1: print_word(mem[n]); break;// {display mem[n] in all forms}
				case 2: print_int(info(n)); break;
				case 3: print_int(link(n)); break;
				case 4: print_word(eqtb[n]); break;
				case 5: print_word(font_info[n]); break;
				case 6: print_word(save_stack[n]); break;
				case 7: show_box(n);  break; //{show a box, abbreviated by show box depth and show box breadth }
				case 8: breadth_max = 10000; depth_threshold = pool_size - pool_ptr - 10; show_node_list(n);  break; //{show a box in its entirety}
				case 9: show_token_list(n, null, 1000); break;
				case 10: slow_print(n); break;
				case 11: check_mem(n > 0);  break; // {check wellformedness; print new busy locations if n > 0}
				case 12: search_mem(n);  break; // {look for pointers to n}
				case 13: fscanf(term_in, "%d", &l);   /*read(term_in, l);*/ print_cmd_chr(n, l);  break;
				case 14: for (k = 0; k <= n; k++) print(buffer[k]);  break;
				case 15: font_in_short_display = null_font; short_display(n);  break;
				case 16: panicking = !panicking;  break;
				#pragma endregion
				default: print(TEX_STRING("?")); break;
			}
		}
	}
}
#endif
// gubed

// 1284
void give_err_help()
{
	token_show(err_help);
}

// 1335
void final_cleanup()
{
	small_number c;
	c = cur_chr;
	if (job_name == 0)
		open_log_file();
	while (input_ptr > 0) {
		if (state == token_list)
			end_token_list();
		else
			end_file_reading();
	}
	while (open_parens > 0) {
		print(TEX_STRING(" )"));
		decr(open_parens);
	}
	if (cur_level > level_one) {
		print_nl(TEX_STRING("("));
		print_esc(TEX_STRING("end occurred "));
		print(TEX_STRING("inside a group at level "));
		print_int(cur_level - level_one); print_char(TEX_STRING(")"));
	}
	while (cond_ptr != null) {
		print_nl(TEX_STRING("("));
		print_esc(TEX_STRING("end occurred "));
		print(TEX_STRING("when "));
		print_cmd_chr(if_test, cur_if);
		if (if_line != 0) {
			print(TEX_STRING(" on line ")); print_int(if_line);

		}
		print(TEX_STRING(" was incomplete)")); if_line = if_line_field(cond_ptr); cur_if = subtype(cond_ptr);
		temp_ptr = cond_ptr; cond_ptr = link(cond_ptr); free_node(temp_ptr, if_node_size);
	}
	if (history != spotless) {
		if (history == warning_issued || interaction < error_stop_mode) {
			if (selector == term_and_log) {
				selector = term_only;
				print_nl(TEX_STRING("(see the transcript file for additional information)"));
				selector = term_and_log;
			}
		}
	}
	if (c == 1) {
		// init
#ifndef NO_INIT
		for (c = top_mark_code; c <= split_bot_mark_code; c++) {
			if (cur_mark[c] != null)
				delete_token_ref(cur_mark[c]);
		}
		if (last_glue != max_halfword)
			delete_glue_ref(last_glue);
		store_fmt_file();


		return;
#endif		
		// tini
		print_nl(TEX_STRING("(\dump is performed only by INITEX)"));
		return;
	}

}

// 440
void scan_int()
{
	bool negative;
	int m;
	small_number d;
	bool vacuous;
	bool OK_so_far;


	radix = 0;
	OK_so_far = true;
	#pragma region <Get the next non_blank non-sign token; set negative appropriately 441>
	negative = false;
	do {
		#pragma region <Get the next non-blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion

		if (cur_tok == other_token + TEX_STRING("-")) {
			negative = !negative; cur_tok = other_token + TEX_STRING("+");
		}
	} while (!(cur_tok != other_token + TEX_STRING("+")));

	#pragma endregion

	if (cur_tok == alpha_token)
		#pragma region <Scan an alphabetic character code into cur_val 442>
	{		
		get_token();
		if (cur_tok < cs_token_flag) {
			cur_val = cur_chr;
			if (cur_cmd <= right_brace)
				if (cur_cmd == right_brace)
					incr(align_state);
				else
					decr(align_state);
		}
		else if (cur_tok < cs_token_flag + single_base)
			cur_val = cur_tok - cs_token_flag - active_base;
		else
			cur_val = cur_tok - cs_token_flag - single_base;
		if (cur_val > 255) {
			print_err(TEX_STRING("Improper alphabetic constant"));
			help2(TEX_STRING("A one-character control sequence belongs after a ` mark."),
				TEX_STRING("So I'm essentially inserting \0 here."));
			cur_val = TEX_STRING("0");
			back_error();
		}
		else 
			#pragma region <Scan an optional space 443>
		{
			get_x_token();
			if (cur_cmd != spacer)
				back_input();
		}
			#pragma endregion
		
	}
		#pragma endregion
	else if (cur_cmd >= min_internal && cur_cmd <= max_internal)
		scan_something_internal(int_val, false);
	else 
		#pragma region <Scan a numeric constant 444>
	{
		
		radix = 10; m = 214748364;
		if (cur_tok == octal_token) {
			radix = 8; m = 02000000000;
			get_x_token();
		}
		else if (cur_tok == hex_token) {
			radix = 16; m = 01000000000;
			get_x_token();
		}
		vacuous = true; cur_val = 0;

		#pragma region <Accumulate the constant until cur_toks is not a suitable digit 445>
		while (1) {
			if (cur_tok < zero_token + radix && cur_tok >= zero_token && cur_tok <= zero_token + 9)
				d = cur_tok - zero_token;
			else if (radix == 16)
				if (cur_tok <= A_token + 5 && cur_tok >= A_token) d = cur_tok - A_token + 10;
				else if (cur_tok <= other_A_token + 5 && cur_tok >= other_A_token)
					d = cur_tok - other_A_token + 10;
				else goto done;
			else goto done;
			vacuous = false;
			if (cur_val >= m && (cur_val > m || d > 7 || radix != 10)) {
				if (OK_so_far) {
					print_err(TEX_STRING("Number too big"));
					help2(TEX_STRING("I can only go up to 2147483647='17777777777=""7FFFFFFF,"),
						TEX_STRING("so I'm using that number instead of yours."));
					error();
					cur_val = _infinity;
					OK_so_far = false;
				}
			}
			else cur_val = cur_val * radix + d;
			get_x_token();
		}
done:
		#pragma endregion

		if (vacuous) 
			#pragma region <Express astonishment that no number was here 446>
		{
			print_err(TEX_STRING("Missing number, treated as zero"));
			help3(TEX_STRING("A number should have been here; I inserted `0'."),
				TEX_STRING("(If you can't figure out why I needed to see a number,"),
				TEX_STRING("look up `weird error' in the index to The TeXbook.)"));
			back_error();
		}
			#pragma endregion
		else if (cur_cmd != spacer) back_input();
	}
		#pragma endregion

	if (negative)
		negate(cur_val);
}


// 407
bool scan_keyword(str_number s)
{
	pointer p;
	pointer q;
	pool_pointer k;
	p = backup_head; link(p) = null; k = str_start[s];

	while (k < str_start[s + 1]) {
		get_x_token();
		if (cur_cs == 0 && (cur_chr == so(str_pool[k]) || cur_chr == so(str_pool[k]) - TEX_STRING("a") +
			TEX_STRING("A"))) {
			store_new_token(cur_tok); incr(k);
		}
		else if (cur_cmd != spacer || p != backup_head) {
			back_input();
			if (p != backup_head)
				back_list(link(backup_head));
			return false;
		}
	}
	flush_list(link(backup_head));
	return true;
}

// 434
void scan_char_num()
{
	scan_int();
	if (cur_val < 0 || cur_val > 255) {
		print_err(TEX_STRING("Bad character code"));
		help2(TEX_STRING("A character number must be between 0 and 255."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

///////////////////////////////////////////////////////////////////////////
// System specific addition for paths on windows

void copypath(char *s1, char *s2, int n)
{
	while ((*s1++ = *s2++) != 0) {
		if (--n == 0) {
			fprintf(stderr, "! Environment search path is too big\n");
			*--s1 = 0;
			return;
		}
	}
}

void set_paths()
{
	char *envpath;
	if ((envpath = getenv("TEXINPUTS")) != NULL)
		copypath(input_path, envpath, MAX_INPUT_CHARS);
	if ((envpath = getenv("TEXFONTS")) != NULL)
		copypath(font_path, envpath, MAX_INPUT_CHARS);
	if ((envpath = getenv("TEXFORMATS")) != NULL)
		copypath(format_path, envpath, MAX_INPUT_CHARS);
	if ((envpath = getenv("TEXPOOL")) != NULL)
		copypath(pool_path, envpath, MAX_INPUT_CHARS);
}

void pack_real_name_of_file(char **cpp)
{
	char *p;
	char *real_name;

	real_name = &real_name_of_file[1];
	if ((p = *cpp) != NULL) {
		while ((*p != ';') && (*p != 0)) {
			*real_name++ = *p++;
			if (real_name == &real_name_of_file[file_name_size])
				break;
		}
		if (*p == 0) *cpp = NULL;
		else *cpp = p + 1;
		*real_name++ = '\\';
	}
	p = name_of_file.get_c_str();
	
	while (*p != 0) {
		if (real_name >= &real_name_of_file[file_name_size]) {
			fprintf(stderr, "! Full file name is too long\n");
			break;
		}
		*real_name++ = *p++;
	}
	*real_name = 0;
	
}

bool test_access(int filepath)
{
	bool ok;
	char *cur_path_place;

	switch (filepath) {
	case no_file_path: cur_path_place = NULL; break;
	case input_file_path: 
	case read_file_path:
		cur_path_place = input_path; break;
	case font_file_path: cur_path_place = font_path; break;
	case format_file_path: cur_path_place = format_path; break;
	case pool_file_path: cur_path_place = pool_path; break;
	default:
		fprintf(stderr, "! This should not happen, test_access\n");
		exit(1);
		break;
	}
	if (name_of_file[1] == '\\' || (isalpha(name_of_file[1]) && name_of_file[2] == ':'))
		cur_path_place = NULL;
	do {
		pack_real_name_of_file(&cur_path_place);
		if (_access(real_name_of_file.get_c_str(), 0) == 0)
			ok = true;
		else
			ok = false;
	} while (!ok && cur_path_place != NULL);

	return ok;
}

///////////////////////////////////////////////////////////////////////////


// 537
void start_input()
{
	scan_file_name();
	if (cur_ext == TEX_STRING(""))
		cur_ext = TEX_STRING(".tex");
	pack_cur_name;
	while (1) {
		begin_file_reading();
		if (a_open_in(&cur_file, input_file_path)) goto done;
		if (cur_ext == TEX_STRING(".tex")) {
			pack_file_name(cur_name, cur_area, TEX_STRING(""));
			if (a_open_in(&cur_file, input_file_path)) goto done;
		}
		end_file_reading();
		prompt_file_name(TEX_STRING("input file name"),
			TEX_STRING(".tex"));
	}
done:
	name = a_make_name_string(cur_file);
	if (job_name == 0) {
		job_name = cur_name; open_log_file();
	}
	if (term_offset + length(name) > max_print_line - 2) print_ln();
	else if (term_offset > 0 || file_offset > 0) print_char(TEX_STRING(" "));
	print_char(TEX_STRING("(")); incr(open_parens); slow_print(name); update_terminal(); state = new_line;
	
	/*
	if (name == str_ptr - 1) {
		flush_string;
		name = cur_name;
	}
	*/
	
	#pragma region <Read the first line of the new file 538>
	line = 1;

	input_ln(cur_file, false);
	firm_up_the_line();
	if (end_line_char_inactive) decr(limit);
	else buffer[limit] = end_line_char;
	first = limit + 1; loc = start;
	#pragma endregion
}


// 1054
bool its_all_over()
{
	if (privileged()) {
		if (page_head == page_tail && head == tail && dead_cycles == 0) {
			return true;
		}
		back_input();
		tail_append(new_null_box()); width(tail) = hsize; tail_append(new_glue(fill_glue));
		tail_append(new_penalty(-010000000000));
		build_page();
	}
	return false;
}

// 1194
void after_math()
{
	bool l;
	bool danger;
	int m;
	pointer p;
	pointer a;
	#pragma region <Local varaibles for finishing a displayed formula 1198>
	pointer b;
	scaled w;
	scaled z;
	scaled e;
	scaled q;
	scaled d;
	scaled s;
	small_number g1, g2;
	pointer r;
	pointer t;
	#pragma endregion

	danger = false;
	#pragma region <Check that the necessary fonts for math symbols are present; if not flush the current math lists and set danger = true 1195>
	if (font_params[fam_fnt(2 + text_size)] < total_mathsy_params ||
		font_params[fam_fnt(2 + script_size)] < total_mathsy_params ||
		font_params[fam_fnt(2 + script_script_size)] < total_mathsy_params) {
		print_err(TEX_STRING("Math formula deleted: Insufficient symbol fonts"));
		help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 2"),
			TEX_STRING("and \scriptfont 2 and \scriptscriptfont 2 have all"),
			TEX_STRING("the \fontdimen values needed in math symbol fonts."));
		error();
		flush_math();
		danger = true;
	}
	else if (font_params[fam_fnt(3 + text_size)] < total_mathex_params ||
		font_params[fam_fnt(3 + script_size)] < total_mathex_params ||
		font_params[fam_fnt(3 + script_script_size)] < total_mathex_params) {
		print_err(TEX_STRING("Math formula deleted: Insufficient extension fonts"));
		help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 3"),
			TEX_STRING("and \scriptfont 3 and \scriptscriptfont 3 have all"),
			TEX_STRING("the \fontdimen values needed in math extension fonts."));
		error();
		flush_math();
		danger = true;
	}
	#pragma endregion

	m = mode; l = false; p = fin_mlist(null);
	if (mode == -m) {
		#pragma region <Check that another $ follows 1197>
		{
			get_x_token();
			if (cur_cmd != math_shift) {
				print_err(TEX_STRING("Display math should end with $$"));
				help2(TEX_STRING("The `$' that I just saw supposedly matches a previous `$$'."),
					TEX_STRING("So I shall assume that you typed `$$' both times."));
				back_error();
			}
		}
		#pragma endregion

		cur_mlist = p; cur_style = text_style; mlist_penalties = false; mlist_to_hlist();
		a = hpack(link(temp_head), 0, additional); unsave(); decr(save_ptr);
		if (saved(0) == 1) l = true;
		danger = false;
		#pragma region <Check that the necessary fonts for math symbols are present; if not flush the current math lists and set danger = true 1195>
		if (font_params[fam_fnt(2 + text_size)] < total_mathsy_params ||
			font_params[fam_fnt(2 + script_size)] < total_mathsy_params ||
			font_params[fam_fnt(2 + script_script_size)] < total_mathsy_params) {
			print_err(TEX_STRING("Math formula deleted: Insufficient symbol fonts"));
			help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 2"),
				TEX_STRING("and \scriptfont 2 and \scriptscriptfont 2 have all"),
				TEX_STRING("the \fontdimen values needed in math symbol fonts."));
			error();
			flush_math();
			danger = true;
		}
		else if (font_params[fam_fnt(3 + text_size)] < total_mathex_params ||
			font_params[fam_fnt(3 + script_size)] < total_mathex_params ||
			font_params[fam_fnt(3 + script_script_size)] < total_mathex_params) {
			print_err(TEX_STRING("Math formula deleted: Insufficient extension fonts"));
			help3(TEX_STRING("Sorry, but I can't typeset math unless \textfont 3"),
				TEX_STRING("and \scriptfont 3 and \scriptscriptfont 3 have all"),
				TEX_STRING("the \fontdimen values needed in math extension fonts."));
			error();
			flush_math();
			danger = true;
		}
		#pragma endregion
		m = mode; p = fin_mlist(null);
	}
	else a = null;
	if (m < 0) 
		#pragma region <Finish math in text 1196>
	{
		tail_append(new_math(math_surround, before)); cur_mlist = p; cur_style = text_style;
		mlist_penalties = (mode > 0); mlist_to_hlist(); link(tail) = link(temp_head);
		while (link(tail) != null) tail = link(tail);
		tail_append(new_math(math_surround, after)); space_factor = 1000; unsave();
	}
		#pragma endregion
	else {
		if (a == null) 
			#pragma region <Check that another $ follows 1197>
		{
			get_x_token();
			if (cur_cmd != math_shift) {
				print_err(TEX_STRING("Display math should end with $$"));
				help2(TEX_STRING("The `$' that I just saw supposedly matches a previous `$$'."),
					TEX_STRING("So I shall assume that you typed `$$' both times."));
				back_error();
			}
		}
			#pragma endregion
		#pragma region <Finish displayed math 1199>
		cur_mlist = p; cur_style = display_style; mlist_penalties = false; mlist_to_hlist(); p = link(temp_head);
		adjust_tail = adjust_head; b = hpack(p, 0, additional); p = list_ptr(b); t = adjust_tail; adjust_tail = null;
		w = width(b); z = display_width; s = display_indent;
		if (a == null || danger) {
			e = 0; q = 0;
		}
		else {
			e = width(a); q = e + math_quad(text_size);
		}
		if (w + q > z) 
			#pragma region <Squeeze the equation as much as possible if ther is an equaton number that should go on a separate line by itself, set e = 0 1201>
		{
			if (e != 0 && (w - total_shrink[normal] + q <= z || total_shrink[fil] != 0 ||
				total_shrink[fill] != 0 || total_shrink[filll]!=0)) {
				free_node(b, box_node_size); b = hpack(p, z - q, exactly);
			}
			else {
				e = 0;
				if (w > z) {
					free_node(b, box_node_size); b = hpack(p, z, exactly);
				}
			}
			w = width(b);
		}
			#pragma endregion

		#pragma region <Determine the displacement, d of the left edge of the equation with respect to the line size z assuming that l = false 1202>
		d = half(z - w);
		if (e > 0 && d < 2 * e) {
			d = half(z - w - e);
			if (p != null)
				if (!is_char_node(p))
					if (type(p) == glue_node)
						d = 0;
		}
		#pragma endregion

		#pragma region <Append the glue or equation number preceding the display 1203>
		tail_append(new_penalty(pre_display_penalty));
		if (d + s <= pre_display_size || l) {
			g1 = above_display_skip_code; g2 = below_display_skip_code;
		}
		else {
			g1 = above_display_short_skip_code; g2 = below_display_short_skip_code;
		}
		if (l && (e == 0)) {
			shift_amount(a) = s; append_to_vlist(a); tail_append(new_penalty(inf_penalty));
		}
		else tail_append(new_param_glue(g1));
		#pragma endregion

		#pragma region <Append the display and perhaps also the equation number 1204>
		if (e != 0) {
			r = new_kern(z - w - e - d);
			if (l) {
				link(a) = r; link(r) = b; b = a; d = 0;
			}
			else {
				link(b) = r; link(r) = a;
			}
			b = hpack(b, 0, additional);
		}
		shift_amount(b) = s + d; append_to_vlist(b);
		#pragma endregion

		#pragma region <Append the glue or equation number folllowing the display 1205>
		if (a != null && e == 0 && !l) {
			tail_append(new_penalty(inf_penalty)); shift_amount(a) = s + z - width(a); append_to_vlist(a);
			g2 = 0;
		}
		if (t != adjust_head) {
			link(tail) = link(adjust_head); tail = t;
		}
		tail_append(new_penalty(post_display_penalty));
		if (g2 > 0) tail_append(new_param_glue(g2));
		#pragma endregion

		resume_after_display();
		#pragma endregion
	}
}


// 1211
void prefixed_command()
{
	small_number a;
	internal_font_number f;
	halfword j;
	font_index k;
	pointer p, q;
	int n;
	bool e;


	a = 0;
	while (cur_cmd == prefix) {
		if (!myodd(a / cur_chr))
			a = a + cur_chr;
		#pragma region <Get the next non-blank non-relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion

		if (cur_cmd <= max_non_prefixed_command)
			#pragma region <Discard erroneous prefixes and return 1212>
		{
			print_err(TEX_STRING("You can't use a prefix with `")); print_cmd_chr(cur_cmd, cur_chr);
			print_char(TEX_STRING("'"));
			help1(TEX_STRING("I'll pretend you didn't say \long or \outer or \global."));
			back_error();
			return;
		}
			#pragma endregion
	}
	#pragma region <Discard the prefixes long and outer if they are irrelevant 1213>
	if (cur_cmd != def && (a % 4 != 0)) {
		print_err(TEX_STRING("You can't use `"));
		print_esc(TEX_STRING("long"));
		print(TEX_STRING("' or `"));
		print_esc(TEX_STRING("outer"));
		print(TEX_STRING("' with `")); print_cmd_chr(cur_cmd, cur_chr);
		print_char(TEX_STRING("'"));
		help1(TEX_STRING("I'll pretend you didn't say \long or \outer here."));
		error();
	}
	#pragma endregion

	#pragma region <Adjust for the setting of globaldefs 1214>
	if(global_defs != 0)
		if (global_defs < 0) {
			if (global) a -= 4;
		}
		else {
			if (!global) a += 4;
		}
	#pragma endregion

	switch (cur_cmd) {
	#pragma region <Assignments 1217>

		//1218
	case set_font:
		define(cur_font_loc, data, cur_chr);
		break;
	case def:
		if (myodd(cur_chr) && !global && global_defs >= 0)
			a = a + 4;
		e = (cur_chr >= 2);
		get_r_token();
		p = cur_cs;
		q = scan_toks(true, e);
		define(p, call + (a % 4), def_ref);
		break;
		//1221
	case let:
		n = cur_chr;
		get_r_token();
		p = cur_cs;
		if (n == normal) {
			do {
				get_token();
			} while (!(cur_cmd != spacer));
			if (cur_tok == other_token + TEX_STRING("=")) {
				get_token();
				if (cur_cmd == spacer)
					get_token();
			}
		}
		else {
			get_token();
			q = cur_tok;
			get_token();
			back_input();
			cur_tok = q;
			back_input();
		}
		if (cur_cmd >= call)
			add_token_ref(cur_chr);
		define(p, cur_cmd, cur_chr);
		break;
		//1224
	case shorthand_def:
		n = cur_chr;
		get_r_token();
		p = cur_cs;
		define(p, relax, 256);
		scan_optional_equals();
		switch (n) {
		case char_def_code:
			scan_char_num();
			define(p, char_given, cur_val);
			break;
		case math_char_def_code:
			scan_fifteen_bit_int();
			define(p, math_given, cur_val);
			break;
		default:
			scan_eight_bit_int();
			switch (n) {
			case count_def_code:
				define(p, assign_int, count_base + cur_val);
				break;
			case dimen_def_code:
				define(p, assign_dimen, scaled_base + cur_val);
				break;
			case skip_def_code:
				define(p, assign_glue, skip_base + cur_val);
				break;
			case mu_skip_def_code:
				define(p, assign_mu_glue, mu_skip_base + cur_val);
				break;
			case toks_def_code:
				define(p, assign_toks, toks_base + cur_val);
				break;
			}
		}
		break;
		//1225
	case read_to_cs:
		scan_int();
		n = cur_val;
		if (!scan_keyword(TEX_STRING("to"))) {
			print_err(TEX_STRING("Missing `to' inserted"));
			help2(TEX_STRING("You should have said `\read<number> to \cs'."),
				TEX_STRING("I'm going to look for the \cs now."));
			error();
		}
		get_r_token();
		p = cur_cs;
		read_toks(n, p);
		define(p, call, cur_val);
		break;
		//1226
	case toks_register:
	case assign_toks:
		q = cur_cs;
		if (cur_cmd == toks_register) {
			scan_eight_bit_int();
			p = toks_base + cur_val;
		}
		else
			p = cur_chr;
		scan_optional_equals();
		#pragma region <Get the next non-blank non-relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion
		if (cur_cmd != left_brace) 
			#pragma region <If the right-hand side is a token parameter or token register, finish the assignment and goto done 1227>
		{
			if (cur_cmd == toks_register) {
				scan_eight_bit_int();
				cur_cmd = assign_toks;
				cur_chr = toks_base + cur_val;
			}
			if (cur_cmd == assign_toks) {
				q = equiv(cur_chr);
				if (q == null) define(p, undefined_cs, null);
				else {
					add_token_ref(q); define(p, call, q);
				}
				goto done;
			}
		}
			#pragma endregion

		back_input();
		cur_cs = q;
		q = scan_toks(false, false);
		if (link(def_ref) == null) {
			define(p, undefined_cs, null);
			free_avail(def_ref);
		}
		else {
			if (p == output_routine_loc) {
				link(q) = get_avail(); q = link(q); info(q) = right_brace_token + TEX_STRING("}");
				q = get_avail();
				info(q) = left_brace_token + TEX_STRING("{"); link(q) = link(def_ref); link(def_ref) = q;
			}
			define(p, call, def_ref);
		}

		break;
		//1228
	case assign_int:
		p = cur_chr;
		scan_optional_equals();
		scan_int();
		word_define(p, cur_val);
		break;
	case assign_dimen:
		p = cur_chr;
		scan_optional_equals();
		scan_normal_dimen;
		word_define(p, cur_val);
		break;

	case assign_glue:
	case assign_mu_glue:
		p = cur_chr;
		n = cur_cmd;
		scan_optional_equals();
		if (n == assign_mu_glue)
			scan_glue(mu_val);
		else
			scan_glue(glue_val);
		trap_zero_glue();
		define(p, glue_ref, cur_val);
		break;
		//1232
	case def_code:
		#pragma region <Let ne be the largest legal code value, based on cur_chr 1233>
		if (cur_chr == cat_code_base) n = max_char_code;
		else if (cur_chr == math_code_base) n = 0100000;
		else if (cur_chr == sf_code_base) n = 077777;
		else if (cur_chr == del_code_base) n = 077777777;
		else n = 255;
		#pragma endregion
		p = cur_chr;
		scan_char_num();
		p = p + cur_val;
		scan_optional_equals();
		scan_int();
		if ((cur_val < 0 && p < del_code_base) || cur_val > n) {
			print_err(TEX_STRING("Invalid code (")); print_int(cur_val);
			if (p < del_code_base)
				print(TEX_STRING("), should be in the range 0.."));
			else print(TEX_STRING("), should be at most "));
			print_int(n);
			help1(TEX_STRING("I'm going to use 0 instead of that illegal code value."));
			error();
			cur_val = 0;
		}
		if (p < math_code_base)
			define(p, data, cur_val);
		else if (p < del_code_base)
			define(p, data, hi(cur_val));
		else
			word_define(p, cur_val);

		break;
		//1234
	case def_family:
		p = cur_chr;
		scan_four_bit_int();
		p = p + cur_val;
		scan_optional_equals();
		scan_font_ident();
		define(p, data, cur_val);
		break;
		//1235
	case _register:
	case advance:
	case multiply:
	case divide:
		do_register_command(a);
		break;
		//1241
	case set_box:
		scan_eight_bit_int();
		if (global)
			n = 256 + cur_val;
		else
			n = cur_val;
		scan_optional_equals();
		if (set_box_allowed)
			scan_box(box_flag + n);
		else {
			print_err(TEX_STRING("Improper "));
			print_esc(TEX_STRING("setbox"));
			help2(TEX_STRING("Sorry, \setbox is not allowed after \halign in a display,"),
				TEX_STRING("or between \accent and an accented character."));
			error();
		}
		break;
		//1242
	case set_aux:
		alter_aux();
		break;
	case set_prev_graf:
		alter_prev_graf();
		break;
	case set_page_dimen:
		alter_page_so_far();
		break;
	case set_page_int:
		alter_integer();
		break;
	case set_box_dimen:
		alter_box_dimen();
		break;
		//1217
	case set_shape:
		scan_optional_equals();
		scan_int();
		n = cur_val;
		if (n <= 0)
			p = null;
		else {
			p = get_node(2 * n + 1); info(p) = n;
			for (j = 1; j <= n; j++) {
				scan_normal_dimen; mem[p + 2 * j - 1].sc = cur_val;
				scan_normal_dimen; mem[p + 2 * j].sc = cur_val;
			}
		}
		define(par_shape_loc, shape_ref, p);
		break;
		//1217
	case hyph_data:
		if (cur_chr == 1) {
			//init
#ifndef NO_INIT
			new_patterns();
			goto done;
#endif
			//tini
			print_err(TEX_STRING("Patterns can be loaded only by INITEX"));
			help0;
			error();
			do {
				get_token();
			} while (!(cur_cmd == right_brace));
			return;
		}
		else {
			new_hyph_exceptions();
			goto done;
		}
		break;
		// 1217
	case assign_font_dimen:
		find_font_dimen(true);
		k = cur_val;
		scan_optional_equals();
		scan_normal_dimen;
		font_info[k].sc = cur_val;
		break;
	case assign_font_int:
		n = cur_chr;
		scan_font_ident();
		f = cur_val;
		scan_optional_equals();
		scan_int();
		if (n == 0)
			hyphen_char[f] = cur_val;
		else
			skew_char[f] = cur_val;
		break;
		//1256
	case def_font:
		new_font(a);
		break;
		//1264
	case set_interaction:
		new_interaction();
		break;


	#pragma endregion

	default:
		confusion(TEX_STRING("prefix"));
		break;
	}
done:
	#pragma region <Insert a token saved by afterassignment, if any 1269>
	if (after_token) {
		cur_tok = after_token;
		back_input();
		after_token = 0;
	}
	#pragma endregion
}

// 1012
void fire_up(pointer c)
{
	pointer p, q, r, s;
	pointer prev_p;
	unsigned char n;
	bool wait;
	int save_vbadness;
	scaled save_vfuzz;
	pointer save_split_top_skip;

	#pragma region <Set the value of output_penalty 1013>
	if (type(best_page_break) == penalty_node) {
		geq_word_define(int_base + output_penalty_code, penalty(best_page_break));
		penalty(best_page_break) = inf_penalty;
	}
	else geq_word_define(int_base + output_penalty_code, inf_penalty);
	#pragma endregion
	
	if (bot_mark != null) {
		if (top_mark != null)
			delete_token_ref(top_mark);
		top_mark = bot_mark; add_token_ref(top_mark); delete_token_ref(first_mark);
		first_mark = null;
	}
	#pragma region <Put the optimal current page into box 255 update first_mark and bot_mark append insertions to their boxes and put the remaining nodes back on the contribution list 1014>
	if (c == best_page_break) best_page_break = null;
	#pragma region <Ensure that box 255 is empty before output 1015>
	if (box(255) != null) {
		print_err(TEX_STRING(""));
		print_esc(TEX_STRING("box"));
		print(TEX_STRING("255 is not void"));
		help2(TEX_STRING("You shouldn't use \box255 except in \output routines."),
			TEX_STRING("Proceed, and I'll discard its present contents."));
		box_error(255);
	}
	#pragma endregion

	insert_penalties = 0;
	save_split_top_skip = split_top_skip;
	if (holding_inserts <= 0) 
		#pragma region <Prepare all the boxes involved in insertions to act as queues 1018>
	{
		r = link(page_ins_head);
		while (r != page_ins_head) {
			if (best_ins_ptr(r) != null) {
				n = qo(subtype(r)); ensure_vbox(n);
				if (box(n) == null) box(n) = new_null_box();
				p = box(n) + list_offset;
				while (link(p) != null) p = link(p);
				last_ins_ptr(r) = p;
			}
			r = link(r);
		}
	}
		#pragma endregion
	q = hold_head; link(q) = null; prev_p = page_head; p = link(prev_p);
	while (p != best_page_break) {
		if (type(p) == ins_node) {
			if (holding_inserts <= 0) 
				#pragma region <Either insert the material specified by node p into the appropriate box, or hold it for the next page; also delete node p from the current page 1020>
			{
				r = link(page_ins_head);
				while (subtype(r) != subtype(p)) r = link(r);
				if (best_ins_ptr(r) == null) wait = true;
				else {
					wait = false; s = last_ins_ptr(r); link(s) = ins_ptr(p);
					if (best_ins_ptr(r) == p) 
						#pragma region <Wrap up the box specified by node r, splitting node p if called for set wait = true if node p holds a remainder after splitting 1021>
					{
						
						if(type(r) == split_up)
							if (broken_ins(r) == p && broken_ptr(r) != null) {
								while (link(s) != broken_ptr(r)) s = link(s);
								link(s) = null; split_top_skip = split_top_ptr(p); ins_ptr(p) = prune_page_top(broken_ptr(r));
								if (ins_ptr(p) != null) {
									temp_ptr = vpack(ins_ptr(p), 0, additional); height(p) = height(temp_ptr) + depth(temp_ptr);
									free_node(temp_ptr, box_node_size); wait = true;
								}
							}
						best_ins_ptr(r) = null; n = qo(subtype(r)); temp_ptr = list_ptr(box(n));
						free_node(box(n), box_node_size); box(n) = vpack(temp_ptr, 0, additional);
					}
						#pragma endregion
					else {
						while (link(s) != null) s = link(s);
						last_ins_ptr(r) = s;
					}
				}
				#pragma region <Either append the insertion node p after node q, and remove it from the current page, or delete node(p) 1022>
				link(prev_p) = link(p); link(p) = null;
				if (wait) {
					link(q) = p; q = p; incr(insert_penalties);
				}
				else {
					delete_glue_ref(split_top_ptr(p)); free_node(p, ins_node_size);
				}
				p = prev_p;
				#pragma endregion
			}
				#pragma endregion
		}
		else if (type(p) == mark_node) 
			#pragma region <Update the values of first_mark and bot_mark 1016>
		{
			if (first_mark == null) {
				first_mark = mark_ptr(p); add_token_ref(first_mark);
			}
			if (bot_mark != null) delete_token_ref(bot_mark);
			bot_mark = mark_ptr(p); add_token_ref(bot_mark);
		}
			#pragma endregion
		prev_p = p; p = link(prev_p);
	}
	split_top_skip = save_split_top_skip;
	#pragma region <Break the current page at node p, put it in box 255, and put the remaining nodes on the contribution list 1017>
	if (p != null) {
		if (link(contrib_head) == null)
			if (nest_ptr == 0) tail = page_tail;
			else contrib_tail = page_tail;
		link(page_tail) = link(contrib_head); link(contrib_head) = p; link(prev_p) = null;
	}
	save_vbadness = vbadness; vbadness = inf_bad; save_vfuzz = vfuzz; vfuzz = max_dimen;
	box(255) = vpackage(link(page_head), best_size, exactly, page_max_depth);
	vbadness = save_vbadness;
	vfuzz = save_vfuzz;
	if (last_glue != max_halfword) delete_glue_ref(last_glue);
	#pragma region <Start a new current page 991>
	page_contents = empty; page_tail = page_head; link(page_head) = null;
	last_glue = max_halfword; last_penalty = 0; last_kern = 0; page_depth = 0; page_max_depth = 0;
	#pragma endregion
	
	if (q != hold_head) {
		link(page_head) = link(hold_head); page_tail = q;
	}
	#pragma endregion

	#pragma region <Delete the page-insertion nodes 1019>
	r = link(page_ins_head);
	while (r != page_ins_head) {
		q = link(r); free_node(r, page_ins_node_size); r = q;
	}
	link(page_ins_head) = page_ins_head;
	#pragma endregion

	#pragma endregion
	if (top_mark != null && first_mark == null) {
		first_mark = top_mark; add_token_ref(top_mark);
	}
	if (output_routine != null)
		if (dead_cycles >= max_dead_cycles) 
			#pragma region <Explain that too many dead cycles have occurred in a row 1024>
		{
			//
			print_err(TEX_STRING("Output loop---"));
			print_int(dead_cycles);
			print(TEX_STRING(" consecutive dead cycles"));
			help3(TEX_STRING("I've concluded that your \output is awry; it never does a"),
				TEX_STRING("\shipout, so I'm shipping \box255 out myself. Next time"),
				TEX_STRING("increase \maxdeadcycles if you want me to be more patient!"));
			error();
		}
			#pragma endregion
		else 
			#pragma region <Fire up the users output routine and return 1025>
		{
			
			output_active = true; incr(dead_cycles); push_nest(); mode = (mode_type)-vmode;
			prev_depth = ignore_depth; mode_line = -line;
			begin_token_list(output_routine, output_text);
			new_save_level(output_group); normal_paragraph(); scan_left_brace();
			goto _exit;
		}
			#pragma endregion

	#pragma region <Perform the default output routine 1023>
	{
		if (link(page_head) != null) {
			if (link(contrib_head) == null)
				if (nest_ptr == 0) tail = page_tail;
				else contrib_tail = page_tail;
			else link(page_tail) = link(contrib_head);
			link(contrib_head) = link(page_head); link(page_head) = null; page_tail = page_head;
		}
		ship_out(box(255)); box(255) = null;
	}
	#pragma endregion
_exit:
	return;
}

// 1060
void append_glue()
{
	small_number s;
	s = cur_chr;
	switch (s) {
	case fil_code:
		cur_val = fil_glue;
		break;
	case fill_code:
		cur_val = fill_glue;
		break;
	case ss_code:
		cur_val = ss_glue;
		break;
	case fil_neg_code:
		cur_val = fil_neg_glue;
		break;
	case skip_code:
		scan_glue(glue_val);
		break;
	case mskip_code:
		scan_glue(mu_val);
		break;
	}
	tail_append(new_glue(cur_val));
	if (s >= skip_code)
	{
		decr(glue_ref_count(cur_val));
		if (s > skip_code)
			subtype(tail) = mu_glue;
	}
}

// 1061
void append_kern()
{
	quarterword s;
	
	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment append_kern\n");
		exit(1);
	}
	//--------
	
	s = (quarterword)cur_chr;
	scan_dimen(s == mu_glue, false, false); tail_append(new_kern(cur_val));
	subtype(tail) = s;
}

// 970
pointer vert_break(pointer p, scaled h, scaled d)
{
	pointer prev_p;
	pointer q, r;
	int pi;
	int b;
	int least_cost;
	pointer best_place;
	scaled prev_dp;
	small_number t;

	prev_p = p;
	least_cost = awful_bad; do_all_six(set_height_zero); prev_dp = 0;
	while (1) {
		#pragma region <If node p is a legal breakpoint, check if this break is the best known, and goto done if p is.. 972>
		if (p == null) pi = eject_penalty;
		else
			#pragma region <Use node p to update the current height and depth measurements; if this node is not a legal..break 973>

			switch (type(p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
				cur_height = cur_height + prev_dp + height(p); prev_dp = depth(p);
				goto not_found;
				break;
			case whatsit_node:
				//<Process whatsit p in vert_break loop, goto not_found 1365>
				goto not_found;
				break;

			case glue_node:
				if (precedes_break(prev_p)) pi = 0;
				else goto update_heights;
				break;
			case kern_node:
				if (link(p) == null) t = penalty_node;
				else t = type(link(p));
				if (t == glue_node) pi = 0;
				else goto update_heights;
				break;
			case penalty_node:
				pi = penalty(p);
				break;
			case mark_node:
			case ins_node:
				goto not_found;
				break;
			default:
				confusion(TEX_STRING("vertbreak"));
				break;
			}
			#pragma endregion

		#pragma region <Check if node p is a new champion breakpoint .. 974>
		if (pi < inf_penalty) {
			#pragma region <Compute the badness, b, using awful_bad if the box is too full 975>
			if (cur_height < h)
				if (active_height[3] != 0 || active_height[4] != 0 || active_height[5] != 0) b = 0;
				else b = badness(h - cur_height, active_height[2]);
			else if (cur_height - h > active_height[6]) b = awful_bad;
			else
				b = badness(cur_height - h, active_height[6]);
			#pragma endregion
			if (b < awful_bad)
				if (pi <= eject_penalty) 
					b = pi;
				else if (b < inf_bad) 
					b += pi;
				else 
					b = deplorable;
			if (b <= least_cost) {
				best_place = p; least_cost = b; best_height_plus_depth = cur_height + prev_dp;
			}
			if (b == awful_bad || pi <= eject_penalty) goto done;
		}
		#pragma endregion

		if (type(p) < glue_node || type(p) > kern_node) goto not_found;
update_heights:
		#pragma region <Update the current height and depth measurements with respect to a glue or kern node p 976>
		if (type(p) == kern_node) q = p;
		else {
			q = glue_ptr(p);
			active_height[2 + stretch_order(q)] += stretch(q);
			active_height[6] += shrink(q);
			if (shrink_order(q) != normal && shrink(q) != 0) {
				print_err(TEX_STRING("Infinite glue shrinkage found in box being split"));
				help4(TEX_STRING("The box you are \vsplitting contains some infinitely"),
					TEX_STRING("shrinkable glue, e.g., `\vss' or `\vskip 0pt minus 1fil'."), 
					TEX_STRING("Such glue doesn't belong there; but you can safely proceed,"), 
					TEX_STRING("since the offensive shrinkability has been made finite."));
				error();
				r = new_spec(q);
				shrink_order(r) = normal; delete_glue_ref(q); glue_ptr(p) = r; q = r;
			}
		}
		cur_height += prev_dp + width(q); prev_dp = 0;
		#pragma endregion

		not_found: 
		if (prev_dp > d) {
			cur_height = cur_height + prev_dp - d; prev_dp = d;
		}
		#pragma endregion
		prev_p = p; p = link(prev_p);
	}
done:
	return best_place;
}

void print_totals()
{
	print_scaled(page_total);
	print_plus(2, TEX_STRING(""));
	print_plus(3, TEX_STRING("fil"));
	print_plus(4, TEX_STRING("fill"));
	print_plus(5, TEX_STRING("filll"));
	if (page_shrink != 0) {
		print(TEX_STRING(" minus "));
		print_scaled(page_shrink);
	}
}

// 977
pointer vsplit(eight_bits n, scaled h)
{
	pointer v;
	pointer p;
	pointer q;

	v = box(n);
	if (split_first_mark != null) {
		delete_token_ref(split_first_mark); split_first_mark = null;
		delete_token_ref(split_bot_mark);
		split_bot_mark = null;
	}

	#pragma region <Dispense with trivial cases of void or bad boxes 978>
	if (v == null) {
		return null;
	}
	if (type(v) != vlist_node) {
		print_err(TEX_STRING(""));
		print_esc(TEX_STRING("vsplit"));
		print(TEX_STRING(" needs a "));
		print_esc(TEX_STRING("vbox"));
		help2(TEX_STRING("The box you are trying to split is an \hbox."),
			TEX_STRING("I can't split such a box, so I'll leave it alone."));
		error();
		return null;
	}
	#pragma endregion



	q = vert_break(list_ptr(v), h, split_max_depth);

	#pragma region <Look at all the marks in nodes before the break, and set the final link to null at the break 979>
	p = list_ptr(v);
	if (p == q) list_ptr(v) = null;
	else while (1) {
		if(type(p) == mark_node)
			if (split_first_mark == null) {
				split_first_mark = mark_ptr(p); split_bot_mark = split_first_mark;
				token_ref_count(split_first_mark) += 2;
			}
			else {
				delete_token_ref(split_bot_mark); split_bot_mark = mark_ptr(p);
				add_token_ref(split_bot_mark);
			}
		if (link(p) == q) {
			link(p) = null; goto done;
		}
		p = link(p);
	}
done:
	#pragma endregion


	q = prune_page_top(q); p = list_ptr(v); free_node(v, box_node_size);
	if (q == null) box(n) = null;
	else box(n) = vpack(q, 0, additional);



	return vpackage(p, h, exactly, split_max_depth);
}



//1200
void resume_after_display()
{
	if (cur_group != math_shift_group) confusion(TEX_STRING("display"));
	unsave(); prev_graf += 3; push_nest(); mode = hmode; space_factor = 1000; set_cur_lang;
	clang = cur_lang;
	prev_graf = (norm_min(left_hyphen_min) * 0100 + norm_min(right_hyphen_min)) * 0200000 + cur_lang;
	#pragma region <Scan an optional space 443>
	get_x_token();
	if (cur_cmd != spacer)
		back_input();
	#pragma endregion
	if (nest_ptr == 1) build_page();
}


//1236
void do_register_command(small_number a)
{
	pointer l, q, r, s;
	int p; // int_val..mu_val
	q = cur_cmd;
	#pragma region <Compute the register location l and its type p; but return if invalid 1237>
	{
		if (q != _register) {
			get_x_token();
			if (cur_cmd >= assign_int && cur_cmd <= assign_mu_glue) {
				l = cur_chr; p = cur_cmd - assign_int; goto found;
			}
			if (cur_cmd != _register) {
				print_err(TEX_STRING("You can't use `")); print_cmd_chr(cur_cmd, cur_chr); print(TEX_STRING("' after "));
				print_cmd_chr((quarterword)q, 0); help1(TEX_STRING("I'm forgetting what you said and not changing anything."));
				error();
				return;
			}
		}
		p = cur_chr; scan_eight_bit_int();
		switch (p) {
		case int_val: l = cur_val + count_base; break;
		case dimen_val: l = cur_val + scaled_base; break;
		case glue_val: l = cur_val + skip_base; break;
		case mu_val: l = cur_val + mu_skip_base; break;
		}
	}
found:

	#pragma endregion
	if (q == _register)
		scan_optional_equals();
	else
		scan_keyword(TEX_STRING("by"));


	arith_error = false;
	if(q<multiply)
		#pragma region <Compute result of register or advance, put it in cur_val 1238>
		if (p < glue_val) {
			if (p == int_val) scan_int(); else scan_normal_dimen;
			if (q == advance) cur_val += eqtb[l].an_int;
		}
		else {
			scan_glue(p);
			if (q == advance)
				#pragma region <Compute the sum of two glue specs 1239>
			{
				q = new_spec(cur_val); r = equiv(l); delete_glue_ref(cur_val); width(q) += width(r);
				if (stretch(q) == 0) stretch_order(q) = normal;
				if (stretch_order(q) == stretch_order(r)) stretch(q) += stretch(r);
				else if (stretch_order(q) < stretch_order(r) && stretch(r) != 0) {
					stretch(q) = stretch(r); stretch_order(q) = stretch_order(r);
				}
				if (shrink(q) == 0) shrink_order(q) = normal;
				if (shrink_order(q) == shrink_order(r)) shrink(q) += shrink(r);
				else if (shrink_order(q) < shrink_order(r) && shrink(r) != 0) {
					shrink(q) = shrink(r); shrink_order(q) = shrink_order(r);
				}
				cur_val = q;
			}
				#pragma endregion
		}
		#pragma endregion
	else
		#pragma region <Compute result of multiply or divide, put it in cur_val 1240>
	{
		scan_int();
		if (p < glue_val)
			if (q == multiply)
				if (p == int_val) cur_val = mult_integers(eqtb[l].an_int, cur_val);
				else cur_val = nx_plus_y(eqtb[l].an_int, cur_val, 0);
			else cur_val = x_over_n(eqtb[l].an_int, cur_val);
		else {
			s = equiv(l); r = new_spec(s);
			if (q == multiply) {
				width(r) = nx_plus_y(width(s), cur_val, 0); stretch(r) = nx_plus_y(stretch(s), cur_val, 0);
				shrink(r) = nx_plus_y(shrink(s), cur_val, 0);
			}
			else {
				width(r) = x_over_n(width(s), cur_val); stretch(r) = x_over_n(stretch(s), cur_val);
				shrink(r) = x_over_n(shrink(s), cur_val);
			}
			cur_val = r;
		}
	}
		#pragma endregion
	if (arith_error) {
		print_err(TEX_STRING("Arithmetic overflow"));
		help2(TEX_STRING("I can't carry out that multiplication or division,"),
			TEX_STRING("since the result is out of range."));
		if (p >= glue_val) delete_glue_ref(cur_val);
		error();
		return;
	}
	if (p < glue_val) word_define(l, cur_val);
	else {
		trap_zero_glue(); define(l, glue_ref, cur_val);
	}
}

// 1275
void open_or_close_in()
{
	unsigned char c;
	unsigned char n;
	
	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment open_or_close_in\n");
		exit(1);
	}
	// ----
	
	c = (unsigned char)cur_chr; scan_four_bit_int(); n = cur_val;
	if (read_open[n] != closed) {
		a_close(read_file[n]); read_open[n] = closed;
	}
	if (c != 0) {
		scan_optional_equals();
		scan_file_name();
		if (cur_ext == TEX_STRING(""))
			cur_ext = TEX_STRING(".tex");
		pack_cur_name;
		if (a_open_in(&read_file[n], read_file_path)) read_open[n] = just_open;
	}
}

//1279
void issue_message()
{
	unsigned int old_setting;
	unsigned char c;
	str_number s;

	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment issue_message\n");
		exit(1);
	}
	//////////////////
	
	c = (unsigned char)cur_chr; link(garbage) = scan_toks(false, true); old_setting = selector;
	selector = new_string; token_show(def_ref); selector = old_setting;
	flush_list(def_ref); str_room(1);
	s = make_string();
	if (c == 0) 
		#pragma region <Print string s on the terminal 1280>
	{
		if (term_offset + length(s) > max_print_line - 2)
			print_ln();
		else if (term_offset > 0 || file_offset > 0)
			print_char(TEX_STRING(" "));
		slow_print(s); update_terminal();
	}
		#pragma endregion
	else 
		#pragma region <Print string s as an error message 1283>
	{
		print_err(TEX_STRING(""));
		slow_print(s);
		if (err_help != null) use_err_help = true;
		else if (long_help_seen)
			help1(TEX_STRING("(That was another \errmessage.)"));
		else {
			if (interaction < error_stop_mode) long_help_seen = true;
			help4(TEX_STRING("This error message was generated by an \errmessage"),
				TEX_STRING("command, so I can't give any explicit help."),
				TEX_STRING("Pretend that you're Hercule Poirot: Examine all clues,"),
				TEX_STRING("and deduce the truth by order and method."));
		}
		error();
		use_err_help = false;
	}
		#pragma endregion
	flush_string;
}

// 218
void show_activities()
{
	int p; // 0..nest_size
	short m; // -mmode..mmode
	memory_word a;
	pointer q, r;
	int t;

	nest[nest_ptr] = cur_list;
	print_nl(TEX_STRING("")); print_ln();
	for (p = nest_ptr; p >= 0; p--) {
		m = nest[p].mode_field; a = nest[p].aux_field; print_nl(TEX_STRING("### ")); print_mode(m);
		print(TEX_STRING(" entered at line ")); print_int(myabs(nest[p].ml_field));
		if(m==hmode)
			if (nest[p].pg_field != 040600000) {
				print(TEX_STRING(" (language")); print_int(nest[p].pg_field % 0200000); print(TEX_STRING(":hyphenmin"));
				print_int(nest[p].pg_field / 020000000); print_char(TEX_STRING(","));
				print_int((nest[p].pg_field / 0200000) % 0100); print_char(TEX_STRING(")"));
			}
		if (nest[p].ml_field < 0) print(TEX_STRING(" (\output routine)"));
		if (p == 0) {
			#pragma region <Show the status of the current page 986>
			if (page_head != page_tail) {
				print_nl(TEX_STRING("### current page:"));
				if (output_active) print(TEX_STRING(" (held over for next output)"));
				show_box(link(page_head));
				if (page_contents > empty) {
					print_nl(TEX_STRING("total height ")); print_totals(); print_nl(TEX_STRING(" goal height "));
					print_scaled(page_goal); r = link(page_ins_head);
					while (r != page_ins_head) {
						print_ln(); print_esc(TEX_STRING("insert")); t = qo(subtype(r)); print_int(t); print(TEX_STRING(" adds "));
						if (count(t) == 1000) t = height(r);
						else t = x_over_n(height(r), 1000)*count(t);
						print_scaled(t);
						if (type(r) == split_up) {
							q = page_head; t = 0;
							do {
								q = link(q);
								if (type(q) == ins_node && subtype(q) == subtype(r)) incr(t);
							} while (!(q == broken_ins(r)));
							print(TEX_STRING(", #")); print_int(t); print(TEX_STRING(" might split"));
						}
						r = link(r);
					}
				}
			}
			#pragma endregion
			if (link(contrib_head) != null) print_nl(TEX_STRING("### recent contributions:"));
		}
		show_box(link(nest[p].head_field));
		#pragma region <Show the auxiliary field 219>
		switch (myabs(m) / (max_command + 1)) {
		case 0:
			print_nl(TEX_STRING("prevdepth "));
			if (a.sc <= ignore_depth) print(TEX_STRING("ignored"));
			else print_scaled(a.sc);
			if (nest[p].pg_field != 0) {
				print(TEX_STRING(", prevgraf ")); print_int(nest[p].pg_field); print(TEX_STRING(" line"));
				if (nest[p].pg_field != 1) print_char(TEX_STRING("s"));
			}
			break;
		case 1:
			print_nl(TEX_STRING("spacefactor ")); print_int(a.hh.lh);
			if (m > 0) if (a.hh.rh > 0) {
				print(TEX_STRING(", current language ")); print_int(a.hh.rh);
			}
			break;
		case 2:
			if (a.an_int != null) {
				print(TEX_STRING("this will be denominator of:")); show_box(a.an_int);
			}
			break;
		}
		#pragma endregion

	}
}


// 1160
void scan_delimiter(pointer p, bool r)
{
	if (r) scan_twenty_seven_bit_int();
	else {
		#pragma region <Get the next non-blank non relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion

		switch (cur_cmd) {
		case letter:
		case other_char:
			cur_val = del_code(cur_chr);
			break;
		case delim_num:
			scan_twenty_seven_bit_int();
			break;
		default:
			cur_val = -1;
			break;
		}
	}
	if (cur_val < 0) 
		#pragma region <Report that an invalid delimiter code is beign changed to null set cur_val = 0 1161>
	{
		print_err(TEX_STRING("Missing delimiter (. inserted)"));
		help6(TEX_STRING("I was expecting to see something like `(' or `\{' or"),
			TEX_STRING("`\}' here. If you typed, e.g., `{' instead of `\{', you"),
			TEX_STRING("should probably delete the `{' by typing `1' now, so that"),
			TEX_STRING("braces don't get unbalanced. Otherwise just proceed."),
			TEX_STRING("Acceptable delimiters are characters whose \delcode is"),
			TEX_STRING("nonnegative, or you can use `\delimiter <delimiter code>'."));
		back_error();
		cur_val = 0;
	}
		#pragma endregion

	small_fam(p) = (cur_val / 04000000) % 16;
	small_char(p) = qi((cur_val / 010000) % 256);
	large_fam(p) = (cur_val / 256) % 16; large_char(p) = qi(cur_val % 256);
	
}

//1288
void shift_case()
{
	pointer b;
	pointer p;
	halfword t;
	eight_bits c;

	b = cur_chr; p = scan_toks(false, false); p = link(def_ref);
	while (p != null) {
		#pragma region <Change the case of the token in p, if a change is appropriate 1289>
		t = info(p);
		if (t < cs_token_flag + single_base) {
			c = t % 256;
			if (equiv(b + c) != 0) info(p) = t - c + equiv(b + c);
		}
		#pragma endregion
		p = link(p);
	}
	back_list(link(def_ref)); free_avail(def_ref);
}

// 280
void save_for_after(halfword t)
{
	if (cur_level > level_one) {
		check_full_save_stack;
		save_type(save_ptr) = insert_token; save_level(save_ptr) = level_zero;
		save_index(save_ptr) = t; incr(save_ptr);
	}
}

// 689
pointer new_choice()
{
	pointer p;
	p = get_node(style_node_size); type(p) = choice_node; subtype(p) = 0;
	display_mlist(p) = null; text_mlist(p) = null; script_mlist(p) = null; script_script_mlist(p) = null;
	return p;
}

// 1159
void math_limit_switch()
{
	// overflow check
	if (cur_chr > 255) {
		printf("Overflow assignment math_limit_switch\n");
		exit(1);
	}
	////////////////
	
	if(head!= tail)
		if (type(tail) == op_noad) {
			subtype(tail) = (quarterword)cur_chr;
			goto _exit;
		}
	print_err(TEX_STRING("Limit controls must follow a math operator"));
	help1(TEX_STRING("I'm ignoring this misplaced \limits or \nolimits command."));
	error();
_exit:
	;
}

// 1163
void math_radical()
{
	tail_append(get_node(radical_noad_size)); type(tail) = radical_noad; subtype(tail) = normal;
	mem[nucleus(tail)].hh = empty_field; mem[subscr(tail)].hh = empty_field;
	mem[supscr(tail)].hh = empty_field; scan_delimiter(left_delimiter(tail), true);
	scan_math(nucleus(tail));
}

// 1165
void math_ac()
{
	if (cur_cmd == accent) {
		//<Complain that the user should have said \mathaccent 1166>
		print_err(TEX_STRING("Please use "));
		print_esc(TEX_STRING("mathaccent"));
		print(TEX_STRING(" for accents in math mode"));
		help2(TEX_STRING("I'm changing \accent to \mathaccent here; wish me luck."),
			TEX_STRING("(Accents are not the same in formulas as they are in text.)"));
		error();
	}
	tail_append(get_node(accent_noad_size)); type(tail) = accent_noad; subtype(tail) = normal;
	mem[nucleus(tail)].hh = empty_field; mem[subscr(tail)].hh = empty_field;
	mem[supscr(tail)].hh = empty_field; math_type(accent_chr(tail)) = math_char;
	scan_fifteen_bit_int();
	character(accent_chr(tail)) = qi(cur_val % 256);
	if (cur_val >= var_code && fam_in_range) fam(accent_chr(tail)) = cur_fam;
	else fam(accent_chr(tail)) = (cur_val / 256) % 16;
	scan_math(nucleus(tail));
}

// 1172
void append_choices()
{
	tail_append(new_choice()); incr(save_ptr); saved(-1) = 0; push_math(math_choice_group);
	scan_left_brace();
}

// 1176
void sub_sup()
{
	small_number t;
	pointer p;
	t = empty; p = null;
	if(tail != head)
		if (scripts_allowed(tail)) {
			p = supscr(tail) + cur_cmd - sup_mark;
			t = math_type(p);
		}
	if (p == null || t != empty) 
		#pragma region <Insert a dummy noad to be sub/superscripted 1177>
	{
		tail_append(new_noad()); p = supscr(tail) + cur_cmd - sup_mark;
		if (t != empty) {
			if (cur_cmd == sup_mark) {
				print_err(TEX_STRING("Double superscript"));
				help1(TEX_STRING("I treat `x^1^2' essentially like `x^1{}^2'."));
			}
			else {
				print_err(TEX_STRING("Double subscript"));
				help1(TEX_STRING("I treat `x_1_2' essentially like `x_1{}_2'."));
			}
			error();
		}
	}
		#pragma endregion

	scan_math(p);
	
}

// 1181
void math_fraction()
{
	small_number c;
	c = cur_chr;
	if (incompleat_noad != null) 
		#pragma region <Ignore the fraction operation and complain about this ambiguous case 1183>
	{
		if (c >= delimited_code) {
			scan_delimiter(garbage, false); scan_delimiter(garbage, false);
		}
		if (c % delimited_code == above_code) scan_normal_dimen;
		print_err(TEX_STRING("Ambiguous; you need another { and }"));
		help3(TEX_STRING("I'm ignoring this fraction specification, since I don't"),
			TEX_STRING("know whether a construction like `x \over y \over z'"),
			TEX_STRING("means `{x \over y} \over z' or `x \over {y \over z}'."));
		error();
	}
		#pragma endregion
	else {
		incompleat_noad = get_node(fraction_noad_size); type(incompleat_noad) = fraction_noad;
		subtype(incompleat_noad) = normal; math_type(numerator(incompleat_noad)) = sub_mlist;
		info(numerator(incompleat_noad)) = link(head);
		mem[denominator(incompleat_noad)].hh = empty_field;
		mem[left_delimiter(incompleat_noad)].qqqq = null_delimiter;
		mem[right_delimiter(incompleat_noad)].qqqq = null_delimiter;
		link(head) = null; tail = head;
		#pragma region <Use code c to distinguish between generalized fraction 1182>
		if (c >= delimited_code) {
			scan_delimiter(left_delimiter(incompleat_noad), false);
			scan_delimiter(right_delimiter(incompleat_noad), false);
		}
		switch (c % delimited_code) {
		case above_code:
			scan_normal_dimen; thickness(incompleat_noad) = cur_val;
			break;
		case over_code:
			thickness(incompleat_noad) = default_code;
			break;
		case atop_code:
			thickness(incompleat_noad) = 0;
			break;
		}
		#pragma endregion
	}
}

// 1270
void do_assignments()
{
	while (1) {
		#pragma region <Get the next non-blank non-relax non-call token 404>
		do
		{
			get_x_token();
		} while (!(cur_cmd != spacer && cur_cmd != relax));
		#pragma endregion
		if (cur_cmd <= max_non_prefixed_command) return;
		set_box_allowed = false; prefixed_command(); set_box_allowed = true;
	}
}


//1191
void math_left_right()
{
	small_number t;
	pointer p;

	t = cur_chr;
	if (t == right_noad && cur_group != math_left_group) 
		#pragma region < Try to recover from mismatched right 1192>
	{
		if (cur_group == math_shift_group) {
			scan_delimiter(garbage, false); print_err(TEX_STRING("Extra "));
			print_esc(TEX_STRING("right"));
			help1(TEX_STRING("I'm ignoring a \right that had no matching \left."));
			error();
		}
		else off_save();
	}
		#pragma endregion
	else {
		p = new_noad(); type(p) = t; scan_delimiter(delimiter(p), false);
		if (t == left_noad) {
			push_math(math_left_group); link(head) = p; tail = p;
		}
		else {
			p = fin_mlist(p); unsave();
			tail_append(new_noad()); type(tail) = inner_noad; math_type(nucleus(tail)) = sub_mlist;
			info(nucleus(tail)) = p;
		}
	}
}

// 296
void print_meaning()
{
	print_cmd_chr(cur_cmd, cur_chr);
	if (cur_cmd >= call) {
		print_char(TEX_STRING(":")); print_ln(); token_show(cur_chr);
	}
	else if (cur_cmd == top_bot_mark) {
		print_char(TEX_STRING(":")); print_ln(); token_show(cur_mark[cur_chr]);
	}
}

// 1293
void show_whatever()
{
	//pointer p; // This variable is not used
	switch (cur_chr) {
	case show_lists:
		begin_diagnostic();
		show_activities();
		break;

	case show_box_code:
		//<Show the current contents of a box 1296>
		scan_eight_bit_int();
		begin_diagnostic();
		print_nl(TEX_STRING("> \box")); print_int(cur_val); print_char(TEX_STRING("="));
		if (box(cur_val) == null) print(TEX_STRING("void"));
		else show_box(box(cur_val));
		break;

	case show_code:
		//<Show the current meaning of a token, then goto common_ending 1294>
		get_token();
		if (interaction == error_stop_mode) wake_up_terminal();
		print_nl(TEX_STRING("> "));
		if (cur_cs != 0) {
			sprint_cs(cur_cs); print_char(TEX_STRING("="));
		}
		print_meaning();
		goto common_ending;
		break;
	default:
		//<Show the current value of some parameter or register, then goto common_ending 1297>
		the_toks();
		if (interaction == error_stop_mode) wake_up_terminal();
		print_nl(TEX_STRING("> ")); token_show(temp_head);
		flush_list(link(temp_head));
		goto common_ending;
		break;
	}
	#pragma region <Complete a potentially long show command 1298>
	end_diagnostic(true); print_err(TEX_STRING("OK"));
	if(selector == term_and_log)
		if (tracing_online) {
			selector = term_only;
			print(TEX_STRING(" (see the transcript file)"));
			selector = term_and_log;
		}
	#pragma endregion
common_ending:
	if (interaction < error_stop_mode) {
		help0; decr(error_count);
	}
	else if (tracing_online > 0) {
		help3(TEX_STRING("This isn't an error message; I'm just \showing something."),
			TEX_STRING("Type `I\show...' to show more (e.g., \show\cs,"),
			TEX_STRING("\showthe\count10, \showbox255, \showlists)."));
	}
	else {
		help5(TEX_STRING("This isn't an error message; I'm just \showing something."),
			TEX_STRING("Type `I\show...' to show more (e.g., \show\cs,"),
			TEX_STRING("\showthe\count10, \showbox255, \showlists)."),
			TEX_STRING("And type `I\tracingonline=1\show...' to show boxes and"),
			TEX_STRING("lists on your terminal as well as in the transcript file."));
	}
	error();
}

// 1047
void insert_dollar_sign()
{
	back_input(); cur_tok = math_shift_token + TEX_STRING("$");
	print_err(TEX_STRING("Missing $ inserted"));
	help2(TEX_STRING("I've inserted a begin-math/end-math symbol since I think"),
		TEX_STRING("you left one out. Proceed, with fingers crossed."));
	ins_error();
}

// 1084
void scan_box(int box_context)
{
	#pragma region <Get the next non-blank non relax non-call token 404>
	do
	{
		get_x_token();
	} while (!(cur_cmd != spacer && cur_cmd != relax));
	#pragma endregion

	if (cur_cmd == make_box) begin_box(box_context);
	else if (box_context >= leader_flag && (cur_cmd == hrule || cur_cmd == vrule)) {
		cur_box = scan_rule_spec(); box_end(box_context);
	}
	else {
		print_err(TEX_STRING("A <box> was supposed to be here"));
		help3(TEX_STRING("I was expecting to see \hbox or \vbox or \copy or \box or"),
			TEX_STRING("something like that. So you might find something missing in"),
			TEX_STRING("your output. But keep trying; you can fix this later."));
		back_error();
	}
}

// 1303
bool load_fmt_file()
{
	int j, k;
	pointer p, q;
	int x;
	four_quarters w;

	#pragma region <Undump constants for consistency check 1308>
	fread(&x, sizeof x, 1, fmt_file);
	if (x != @$) goto bad_fmt;
	undump_int(&x);
	if (x != mem_bot) goto bad_fmt;
	undump_int(&x);
	if (x != mem_top) goto bad_fmt;
	undump_int(&x);
	if (x != eqtb_size) goto bad_fmt;
	undump_int(&x);
	if (x != hash_prime) goto bad_fmt;
	undump_int(&x);
	if (x != hyph_size) goto bad_fmt;
	#pragma endregion

	#pragma region <Undump the string pool 1310>
	undump_size(0, pool_size, "string pool size", pool_ptr);
	undump_size(0, max_strings, "max strings", str_ptr);
	for (k = 0; k <= str_ptr; k++)
		undump(0, pool_ptr, str_start[k]);
	k = 0;
	while (k + 4 < pool_ptr) {
		undump_four_ASCII; k += 4;
	}
	k = pool_ptr - 4; undump_four_ASCII; init_str_ptr = str_ptr; init_pool_ptr = pool_ptr;

	#pragma endregion

	#pragma region <Undump the dynamic memory 1312>
	undump(lo_mem_stat_max + 1000, hi_mem_stat_min - 1, lo_mem_max);
	undump(lo_mem_stat_max + 1, lo_mem_max, rover); p = mem_bot; q = rover;
	do {
		for (k = p; k <= q + 1; k++) undump_wd(&mem[k]);
		p = q + node_size(q);
		if (p > lo_mem_max || (q >= rlink(q) && rlink(q) != rover)) goto bad_fmt;
		q = rlink(q);
	} while (!(q == rover));
	for (k = p; k <= lo_mem_max; k++) undump_wd(&mem[k]);
	if (mem_min < mem_bot - 2) {
		p = llink(rover); q = mem_min + 1; link(mem_min) = null;
		info(mem_min) = null;
		rlink(p) = q; llink(rover) = q;
		rlink(q) = rover; llink(q) = p; link(q) = empty_flag; node_size(q) = mem_bot - q;
	}
	undump(lo_mem_max + 1, hi_mem_stat_min, hi_mem_min);
	undump(null, mem_top, avail);
	mem_end = mem_top;
	for (k = hi_mem_min; k <= mem_end; k++) undump_wd(&mem[k]);
	undump_int(&var_used); undump_int(&dyn_used);
	#pragma endregion

	#pragma region <Undump the table of equivalents 1314>
	#pragma region <Undump regions 1 to 6 of eqtb 1317>
	k = active_base;
	do {
		undump_int(&x);
		if (x<1 || k + x > eqtb_size + 1) goto bad_fmt;
		for (j = k; j <= k + x - 1; j++) undump_wd(&eqtb[j]);
		k += x; undump_int(&x);
		if (x<0 || k + x > eqtb_size + 1) goto bad_fmt;
		for (j = k; j <= k + x - 1; j++) eqtb[j] = eqtb[k - 1];
		k += x;
	} while (!(k > eqtb_size));
	#pragma endregion


	undump(hash_base, frozen_control_sequence, par_loc); par_token = cs_token_flag + par_loc;
	undump(hash_base, frozen_control_sequence, write_loc);

	#pragma region Undump the hash table 1319>
	undump(hash_base, frozen_control_sequence, hash_used); p = hash_base - 1;
	do {
		undump(p + 1, hash_used, p); undump_hh(&hash[p]);
	} while (!(p == hash_used));
	for (p = hash_used + 1; p <= undefined_control_sequence - 1; p++) undump_hh(&hash[p]);
	undump_int(&cs_count);
	#pragma endregion

	#pragma endregion

	#pragma region <Undump the font information 1321>
	undump_size(7, font_mem_size, "font mem size", fmem_ptr);
	for (k = 0; k <= fmem_ptr - 1; k++) undump_wd(&font_info[k]);
	undump_size(font_base, font_max, "font max", font_ptr);
	for (k = null_font; k <= font_ptr; k++)
		#pragma region <Undump the array info for internal font number k 1323>
	{
		
		undump_qqqq(&font_check[k]);
		undump_int(&font_size[k]); undump_int(&font_dsize[k]);
		undump(min_halfword, max_halfword, font_params[k]);
		undump_int(&hyphen_char[k]); undump_int(&skew_char[k]);
		undump(0, str_ptr, font_name[k]); undump(0, str_ptr, font_area[k]);
		undump(0, 255, font_bc[k]); undump(0, 255, font_ec[k]);
		undump_int(&char_base[k]); undump_int(&width_base[k]); undump_int(&height_base[k]);
		undump_int(&depth_base[k]); undump_int(&italic_base[k]); undump_int(&lig_kern_base[k]);
		undump_int(&kern_base[k]); undump_int(&exten_base[k]); undump_int(&param_base[k]);
		undump(min_halfword, lo_mem_max, font_glue[k]); 
		undump(0, fmem_ptr - 1, bchar_label[k]);  undump(min_quarterword, non_char, font_bchar[k]);
		undump(min_quarterword, non_char, font_false_bchar[k]);
	}
		#pragma endregion

	#pragma endregion

	#pragma region <Undump the hyphenation tables 1325>
	undump(0, hyph_size, hyph_count);
	for (k = 1; k <= hyph_count; k++) {
		undump(0, hyph_size, j); undump(0, str_ptr, hyph_word[j]);
		undump(min_halfword, max_halfword, hyph_list[j]);
	}
	undump_size(0, trie_size, "trie size", j);
	//init
#ifndef NO_INIT
	trie_max = j;
#endif
	//tini

	for (k = 0; k <= j; k++) undump_hh(&trie[k]);
	undump_size(0, trie_op_size, "trie op size", j);
	//init
#ifndef NO_INIT
	trie_op_ptr = j;
#endif
	//tini

	for (k = 1; k <= j; k++) {
		undump(0, 63, hyf_distance[k]);
		undump(0, 63, hyf_num[k]); undump(min_quarterword, max_quarterword, hyf_next[k]);
	}
	//init
#ifndef NO_INIT
	for (k = 0; k <= 255; k++) trie_used[k] = min_quarterword;
#endif
	//tini
	k = 256;
	while (j > 0) {
		undump(0, k - 1, k); undump(1, j, x);
		//init
#ifndef NO_INIT
		trie_used[k] = qi(x);
#endif
		//tini

		j = j - x; op_start[k] = qo(j);
	}
	//init
#ifndef NO_INIT
	trie_not_ready = false;
#endif
	//tini
	#pragma endregion



	#pragma region <Undump a couple of more things and the closing check word 1327>
	undump(batch_mode, error_stop_mode, interaction); undump(0, str_ptr, format_ident); undump_int(&x);
	if (x != 69069 || feof(fmt_file)) goto bad_fmt;
	#pragma endregion



	return true;

bad_fmt:
	wake_up_terminal(); wterm_ln_s("(Fatal format file error; I'm stymied)");
	return false;
}


// 1349
void new_whatsit(small_number s, small_number w)
{
	pointer p;
	p = get_node(w); type(p) = whatsit_node; subtype(p) = s; link(tail) = p; tail = p;
}



// 1350
void new_write_whatsit(small_number w)
{
	new_whatsit(cur_chr, w);
	if (w != write_node_size)
		scan_four_bit_int();
	else {
		scan_int();
		if (cur_val < 0)
			cur_val = 17;
		else if (cur_val > 15)
			cur_val = 16;
	}
	write_stream(tail) = cur_val;
}

// 1355
void print_write_whatsit(str_number s, pointer p)
{
	print_esc(s);
	if (write_stream(p) < 16) print_int(write_stream(p));
	else if (write_stream(p) == 16) print_char(TEX_STRING("*"));
	else print_char(TEX_STRING("-"));
}


// 1368
void special_out(pointer p)
{
	unsigned int old_setting;
	pool_pointer k;

	synch_h; synch_v;

	old_setting = selector; selector = new_string;
	show_token_list(link(write_tokens(p)), null, pool_size - pool_ptr); selector = old_setting; str_room(1);
	if (cur_length < 256) {
		dvi_out(dvi_op::xxx1); dvi_out(cur_length);
	}
	else {
		dvi_out(dvi_op::xxx4); dvi_four(cur_length);
	}
	for (k = str_start[str_ptr]; k <= pool_ptr - 1; k++)
		dvi_out(so(str_pool[k]));
	pool_ptr = str_start[str_ptr];
}

//1370
void write_out(pointer p)
{
	unsigned int old_setting;
	int old_mode;
	small_number j;
	pointer q, r;

	#pragma region <Expand macros in the token list and make link(def_ref) point to the result 1371>
	q = get_avail(); info(q) = right_brace_token + TEX_STRING("}");
	r = get_avail(); link(q) = r; info(r) = end_write_token; ins_list(q);
	begin_token_list(write_tokens(p), write_text);
	q = get_avail(); info(q) = left_brace_token + TEX_STRING("{"); ins_list(q);
	old_mode = mode; mode = (mode_type)0;
	cur_cs = write_loc; q = scan_toks(false, true);
	get_token(); 
	if (cur_tok != end_write_token)
		#pragma region <Recover from an unbalanced write command 1372>
	{
		print_err(TEX_STRING("Unbalanced write command"));
		help2(TEX_STRING("On this page there's a \write with fewer real {'s than }'s."),
			TEX_STRING("I can't handle that very well; good luck."));
		error();
		do {
			get_token();
		} while (!(cur_tok == end_write_token));
	}
		#pragma endregion
	mode = (mode_type)old_mode; end_token_list();
	#pragma endregion

	old_setting = selector; j = write_stream(p);
	if (write_open[j]) selector = j;
	else {
		if (j == 17 && selector == term_and_log)
			selector = log_only;
		print_nl(TEX_STRING(""));
	}
	token_show(def_ref); print_ln(); flush_list(def_ref); selector = old_setting;
}

// 1373
void out_what(pointer p)
{
	small_number j;
	switch (subtype(p)) {
	case open_node:
	case write_node:
	case close_node:
		#pragma region <Do some work that has been queued up for write 1374>
		if (!doing_leaders) {
			j = write_stream(p);
			if (subtype(p) == write_node) write_out(p);
			else {
				if (write_open[j]) a_close(write_file[j]);
				if (subtype(p) == close_node) write_open[j] = false;
				else if (j < 16) {
					cur_name = open_name(p); cur_area = open_area(p); cur_ext = open_ext(p);
					if (cur_ext == TEX_STRING(""))
						cur_ext = TEX_STRING(".tex");
					pack_cur_name;
					while (!a_open_out(&write_file[j]))
						prompt_file_name(TEX_STRING("output file name"),
							TEX_STRING(".tex"));
					write_open[j] = true;
				}
			}
		}
		#pragma endregion
		break;
	case special_node:
		special_out(p);
		break;
	case language_node:
		//do_nothing
		break;

	default:
		confusion(TEX_STRING("ext4"));
		break;
	}
}


// 1348
void do_extension()
{
	//int i; 
	//int j;
	int k;
	pointer p;
	//pointer q;
	//pointer r;

	switch (cur_chr) {
	case open_node:
		#pragma region <Implement openout 1351>
		new_write_whatsit(open_node_size);
		scan_optional_equals();
		scan_file_name();
		open_name(tail) = cur_name; open_area(tail) = cur_area; open_ext(tail) = cur_ext;
		#pragma endregion
		break;
	case write_node:
		#pragma region <Implement write 1352>
		k = cur_cs; new_write_whatsit(write_node_size);
		cur_cs = k; p = scan_toks(false, false); write_tokens(tail) = def_ref;
		#pragma endregion
		break;
	case close_node:
		#pragma region <Implement closeout 1353>
		new_write_whatsit(write_node_size);
		write_tokens(tail) = null;
		#pragma endregion
		break;
	case special_node:
		#pragma region <Implement special 1354>
		new_whatsit(special_node, write_node_size); write_stream(tail) = null; p = scan_toks(false, true);
		write_tokens(tail) = def_ref;
		#pragma endregion
		break;
	case immediate_code:
		#pragma region <Implement immediate 1375>
		get_x_token();
		if (cur_cmd == extension && cur_chr <= close_node) {
			p = tail; do_extension();
			out_what(tail);
			flush_node_list(tail); tail = p; link(p) = null;
		}
		else
			back_input();
		#pragma endregion
		break;
	case set_language_code:
		#pragma region <Implement setlanguge 1377>
		if (myabs(mode) != hmode)
			report_illegal_case();
		else {
			new_whatsit(language_node, small_node_size);
			scan_int();
			if (cur_val <= 0)
				clang = 0;
			else if (cur_val > 255)
				clang = 0;
			else
				clang = cur_val;
			what_lang(tail) = clang; what_lhm(tail) = norm_min(left_hyphen_min);
			what_rhm(tail) = norm_min(right_hyphen_min);
		}
		#pragma endregion
		break;

	default:
		confusion(TEX_STRING("ext1"));
		break;
	}
}

//1079
void begin_box(int box_context)
{
	pointer p, q;
	quarterword m;
	halfword k;
	eight_bits n;

	switch (cur_chr) {
	case box_code:
		scan_eight_bit_int();
		cur_box = box(cur_val);
		box(cur_val) = null;
		break;
	case copy_code:
		scan_eight_bit_int(); cur_box = copy_node_list(box(cur_val));
		break;
	case last_box_code:
		#pragma region <If the current list ends with a box node delete it from the list and make cur_box point to it; otherwise set cur_box = null 1080>
		cur_box = null;
		if (myabs(mode) == mmode) {
			you_cant(); help1(TEX_STRING("Sorry; this \lastbox will be void."));
			error();
		}
		else if (mode == vmode && head == tail) {
			you_cant(); 
			help2(TEX_STRING("Sorry...I usually can't take things from the current page."),
				TEX_STRING("This \lastbox will therefore be void."));
			error();
		}
		else {
			if(!is_char_node(tail))
				if (type(tail) == hlist_node || type(tail) == vlist_node) 
					#pragma region <Remove the last box, unless its part of discretionary 1081>
				{
					q = head;
					do {
						p = q;
						if(!is_char_node(q))
							if (type(q) == disc_node) {
								for (m = 1; m <= replace_count(q); m++) p = link(p);

								if (p == tail) goto done;
							}
						q = link(p);
					} while (!(q == tail));
					cur_box = tail; shift_amount(cur_box) = 0; tail = p; link(p) = null;
				done:
					;
				}
					#pragma endregion
		}
		#pragma endregion
		break;
	case vsplit_code:
		#pragma region <Split off part of a vertical box, make cur_box point to it 1082>
		scan_eight_bit_int(); n = cur_val;
		if (!scan_keyword(TEX_STRING("to"))) {
			print_err(TEX_STRING("Missing `to' inserted"));
			help2(TEX_STRING("I'm working on `\vsplit<box number> to <dimen>';"),
				TEX_STRING("will look for the <dimen> next."));
			error();
		}
		scan_normal_dimen; cur_box = vsplit(n, cur_val);
		#pragma endregion
		break;
	default:
		#pragma region <Initiate the construction of an hbox or vbox, then return 1083>
		k = cur_chr - vtop_code; saved(0) = box_context;
		if (k == hmode)
			if (box_context < box_flag && myabs(mode) == vmode) scan_spec(adjusted_hbox_group, true);
			else scan_spec(hbox_group, true);
		else {
			if (k == vmode) scan_spec(vbox_group, true);
			else {
				scan_spec(vtop_group, true); k = vmode;
			}
			normal_paragraph();
		}
		push_nest(); mode = (mode_type)-k;
		if (k == vmode) {
			prev_depth = ignore_depth;
			if (every_vbox != null) begin_token_list(every_vbox, every_vbox_text);
		}
		else {
			space_factor = 1000;
			if (every_hbox != null) begin_token_list(every_hbox, every_hbox_text);
		}
		return;
		#pragma endregion
		break;

	}
	box_end(box_context);
}

// 1070
void normal_paragraph()
{
	if (looseness != 0) eq_word_define(int_base + looseness_code, 0);
	if (hang_indent != 0) eq_word_define(dimen_base + hang_indent_code, 0);
	if (hang_after != 1) eq_word_define(int_base + hang_after_code, 1);
	if (par_shape_ptr != null) eq_define(par_shape_loc, shape_ref, null);
}

// 1091
// 1091
small_number norm_min(int h)
{
	if (h <= 0)
		return 1;
	else if (h >= 63)
		return 63;
	else
		return h;
}

void new_graf(bool indented)
{
	prev_graf = 0;
	if (mode == vmode || head != tail) tail_append(new_param_glue(par_skip_code));
	push_nest(); mode = hmode; space_factor = 1000; set_cur_lang; clang = cur_lang;
	prev_graf = (norm_min(left_hyphen_min) * 0100 + norm_min(right_hyphen_min)) * 0200000 + cur_lang;
	if (indented) {
		tail = new_null_box(); link(head) = tail; width(tail) = par_indent;
	}
	if (every_par != null) begin_token_list(every_par, every_par_text);
	if (nest_ptr == 1) build_page();
}

// 1093
void indent_in_hmode()
{
	pointer p, q;
	if (cur_chr > 0) {
		p = new_null_box(); width(p) = par_indent;
		if (myabs(mode) == hmode) space_factor = 1000;
		else {
			q = new_noad(); math_type(nucleus(q)) = sub_box; info(nucleus(q)) = p; p = q;
		}
		tail_append(p);
	}
}

//791
bool fin_col()
{
	pointer p;
	pointer q, r;
	pointer s;
	pointer u;
	scaled w;
	glue_ord o;
	halfword n;

	if (cur_align == null) confusion(TEX_STRING("endv"));
	q = link(cur_align); if (q == null) confusion(TEX_STRING("endv"));
	if (align_state < 500000) fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
	p = link(q);
	#pragma region <If the preamble list has been traversed, check that the row has ended 792>
	if(p == null && extra_info(cur_align) < cr_code)
		if (cur_loop != null)
			#pragma region <Lengthen the preamble periodically 793>
		{
			link(q) = new_null_box(); p = link(q);
			info(p) = end_span; width(p) = null_flag; cur_loop = link(cur_loop);
			#pragma region <Copy the templates from node cur_loop into node p 794>
			q = hold_head; r = u_part(cur_loop);
			while (r != null) {
				link(q) = get_avail(); q = link(q); info(q) = info(r); r = link(r);
			}
			link(q) = null; u_part(p) = link(hold_head); q = hold_head; r = v_part(cur_loop);
			while (r != null) {
				link(q) = get_avail(); q = link(q); info(q) = info(r); r = link(r);
			}
			link(q) = null; v_part(p) = link(hold_head);
			#pragma endregion

			cur_loop = link(cur_loop); link(p) = new_glue(glue_ptr(cur_loop));
		}
			#pragma endregion
		else {
			print_err(TEX_STRING("Extra alignment tab has been changed to ")); print_esc(TEX_STRING("cr"));
			help3(TEX_STRING("You have given more \span or & marks than there were"),
				TEX_STRING("in the preamble to the \halign or \valign now in progress."),
				TEX_STRING("So I'll assume that you meant to type \cr instead."));
			extra_info(cur_align) = cr_code;
			error();
		}

	#pragma endregion

	if (extra_info(cur_align) != span_code) {
		unsave(); new_save_level(align_group);
		#pragma region <Package an unset box for the current column and record its width 796>
		{
			if (mode == -hmode) {
				adjust_tail = cur_tail; u = hpack(link(head), 0, additional); w = width(u); cur_tail = adjust_tail;
				adjust_tail = null;
			}
			else {
				u = vpackage(link(head), 0, additional, 0); w = height(u);
			}
			n = min_quarterword;
			if (cur_span != cur_align)
				#pragma region<Update width entry for spanned columns 798>
			{
				q = cur_span;
				do {
					incr(n); q = link(link(q));
				} while (!(q == cur_align));
				if (n > max_quarterword) confusion(TEX_STRING("256 spans"));
				q = cur_span;
				while (link(info(q)) < n) q = info(q);
				if (link(info(q)) > n) {
					s = get_node(span_node_size); info(s) = info(q); link(s) = n; info(q) = s; width(s) = w;
				}
				else if (width(info(q)) < w) width(info(q)) = w;
			}
				#pragma endregion

			else if (w > width(cur_align)) width(cur_align) = w;

			//overflow check
			if (n > 255) {
				printf("overflow assignment fin_col 796\n");
				exit(1);
			}
			//--------------------------
			
			type(u) = (quarterword)unset_node; span_count(u) = (quarterword)n;
			#pragma region <Determine the stretch order 659>
			if (total_stretch[filll] != 0) o = filll;
			else if (total_stretch[fill] != 0) o = fill;
			else if (total_stretch[fil] != 0) o = fil;
			else o = normal;
			#pragma endregion
			glue_order(u) = o; glue_stretch(u) = total_stretch[o];
			#pragma region <Determine the shrink order 665>
			if (total_shrink[filll] != 0) o = filll;
			else if (total_shrink[fill] != 0) o = fill;
			else if (total_shrink[fil] != 0) o = fil;
			else o = normal;
			#pragma endregion
			glue_sign(u) = o; glue_shrink(u) = total_shrink[o];
			pop_nest(); link(tail) = u; tail = u;
		}
		#pragma endregion

		#pragma region <Copy the tabskip glue between columns 795>
		tail_append(new_glue(glue_ptr(link(cur_align)))); subtype(tail) = tab_skip_code + 1;
		#pragma endregion
		if (extra_info(cur_align) >= cr_code) {
			return true;
		}
		init_span(p);
	}
	align_state = 1000000;
	#pragma region <Get the next non-blank non-call token 406>
	do {
		get_x_token();
	} while (!(cur_cmd != spacer));
	#pragma endregion

	cur_align = p; init_col();
	return false;
}

//799
void fin_row()
{
	pointer p;
	if (mode == -hmode) {
		p = hpack(link(head), 0, additional); pop_nest(); append_to_vlist(p);
		if (cur_head != cur_tail) {
			link(tail) = link(cur_head); tail = cur_tail;
		}
	}
	else {
		p = vpack(link(head), 0, additional); pop_nest(); link(tail) = p; tail = p; space_factor = 1000;
	}
	type(p) = unset_node; glue_stretch(p) = 0;
	if (every_cr != null) begin_token_list(every_cr, every_cr_text);
	align_peek();
}


// 1030
void main_control()
{
	int t;
	if (every_job != null)
		begin_token_list(every_job, every_job_text);
big_switch:
	get_x_token();
reswitch:
	#pragma region <Give diagnostic information, if requested 1031>
	if (interrupt != 0) {
		if (OK_to_interrupt) {
			back_input();
			check_interrupt;
			goto big_switch;
		}
	}
	//debug
#ifndef NO_DEBUG
	if (panicking)
		check_mem(false);
#endif		
	//gubed
	if (tracing_commands > 0)
		show_cur_cmd_chr();
	#pragma endregion

	switch (myabs(mode) + cur_cmd) {
	case hmode + letter:
	case hmode + other_char:
	case hmode + char_given:
		goto main_loop;
		break;
	case hmode + char_num:
		scan_char_num();
		cur_chr = cur_val;
		goto main_loop;
		break;
	case hmode + no_boundary:
		get_x_token();
		if (cur_cmd == letter || cur_cmd == other_char || cur_cmd == char_given || cur_cmd == char_num)
			cancel_boundary = true;
		goto reswitch;
		break;
	case hmode + spacer:
		if (space_factor == 1000)
			goto append_normal_space;
		else
			app_space();
		break;
	case hmode + ex_space:
	case mmode + ex_space:
		goto append_normal_space;
		break;
		
	#pragma region <Cases of main_control that are not part of the inner loop 1045>
	case any_mode(relax):
	case vmode+spacer:
	case mmode+spacer:
	case mmode+no_boundary:
		break;
	case any_mode(ignore_spaces):
		#pragma region <Get the next non_blank non-call token 406>
		do {
			get_x_token();
		} while (!(cur_cmd != spacer));
		#pragma endregion
		goto reswitch;
		break;
	case vmode+stop:
		if (its_all_over())
			return;
		break;

	#pragma region <Forbidden cases detected in main_control 1048>
	case vmode+vmove:
	case hmode+hmove:
	case mmode+hmove:
	case any_mode(last_item):
		// 1098
	case vmode+vadjust:
		//1111
	case vmode+ital_corr:
		//1144
	case non_math(eq_no):
	#pragma endregion

	case any_mode(mac_param):
		report_illegal_case();
		break;

	#pragma region <Math-only cases in non-math modes or vice versa 1046>
	case non_math(sup_mark):
	case non_math(sub_mark):
	case non_math(math_char_num):
	case non_math(math_given):
	case non_math(math_comp):
	case non_math(delim_num):
	case non_math(left_right):
	case non_math(above):
	case non_math(radical):
	case non_math(math_style):
	case non_math(math_choice):
	case non_math(vcenter):
	case non_math(non_script):
	case non_math(mkern):
	case non_math(limit_switch):
	case non_math(mskip):
	case non_math(math_accent):
	case mmode+endv:
	case mmode+par_end:
	case mmode+stop:
	case mmode+vskip:
	case mmode+un_vbox:
	case mmode+valign:
	case mmode+hrule:
		insert_dollar_sign();
		break;
	#pragma endregion

	#pragma region <Cases of main_control that build boxes and lists 1056>
	case vmode+hrule:
	case hmode+vrule:
	case mmode+vrule:
		tail_append(scan_rule_spec());
		if (myabs(mode) == vmode)
			prev_depth = ignore_depth;
		else if (myabs(mode) == hmode)
			space_factor = 1000;
		break;
	// 1057
	case vmode+vskip:
	case hmode+hskip:
	case mmode+hskip:
	case mmode+mskip:
		append_glue();
		break;
	case any_mode(kern):
	case mmode+mkern:
		append_kern();
		break;

		//1063
	case non_math(left_brace):
		new_save_level(simple_group);
		break;
	case any_mode(begin_group):
		new_save_level(semi_simple_group);
		break;
	case any_mode(end_group):
		if (cur_group == semi_simple_group)
			unsave();
		else off_save();
		break;

		//1067
	case any_mode(right_brace):
		handle_right_brace();
		break;

		// 1073
	case vmode+hmove:
	case hmode+vmove:
	case mmode+vmove:
		t = cur_chr; scan_normal_dimen;
		if (t == 0)
			scan_box(cur_val);
		else
			scan_box(-cur_val);
		break;
	case any_mode(leader_ship):
		scan_box(leader_flag - a_leaders + cur_chr);
		break;
	case any_mode(make_box):
		begin_box(0);
		break;

		// 1090
	case vmode+start_par:
		new_graf(cur_chr > 0);
		break;
	case vmode+letter:
	case vmode+other_char:
	case vmode+char_num:
	case vmode+char_given:
	case vmode+math_shift:
	case vmode+un_hbox:
	case vmode+vrule:
	case vmode+accent:
	case vmode+discretionary:
	case vmode+hskip:
	case vmode+valign:
	case vmode+ex_space:
	case vmode+no_boundary:
		back_input();
		new_graf(true);
		break;

		// 1092
	case hmode+start_par:
	case mmode+start_par:
		indent_in_hmode();
		break;

		// 1094
	case vmode+par_end:
		normal_paragraph();
		if (mode > 0)
			build_page();
		break;
	case hmode+par_end:
		if (align_state < 0)
			off_save();
		end_graf();
		if (mode == vmode)
			build_page();
		break;
	case hmode+stop:
	case hmode+vskip:
	case hmode+hrule:
	case hmode+un_vbox:
	case hmode+halign:
		head_for_vmode();
		break;

		//1097
	case any_mode(insert):
	case hmode+vadjust:
	case mmode+vadjust:
		begin_insert_or_adjust();
		break;
	case any_mode(mark):
		make_mark();
		break;

		// 1102
	case any_mode(break_penalty):
		append_penalty();
		break;

	case any_mode(remove_item):
		delete_last();
		break;

		// 1109
	case vmode+un_vbox:
	case hmode+un_hbox:
	case mmode+un_hbox:
		unpackage();
		break;

		//1112
	case hmode+ital_corr:
		append_italic_correction();
		break;
	case mmode+ital_corr:
		tail_append(new_kern(0));
		break;

		//1116
	case hmode+discretionary:
	case mmode+discretionary:
		append_discretionary();
		break;

	case hmode+accent:
		make_accent();
		break;

		// 1126
	case any_mode(car_ret):
	case any_mode(tab_mark):
		align_error();
		break;
	case any_mode(no_align):
		no_align_error();
		break;
	case any_mode(omit):
		omit_error();
		break;

		//1130
	case vmode+halign:
	case hmode+valign:
		init_align();
		break;
	case mmode+halign:
		if (privileged())
			if (cur_group == math_shift_group)
				init_align();
			else
				off_save();
		break;
	case vmode+endv:
	case hmode+endv:
		do_endv();
		break;

		//1134
	case any_mode(end_cs_name):
		cs_error();
		break;

		// 1137
	case hmode+math_shift:
		init_math();
		break;

		// 1140
	case mmode+eq_no:
		if (privileged())
			if (cur_group == math_shift_group)
				start_eq_no();
			else off_save();

		break;

		// 1150
	case mmode+left_brace:
		tail_append(new_noad());
		back_input();
		scan_math(nucleus(tail));
		break;

		// 1154
	case mmode+letter:
	case mmode+other_char:
	case mmode+char_given:
		set_math_char(ho(math_code(cur_chr)));
		break;
	case mmode+char_num:
		scan_char_num();
		cur_chr = cur_val;
		set_math_char(ho(math_code(cur_chr)));
		break;
	case mmode+math_char_num:
		scan_fifteen_bit_int();
		set_math_char(cur_val);
		break;
	case mmode+math_given:
		set_math_char(cur_chr);
		break;
	case mmode+delim_num:
		scan_twenty_seven_bit_int();
		set_math_char(cur_val / 010000);
		break;

		// 1158
	case mmode+math_comp:
		// overflow check
		if (cur_chr > 255) {
			printf("Overflow assignment 1158\n");
			exit(1);
		}
		//////////////////
		
		tail_append(new_noad()); type(tail) = (quarterword)cur_chr;
		scan_math(nucleus(tail));
		break;
	case mmode+limit_switch:
		math_limit_switch();
		break;

		// 1162
	case mmode+radical:
		math_radical();
		break;

		// 1164
	case mmode+accent:
	case mmode+math_accent:
		math_ac();
		break;

		// 1167
	case mmode+vcenter:
		scan_spec(vcenter_group, false);
		normal_paragraph();
		push_nest();
		mode = (mode_type)-vmode;
		prev_depth = ignore_depth;
		if (every_vbox != null)
			begin_token_list(every_vbox, every_vbox_text);
		break;

		// 1171
	case mmode+math_style:
		tail_append(new_style(cur_chr));
		break;
	case mmode+non_script:
		tail_append(new_glue(zero_glue)); subtype(tail) = cond_math_glue;
		break;
	case mmode+math_choice:
		append_choices();
		break;

		// 1175
	case mmode+sub_mark:
	case mmode+sup_mark:
		sub_sup();
		break;

		// 1180
	case mmode+above:
		math_fraction();
		break;

		// 1190
	case mmode+left_right:
		math_left_right();
		break;

		// 1193
	case mmode+math_shift:
		if (cur_group == math_shift_group)
			after_math();
		else
			off_save();
		break;
	#pragma endregion

	#pragma region <Cases of main_control that dont depend on mode 1210>
	case any_mode(toks_register):
	case any_mode(assign_toks):
	case any_mode(assign_int):
	case any_mode(assign_dimen):
	case any_mode(assign_glue):
	case any_mode(assign_mu_glue):
	case any_mode(assign_font_dimen):
	case any_mode(assign_font_int):
	case any_mode(set_aux):
	case any_mode(set_prev_graf):
	case any_mode(set_page_dimen):
	case any_mode(set_page_int):
	case any_mode(set_box_dimen):
	case any_mode(set_shape):
	case any_mode(def_code):
	case any_mode(def_family):
	case any_mode(set_font):
	case any_mode(def_font):
	case any_mode(_register):
	case any_mode(advance):
	case any_mode(multiply):
	case any_mode(divide):
	case any_mode(prefix):
	case any_mode(let):
	case any_mode(shorthand_def):
	case any_mode(read_to_cs):
	case any_mode(def):
	case any_mode(set_box):
	case any_mode(hyph_data):
	case any_mode(set_interaction):
		prefixed_command();
		break;

		// 1268
	case any_mode(after_assignment):
		get_token();
		after_token = cur_tok;
		break;

		// 1271
	case any_mode(after_group):
		get_token();
		save_for_after(cur_tok);
		break;

		//1274
	case any_mode(in_stream):
		open_or_close_in();
		break;

		// 1276
	case any_mode(message):
		issue_message();
		break;

		// 1285
	case any_mode(case_shift):
		shift_case();
		break;

		// 1290
	case any_mode(xray):
		show_whatever();
		break;

	#pragma endregion

	#pragma region <Cases of main_control that are for extensions fo TeX 1347>
	case any_mode(extension):
		do_extension();
		break;
	#pragma endregion

	#pragma endregion

	}
	goto big_switch;

main_loop:

	#pragma region <Append character cur_chr and the following characters if any to the current hlist in the current font; goto reswitch when a non character has been reached 1034>
	adjust_space_factor;
	main_f = cur_font; bchar = font_bchar[main_f]; false_bchar = font_false_bchar[main_f];
	if (mode > 0)
		if (language != clang)
			fix_language();
	lig_stack = get_avail(); font(lig_stack) = main_f; cur_l = qi(cur_chr); 
	
	// overflow check
	if (cur_l > 255) {
		printf("Overflow assignment 1034\n");
		exit(1);
	}
	///////////////
	
	character(lig_stack) = (quarterword)cur_l;
	cur_q = tail;
	if (cancel_boundary) {
		cancel_boundary = false; main_k = non_address;
	}
	else main_k = bchar_label[main_f];
	if (main_k == non_address)
		goto main_loop_move_plus2;
	cur_r = cur_l; cur_l = non_char; goto main_lig_loop_plus1;

main_loop_wrapup:
	#pragma region <Make a ligature node, if ligature present; insert a null discretionary if appropriate 1035>

	wrapup(rt_hit);

	#pragma endregion

main_loop_move:
	#pragma region <If the cursor is immediately followed by the right boundary goto reswitch; .. 1036>
	if (lig_stack == null) goto reswitch;
	cur_q = tail; cur_l = character(lig_stack);
main_loop_move_plus1:
	if (!is_char_node(lig_stack)) goto main_loop_move_lig;

main_loop_move_plus2:
	if (cur_chr < font_bc[main_f] || cur_chr > font_ec[main_f]) {
	
		// Overflow check
		if (cur_chr > 255) {
			printf("overflow char_warning1 1036\n");
			exit(1);
		}
		//////////////
		
		char_warning(main_f, (eight_bits)cur_chr); free_avail(lig_stack); goto big_switch;
	}
	main_i = char_info(main_f, cur_l);
	if (!char_exists(main_i)) {
	
		// Overflow check
		if (cur_chr > 255) {
			printf("overflow char_warning2 1036\n");
			exit(1);
		}
		////////////////
		
		char_warning(main_f, (eight_bits)cur_chr); free_avail(lig_stack); goto big_switch;
	}
	link(tail) = lig_stack; tail = lig_stack;

	#pragma endregion
main_loop_lookahead:
	#pragma region <Look ahead for another character or leave lig_stack empty if theres none there 1038>
	get_next();
	if (cur_cmd == letter) goto main_loop_lookahead_plus1;
	if (cur_cmd == other_char) goto main_loop_lookahead_plus1;
	if (cur_cmd == char_given) goto main_loop_lookahead_plus1;
	x_token();
	if (cur_cmd == letter) goto main_loop_lookahead_plus1;
	if (cur_cmd == other_char) goto main_loop_lookahead_plus1;
	if (cur_cmd == char_given) goto main_loop_lookahead_plus1;
	if (cur_cmd == char_num) {
		scan_char_num(); cur_chr = cur_val; goto main_loop_lookahead_plus1;
	}
	if (cur_cmd == no_boundary) bchar = non_char;
	cur_r = bchar; lig_stack = null; goto main_lig_loop;
main_loop_lookahead_plus1:
	adjust_space_factor; lig_stack = get_avail(); font(lig_stack) = main_f;
	cur_r = qi(cur_chr);

	// overflow check
	if (cur_r > 255) {
		printf("Overflow assignment 1038\n");
		exit(1);
	}
	////////////////
	
	character(lig_stack) = (quarterword)cur_r;
	if (cur_r == false_bchar) cur_r = non_char;

#pragma endregion

main_lig_loop:
	#pragma region <If theres a ligature/kern command relevant to cur_l and cur_r adjust the text appropriatley exit to main_loop_wrapup 1039>
	if (char_tag(main_i) != lig_tag) goto main_loop_wrapup;
	if (cur_r == non_char) goto main_loop_wrapup;
	main_k = lig_kern_start(main_f, main_i); main_j = font_info[main_k].qqqq;
	if (skip_byte(main_j) <= stop_flag) goto main_lig_loop_plus2;
	main_k = lig_kern_restart(main_f, main_j);
main_lig_loop_plus1:
	main_j = font_info[main_k].qqqq;
main_lig_loop_plus2:
	if(next_char(main_j) == cur_r)
		if (skip_byte(main_j) <= stop_flag) 
			#pragma region <Do ligature or kern command returning to main_lig_loop or main_loop_wrapup or main_loop_move 1040>
		{
			
			if (op_byte(main_j) >= kern_flag) {
				wrapup(rt_hit); tail_append(new_kern(char_kern(main_f, main_j)));
				goto main_loop_move;
			}

			if (cur_l == non_char)
				lft_hit = true;
			else if (lig_stack == null)
				rt_hit = true;
			check_interrupt;


			switch (op_byte(main_j)) {
			case qi(1):
			case qi(5):
				cur_l = rem_byte(main_j);
				main_i = char_info(main_f, cur_l); ligature_present = true;
				break;
			case qi(2):
			case qi(6):
				cur_r = rem_byte(main_j);
				if (lig_stack == null)
				{
					lig_stack = new_lig_item((quarterword)cur_r); bchar = non_char;
				}
				else if (is_char_node(lig_stack)) {
					main_p = lig_stack; lig_stack = new_lig_item((quarterword)cur_r); lig_ptr(lig_stack) = main_p;
				}
				else character(lig_stack) = (quarterword)cur_r;
				break;

			case qi(3):
				cur_r = rem_byte(main_j);
				main_p = lig_stack; lig_stack = new_lig_item((quarterword)cur_r); link(lig_stack) = main_p;
				break;
			case qi(7):
			case qi(11):
				wrapup(false);
				cur_q = tail; cur_l = rem_byte(main_j); main_i = char_info(main_f, cur_l);
				ligature_present = true;
				break;
			default:
				cur_l = rem_byte(main_j); ligature_present = true;
				if (lig_stack == null)
					goto main_loop_wrapup;
				else goto main_loop_move_plus1;
				break;
			}
			if (op_byte(main_j) > qi(4))
				if (op_byte(main_j) != qi(7)) goto main_loop_wrapup;
			if (cur_l < non_char) goto main_lig_loop;
			main_k = bchar_label[main_f]; goto main_lig_loop_plus1;
		}
			#pragma endregion
	if (skip_byte(main_j) == qi(0)) incr(main_k);
	else {
		if (skip_byte(main_j) >= stop_flag) goto main_loop_wrapup;
		main_k += qo(skip_byte(main_j)) + 1;
	}
	goto main_lig_loop_plus1;

	#pragma endregion

main_loop_move_lig:
	#pragma region <Move the cursor past a pseudo ligature then goto main_loop_lookahead or main_lig_loop 1037>
	main_p = lig_ptr(lig_stack);
	if (main_p > null) tail_append(main_p);
	temp_ptr = lig_stack; lig_stack = link(temp_ptr); free_node(temp_ptr, small_node_size);
	main_i = char_info(main_f, cur_l); ligature_present = true;
	if (lig_stack == null)
		if (main_p > null) goto main_loop_lookahead;
		else cur_r = bchar;
	else cur_r = character(lig_stack);
	goto main_lig_loop;
	#pragma endregion

	#pragma endregion

append_normal_space:
	#pragma region <Append a normal inter-word space to the current list then goto big_switch 1041>
	if (space_skip == zero_glue) {
		#pragma region <Find the glue spec main_p for text spaces in the current font 1042>
		{
			main_p = font_glue[cur_font];
			if (main_p == null) {
				main_p = new_spec(zero_glue); main_k = param_base[cur_font] + space_code;
				width(main_p) = font_info[main_k].sc;
				stretch(main_p) = font_info[main_k + 1].sc;
				shrink(main_p) = font_info[main_k + 2].sc;
				font_glue[cur_font] = main_p;
			}
		}
		#pragma endregion
		temp_ptr = new_glue(main_p);
	}
	else temp_ptr = new_param_glue(space_skip_code);
	link(tail) = temp_ptr; tail = temp_ptr; goto big_switch;
	#pragma endregion

	return;
}

// 437
void scan_twenty_seven_bit_int()
{
	scan_int();
	if (cur_val < 0 || cur_val > 0777777777) {
		print_err(TEX_STRING("Bad delimiter code"));
		help2(TEX_STRING("A numeric delimiter code must be between 0 and 2^{27}-1."),
			TEX_STRING("I changed this one to zero."));
		int_error(cur_val);
		cur_val = 0;
	}
}

// 688
pointer new_style(small_number s)
{
	pointer p;

	p = get_node(style_node_size); type(p) = style_node; subtype(p) = s;
	width(p) = 0;
	depth(p) = 0;
	return p;
}

//1131
void do_endv()
{
	base_ptr = input_ptr; input_stack[base_ptr] = cur_input;
	while (input_stack[base_ptr].index_field != v_template && input_stack[base_ptr].loc_field == null &&
		input_stack[base_ptr].state_field == token_list) decr(base_ptr);
	if (input_stack[base_ptr].index_field != v_template || input_stack[base_ptr].loc_field !=
		null || input_stack[base_ptr].state_field != token_list)
		fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
	if (cur_group == align_group) {
		end_graf();
		if (fin_col()) fin_row();
	}
	else off_save();
}

//1135
void cs_error()
{
	print_err(TEX_STRING("Extra "));
	print_esc(TEX_STRING("endcsname"));
	help1(TEX_STRING("I'm ignoring this, since I wasn't doing a \csname."));
	error();
}

//1138
void init_math()
{
	scaled w;
	scaled l;
	scaled s;
	pointer p;
	pointer q;
	internal_font_number f;
	int n;
	scaled v;
	scaled d;

	get_token();
	if (cur_cmd == math_shift && mode > 0)
		#pragma region <Go into display math mode 1145>
	{
		if (head == tail) {
			pop_nest(); w = -max_dimen;
		}
		else {
			line_break(display_widow_penalty);
			#pragma region <Calculate the natural width, w, by which the characters of the final line extend to the right... 1146>
			v = shift_amount(just_box) + 2 * quad(cur_font); w = -max_dimen; p = list_ptr(just_box);
			while (p != null) {
				#pragma region <Let d be the natural width of node p; if the node is visible.. 1147>
			reswitch:
				if (is_char_node(p)) {
					f = font(p); d = char_width(f, char_info(f, character(p))); goto found;
				}
				switch (type(p)) {
				case hlist_node:
				case vlist_node:
				case rule_node:
					d = width(p); goto found;
					break;
				case ligature_node:
					#pragma region <Make node p look like a char_node and goto reswitch 652>
					mem[lig_trick] = mem[lig_char(p)]; link(lig_trick) = link(p); p = lig_trick;
					goto reswitch;
					#pragma endregion
					break;
				case kern_node:
				case math_node:
					d = width(p);
					break;
				case glue_node:
					#pragma region <Let d be the natural width of this glue; if stretching or shrinking, .. 1148>
					q = glue_ptr(p); d = width(q);
					if (glue_sign(just_box) == stretching) {
						if (glue_order(just_box) == stretch_order(q) && stretch(q) != 0) v = max_dimen;
					}
					else if (glue_sign(just_box) == shrinking) {
						if (glue_order(just_box) == shrink_order(q) && shrink(q) != 0) v = max_dimen;
					}
					if (subtype(p) >= a_leaders) goto found;
					#pragma endregion
					break;
				case whatsit_node:
					#pragma region <Let d be the width of the whatsit p 1361>
					d = 0;
					#pragma endregion
					break;

				default: d = 0; break;
				}
				#pragma endregion
				if (v < max_dimen) v += d;
				goto not_found;
			found:
				if (v < max_dimen) {
					v += d; w = v;
				}
				else {
					w = max_dimen; goto done;
				}
		not_found:
				p = link(p);
			}
		done:
			;
			#pragma endregion
		}
		#pragma region <Calculate the length, l, and the shift amount, s, of the display lines 1149>
		if(par_shape_ptr == null)
			if (hang_indent != 0 && ((hang_after >= 0 && prev_graf + 2 > hang_after) || prev_graf + 1 < -hang_after)) {
				l = hsize - myabs(hang_indent);
				if (hang_indent > 0) s = hang_indent;
				else s = 0;
			}
			else {
				l = hsize; s = 0;
			}
		else {
			n = info(par_shape_ptr);
			if (prev_graf + 2 >= n) p = par_shape_ptr + 2 * n;
			else p = par_shape_ptr + 2 * (prev_graf + 2);
			s = mem[p - 1].sc; l = mem[p].sc;
		}
		#pragma endregion

		push_math(math_shift_group); mode = mmode; eq_word_define(int_base + cur_fam_code, -1);
		eq_word_define(dimen_base + pre_display_size_code, w);
		eq_word_define(dimen_base + display_width_code, l); eq_word_define(dimen_base + display_indent_code, s);
		if (every_display != null) begin_token_list(every_display, every_display_text);
		if (nest_ptr == 1) build_page();
	}
		#pragma endregion
	else {
		back_input();
		#pragma region <Go into ordinary math mode 1139>
		{
			push_math(math_shift_group); eq_word_define(int_base + cur_fam_code, -1);
			if (every_math != null) begin_token_list(every_math, every_math_text);
		}
		#pragma endregion
	}
}

// 1142
void start_eq_no()
{
	saved(0) = cur_chr; incr(save_ptr);
	#pragma region <Go into ordinary math mode 1139>
	{
		push_math(math_shift_group); eq_word_define(int_base + cur_fam_code, -1);
		if (every_math != null) begin_token_list(every_math, every_math_text);
	}
	#pragma endregion
}

// 1151
void scan_math(pointer p)
{
	int c;

restart:

	#pragma region <Get the next non-blank non-relax non-call token 404>
	do
	{
		get_x_token();
	} while (!(cur_cmd != spacer && cur_cmd != relax));
	#pragma endregion

reswitch:

	switch (cur_cmd) {
	case letter:
	case other_char:
	case char_given:
		c = ho(math_code(cur_chr));
		if (c == 0100000) {
			#pragma region <Treat cur_chr as an active character 1152>
			{
				cur_cs = cur_chr + active_base; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs); x_token();
				back_input();
			}
			#pragma endregion
			goto restart;
		}
		break;
	case char_num:
		scan_char_num(); cur_chr = cur_val; cur_cmd = char_given; goto reswitch;
		break;
	case math_char_num:
		scan_fifteen_bit_int(); c = cur_val;
		break;
	case math_given:
		c = cur_chr;
		break;
	case delim_num:
		scan_twenty_seven_bit_int(); c = cur_val / 010000;
		break;
	default:
		#pragma region <Scan a subformula enclosed in braces and return 1153>
		back_input(); scan_left_brace();
		saved(0) = p; incr(save_ptr); push_math(math_group); return;
		#pragma endregion
		break;
	}
	math_type(p) = math_char; character(p) = qi(c % 256);
	if (c >= var_code && fam_in_range) fam(p) = cur_fam;
	else 
		fam(p) = (c / 256) % 16;


}

// 1155
void set_math_char(int c)
{
	pointer p;

	if (c >= 0100000)
		#pragma region <treat cur_chr as an active character 1152>
	{
		cur_cs = cur_chr + active_base; cur_cmd = eq_type(cur_cs); cur_chr = equiv(cur_cs); x_token();
		back_input();
	}
		#pragma endregion
	else {
		p = new_noad(); math_type(nucleus(p)) = math_char;
		character(nucleus(p)) = qi(c % 256); fam(nucleus(p)) = (c / 256) % 16;
		if (c >= var_code) {
			if (fam_in_range) fam(nucleus(p)) = cur_fam;
			type(p) = ord_noad;
		}
		else type(p) = ord_noad + (c / 010000);
		link(tail) = p; tail = p;
	}
}

// 782
void get_preamble_token()
{
restart:
	get_token();
	while (cur_chr == span_code && cur_cmd == tab_mark) {
		get_token();
		if (cur_cmd > max_command) {
			expand(); get_token();
		}
	}
	if (cur_cmd == endv) fatal_error(TEX_STRING("(interwoven alignment preambles are not allowed)"));
	if (cur_cmd == assign_glue && cur_chr == glue_base + tab_skip_code) {
		scan_optional_equals(); scan_glue(glue_val);
		if (global_defs > 0) geq_define(glue_base + tab_skip_code, glue_ref, cur_val);
		else eq_define(glue_base + tab_skip_code, glue_ref, cur_val);
		goto restart;
	}
}


// 774
void init_align()
{
	pointer save_cs_ptr;
	pointer p;

	save_cs_ptr = cur_cs;
	push_alignment(); align_state = -1000000;
	#pragma region <Check for improper alignment in displayed math 776>
	if (mode == mmode && (tail != head || incompleat_noad != null)) {
		print_err(TEX_STRING("Improper ")); print_esc(TEX_STRING("halign")); print(TEX_STRING(" inside $$'s"));
		help3(TEX_STRING("Displays can use special alignments (like \eqalignno)"),
			TEX_STRING("only if nothing but the alignment itself is between $$'s."),
			TEX_STRING("So I've deleted the formulas that preceded this alignment."));
		error();
		flush_math();
	}
	#pragma endregion
	push_nest();
	#pragma region <Change current mode to -vmode for halign, -hmode for valign 775>
	if (mode == mmode) {
		mode = (mode_type)-vmode; prev_depth = nest[nest_ptr - 2].aux_field.sc;
	}
	else if (mode > 0)
		mode = (mode_type)-mode;
	#pragma endregion
	scan_spec(align_group, false);
	#pragma region <Scan the preamble and record it in the preamble list 777>
	preamble = null; cur_align = align_head; cur_loop = null; scanner_status = aligning;
	warning_index = save_cs_ptr; align_state = -1000000;
	while (1) {
		#pragma region <Append the current tabskip glue to the preamble list 778>
		link(cur_align) = new_param_glue(tab_skip_code); cur_align = link(cur_align);
		#pragma endregion
		if (cur_cmd == car_ret) goto done;
		#pragma region <Scan preamble text until cur_cmd is tab_mark or car_ret, looking for changes in.. 779>

		#pragma region <Scan the template <u_j>, putting the resulting token list in hold_head 783>
		p = hold_head; link(p) = null;
		while (1) {
			get_preamble_token();
			if (cur_cmd == mac_param) goto done1;
			if (cur_cmd <= car_ret && cur_cmd >= tab_mark && align_state == -1000000)
				if (p == hold_head && cur_loop == null && cur_cmd == tab_mark) cur_loop = cur_align;
				else {
					print_err(TEX_STRING("Missing # inserted in alignment preamble"));
					help3(TEX_STRING("There should be exactly one # between &'s, when an"),
						TEX_STRING("\halign or \valign is being set up. In this case you had"),
						TEX_STRING("none, so I've put one in; maybe that will work."));
					back_error();
					goto done1;
				}
			else if (cur_cmd != spacer || p != hold_head) {
				link(p) = get_avail(); p = link(p); info(p) = cur_tok;
			}
		}
	done1:
		#pragma endregion
		link(cur_align) = new_null_box(); cur_align = link(cur_align);
		info(cur_align) = end_span; width(cur_align) = null_flag; u_part(cur_align) = link(hold_head);
		#pragma region <Scan the template <v_j>, putting the resulting token list in hold_head 784>
		p = hold_head; link(p) = null;
		while (1) {
		mycontinue:
			get_preamble_token();
			if (cur_cmd <= car_ret && cur_cmd >= tab_mark && align_state == -1000000) goto done2;
			if (cur_cmd == mac_param) {
				print_err(TEX_STRING("Only one # is allowed per tab"));
				help3(TEX_STRING("There should be exactly one # between &'s, when an"),
					TEX_STRING("\halign or \valign is being set up. In this case you had"),
					TEX_STRING("more than one, so I'm ignoring all but the first."));
				error();
				goto mycontinue;
			}
			link(p) = get_avail(); p = link(p); info(p) = cur_tok;
		}
	done2:
		link(p) = get_avail(); p = link(p); info(p) = end_template_token;
		#pragma endregion
		v_part(cur_align) = link(hold_head);

		#pragma endregion
	}
done:
	scanner_status = normal;
	#pragma endregion
	new_save_level(align_group);
	if (every_cr != null) begin_token_list(every_cr, every_cr_text);
	align_peek();
}

// 1376
void fix_language()
{
	ASCII_code l;
	if (language <= 0)
		l = 0;
	else if (language > 255) l = 0;
	else l = language;

	if (l != clang) {
		new_whatsit(language_node, small_node_size); what_lang(tail) = l; clang = l;
		what_lhm(tail) = norm_min(left_hyphen_min); what_rhm(tail) = norm_min(right_hyphen_min);
	}
}



// 1095
void head_for_vmode()
{
	if (mode < 0)
		if (cur_cmd != hrule) off_save();
		else {
			print_err(TEX_STRING("You can't use `"));
			print_esc(TEX_STRING("hrule"));
			print(TEX_STRING("' here except with leaders"));
			help2(TEX_STRING("To put a horizontal rule in an hbox or an alignment,"),
				TEX_STRING("you should use \leaders or \hrulefill (see The TeXbook)."));
			error();
		}
	else {
		back_input(); cur_tok = par_token; back_input(); token_type = inserted;
	}
}


// 1123
void make_accent()
{
	float s, t;
	pointer p, q, r;
	internal_font_number f;
	scaled a, h, x, w, delta;
	four_quarters i;

	scan_char_num(); f = cur_font; p = new_character(f, cur_val);
	if (p != null) {
		x = x_height(f); s = slant(f) / 65536.0f;
		a = char_width(f, char_info(f, character(p)));
		do_assignments();
		#pragma region <Create a character node q for the next character, but set q = null if problems arise 1124>
		q = null; f = cur_font;
		if (cur_cmd == letter || cur_cmd == other_char || cur_cmd == char_given) {
			// overflow check
			if (cur_chr > 255) {
				printf("Overflow assignment make_accent\n");
				exit(1);
			}
			//////////////
			
			q = new_character(f, (quarterword)cur_chr);
		}
		else if (cur_cmd == char_num) {
			scan_char_num(); q = new_character(f, cur_val);
		}
		else back_input();
		#pragma endregion
		if (q != null)
			#pragma region <Append the accent with appropriate kerns, then set p = q 1125>
		{
			t = slant(f) / 65536.0f; i = char_info(f, character(q)); w = char_width(f, i);
			h = char_height(f, height_depth(i));
			if (h != x) {
				p = hpack(p, 0, additional); shift_amount(p) = x - h;
			}
			
			// Check for overflow
			float ftemp = round((w - a) / 2.0f + h * t - x * s);
			if(ftemp > 2147483583 || ftemp < -2147483583) {
				printf("Overflow in 1125.\n");
				exit(1);
			}
			/////////////////////////
			
			
			delta = (scaled)ftemp; r = new_kern(delta); subtype(r) = acc_kern;
			link(tail) = r; link(r) = p; tail = new_kern(-a - delta); subtype(tail) = acc_kern; link(p) = tail;
			p = q;
		}
			#pragma endregion
		link(tail) = p; tail = p; space_factor = 1000;
	}
}

//1127
void align_error()
{
	if (myabs(align_state) > 2)
		#pragma region <Express consternation over the fact that no alignment is in progress 1128>
	{
		print_err(TEX_STRING("Misplaced ")); print_cmd_chr(cur_cmd, cur_chr);
		if (cur_tok == tab_token + TEX_STRING("&")) {
			help6(TEX_STRING("I can't figure out why you would want to use a tab mark"),
				TEX_STRING("here. If you just want an ampersand, the remedy is"),
				TEX_STRING("simple: Just type `I\&' now. But if some right brace"),
				TEX_STRING("up above has ended a previous alignment prematurely,"),
				TEX_STRING("you're probably due for more error messages, and you"),
				TEX_STRING("might try typing `S' now just to see what is salvageable."));
		}
		else {
			help5(TEX_STRING("I can't figure out why you would want to use a tab mark"),
				TEX_STRING("or \cr or \span just now. If something like a right brace"),
				TEX_STRING("up above has ended a previous alignment prematurely,"),
				TEX_STRING("you're probably due for more error messages, and you"),
				TEX_STRING("might try typing `S' now just to see what is salvageable."));
		}
		error();
	}
#pragma endregion
	else {
		back_input();
		if (align_state < 0) {
			print_err(TEX_STRING("Missing { inserted")); incr(align_state); cur_tok = left_brace_token + TEX_STRING("{");
		}
		else {
			print_err(TEX_STRING("Missing } inserted")); decr(align_state); cur_tok = right_brace_token + TEX_STRING("}");
		}
		help3(TEX_STRING("I've put in what seems to be necessary to fix"),
			TEX_STRING("the current column of the current alignment."),
			TEX_STRING("Try to go on, since this might almost work."));
		ins_error();
	}
}

// 1129
void no_align_error()
{
	print_err(TEX_STRING("Misplaced "));
	print_esc(TEX_STRING("noalign"));
	help2(TEX_STRING("I expect to see \noalign only after the \cr of"),
		TEX_STRING("an alignment. Proceed, and I'll ignore this case."));
	error();
}

void omit_error()
{
	print_err(TEX_STRING("Misplaced ")); 
	print_esc(TEX_STRING("omit"));
	help2(TEX_STRING("I expect to see \omit only after tab marks or the \cr of"),
		TEX_STRING("an alignment. Proceed, and I'll ignore this case."));
	error();
}

// 1117
void append_discretionary()
{
	int c;
	tail_append(new_disc());
	if (cur_chr == 1) {
		c = hyphen_char[cur_font];
		if (c >= 0)
			if (c < 256) pre_break(tail) = new_character(cur_font, c);
	}
	else {
		incr(save_ptr); saved(-1) = 0; new_save_level(disc_group);
		scan_left_brace(); push_nest();
		mode = (mode_type)-hmode; space_factor = 1000;
	}
}

// 968
pointer prune_page_top(pointer p)
{
	pointer prev_p;
	pointer q;

	prev_p = temp_head; link(temp_head) = p;
	while(p!=null)
		switch (type(p)) {
		case hlist_node:
		case vlist_node:
		case rule_node:
			#pragma region <Insert glue for split_top_skip and set p = null 969>
			q = new_skip_param(split_top_skip_code); link(prev_p) = q; link(q) = p;
			if (width(temp_ptr) > height(p)) width(temp_ptr) -= height(p);
			else width(temp_ptr) = 0;
			p = null;
			#pragma endregion
			break;
		case whatsit_node:
		case mark_node:
		case ins_node:
			prev_p = p; p = link(prev_p);
			break;
		case glue_node:
		case kern_node:
		case penalty_node:
			q = p; p = link(q); link(q) = null; link(prev_p) = p;
			flush_node_list(q);
			break;
		default:
			confusion(TEX_STRING("pruning"));
			break;
		}

	return link(temp_head);
}

// 1113
void append_italic_correction()
{
	pointer p;
	internal_font_number f;
	
	if (tail != head) {
		if (is_char_node(tail)) p = tail;
		else if (type(tail) == ligature_node) p = lig_char(tail);
		else return;
		f = font(p); tail_append(new_kern(char_italic(f, char_info(f, character(p)))));
		subtype(tail) = _explicit;
	}
}

// 815
void line_break(int final_widow_penalty)
{
	#pragma region <Local variables for line breaking 862>
	bool auto_breaking;
	pointer prev_p;
	pointer q, r, s, prev_s;
	internal_font_number f;

	//893
	small_number j;
	unsigned char c;

	#pragma endregion

	pack_begin_line = mode_line;

	#pragma region <Get ready to start line breaking 816>
	link(temp_head) = link(head);
	if (is_char_node(tail)) tail_append(new_penalty(inf_penalty));
	else if (type(tail) != glue_node) tail_append(new_penalty(inf_penalty));
	else {
		type(tail) = penalty_node; delete_glue_ref(glue_ptr(tail)); flush_node_list(leader_ptr(tail));
		penalty(tail) = inf_penalty;
	}
	link(tail) = new_param_glue(par_fill_skip_code); init_cur_lang = prev_graf % 0200000;
	init_l_hyf = prev_graf / 020000000; init_r_hyf = (prev_graf / 0200000) % 0100;
	pop_nest();

	//827
	no_shrink_error_yet = true;
	check_shrinkage(left_skip); check_shrinkage(right_skip);
	q = left_skip; r = right_skip; background[1] = width(q) + width(r);
	background[2] = 0; background[3] = 0; background[4] = 0; background[5] = 0;
	background[2 + stretch_order(q)] = stretch(q);
	background[2 + stretch_order(r)] += stretch(r);
	background[6] = shrink(q) + shrink(r);

	//834
	minimum_demerits = awful_bad; minimal_demerits[tight_fit] = awful_bad;
	minimal_demerits[decent_fit] = awful_bad; minimal_demerits[loose_fit] = awful_bad;
	minimal_demerits[very_loose_fit] = awful_bad;

	//848
	if(par_shape_ptr == null)
		if (hang_indent == 0) {
			last_special_line = 0; second_width = hsize; second_indent = 0;
		}
		else
			#pragma region <Set line length paramters in preparation for hanging indentation 849>
		{
			last_special_line = myabs(hang_after);
			if (hang_after < 0) {
				first_width = hsize - myabs(hang_indent);
				if (hang_indent >= 0) first_indent = hang_indent;
				else first_indent = 0;
				second_width = hsize; second_indent = 0;
			}
			else {
				first_width = hsize; first_indent = 0; second_width = hsize - myabs(hang_indent);
				if (hang_indent >= 0) second_indent = hang_indent;
				else second_indent = 0;
			}
		}
			#pragma endregion
	else {
		last_special_line = info(par_shape_ptr) - 1;
		second_width = mem[par_shape_ptr + 2 * (last_special_line + 1)].sc;
		second_indent = mem[par_shape_ptr + 2 * last_special_line + 1].sc;
	}
	if (looseness == 0) easy_line = last_special_line;
	else easy_line = max_halfword;


	#pragma endregion

	#pragma region <Find optimal breakpoints 863>
	threshold = pretolerance;
	if (threshold >= 0) {
		//stat
#ifndef NO_STAT
		if (tracing_paragraphs > 0) {
			begin_diagnostic(); print_nl(TEX_STRING("@firstpass"));
		}
#endif
		//tats
		second_pass = false; final_pass = false;
	}
	else {
		threshold = tolerance; second_pass = true;
		final_pass = (emergency_stretch <= 0);
		//stat
#ifndef NO_STAT
		if (tracing_paragraphs > 0) begin_diagnostic();
#endif
		//tats
	}
	while (1) {
		if (threshold > inf_bad) threshold = inf_bad;
		if (second_pass)
			#pragma region <Initialize for hyphenating a paragraph 891>
		{
			//init
#ifndef NO_INIT
			if (trie_not_ready) init_trie();
#endif
			//tini
			cur_lang = init_cur_lang; l_hyf = init_l_hyf; r_hyf = init_r_hyf;
		}
			#pragma endregion

		#pragma region <Create an active breakpoint representing the beginning of the paragraph 864>
		q = get_node(active_node_size); type(q) = unhyphenated; fitness(q) = decent_fit; link(q) = last_active;
		break_node(q) = null; line_number(q) = prev_graf + 1; total_demerits(q) = 0; link(active) = q;
		do_all_six(store_background);
		passive = null; printed_node = temp_head; pass_number = 0; font_in_short_display = null_font;
		#pragma endregion

		cur_p = link(temp_head); auto_breaking = true;
		prev_p = cur_p;
		while (cur_p != null && link(active) != last_active)
			#pragma region <Call try_break if cur_p is a legal breakpoint;... 866>
		{
			if (is_char_node(cur_p))
				#pragma region <Advance cur_p to the node following the present string of characters 867>
			{
				prev_p = cur_p;
				do {
					f = font(cur_p); act_width += char_width(f, char_info(f, character(cur_p)));
					cur_p = link(cur_p);
				} while (!(!is_char_node(cur_p)));
			}
				#pragma endregion

			switch (type(cur_p)) {
			case hlist_node:
			case vlist_node:
			case rule_node:
				act_width += width(cur_p);
				break;
			case whatsit_node:
				#pragma region <Advance past a whatsit node in the line_break loop 1362>
				adv_past(cur_p);
				#pragma endregion
				break;
			case glue_node:
				#pragma region <If node cur_p is a legal breakpoint, call try_break ... 868>
				if (auto_breaking) {
					if (is_char_node(prev_p)) try_break(0, unhyphenated);
					else if (precedes_break(prev_p)) try_break(0, unhyphenated);
					else if (type(prev_p) == kern_node && subtype(prev_p) != _explicit) try_break(0, unhyphenated);
				}
				check_shrinkage(glue_ptr(cur_p)); q = glue_ptr(cur_p); act_width += width(q);
				active_width[2 + stretch_order(q)] += stretch(q);
				active_width[6] += shrink(q);
				#pragma endregion
				if(second_pass && auto_breaking)
					#pragma region <Try to hyphenate the following word 894>
				{ 
					prev_s = cur_p; s = link(prev_s);
					if (s != null) {
						#pragma region <Skip to node ha, or goto done1 if no hyphenaotn should be attempted 896>
						while (1) {
							if (is_char_node(s)) {
								c = qo(character(s)); hf = font(s);
							}
							else if (type(s) == ligature_node)
								if (lig_ptr(s) == null) goto mycontinue;
								else {
									q = lig_ptr(s); c = qo(character(q)); hf = font(q);
								}
							else if (type(s) == kern_node && subtype(s) == normal) goto mycontinue;
							else if (type(s) == whatsit_node) {
								#pragma region <Advance past a whatsit node in the pre-hyphenation loop 1363>
								adv_past(s);
								#pragma endregion
								goto mycontinue;
							}
							else goto done1;
							if (lc_code(c) != 0)
								if (lc_code(c) == c || uc_hyph > 0) goto done2;
								else goto done1;
							mycontinue:
								prev_s = s; s = link(prev_s);
						}
					done2: hyf_char = hyphen_char[hf];
						if (hyf_char < 0) goto done1;
						if (hyf_char > 255) goto done1;
						ha = prev_s;
						#pragma endregion
						if (l_hyf + r_hyf > 63) goto done1;
						#pragma region <Skip to node hb, putting letters into hu and hc 897>
						hn = 0;
						while (1) {
							if (is_char_node(s)) {
								if (font(s) != hf) goto done3;
								hyf_bchar = character(s); c = qo(hyf_bchar);
								if (lc_code(c) == 0) goto done3;
								if (hn == 63) goto done3;
								hb = s; incr(hn); hu[hn] = c; hc[hn] = lc_code(c); hyf_bchar = non_char;
							}
							else if (type(s) == ligature_node)
								#pragma region <Move the characters of a ligature node to hu and hc; but got done3... 898>
							{ 
								if (font(lig_char(s)) != hf) goto done3;
								j = hn; q = lig_ptr(s); if (q > null) hyf_bchar = character(q);
								while (q > null) {
									c = qo(character(q));
									if (lc_code(c) == 0) goto done3;
									if (j == 63) goto done3;
									incr(j); hu[j] = c; hc[j] = lc_code(c);
									q = link(q);
								}
								hb = s; hn = j;
								if (myodd(subtype(s))) hyf_bchar = font_bchar[hf];
								else hyf_bchar = non_char;
							}
								#pragma endregion
							else if (type(s) == kern_node && subtype(s) == normal) {
								hb = s; hyf_bchar = font_bchar[hf];
							}
							else goto done3;
							s = link(s);
						}
					done3:
						#pragma endregion
						#pragma region <Check that the nodes following hb permit hyphenation and that at least l_hyf... 899>
						if (hn < l_hyf + r_hyf) goto done1;
						while (1) {
							if(!is_char_node(s))
								switch (type(s)) {
								case ligature_node:
									//do_nothing
									break;
								case kern_node:
									if (subtype(s) != normal) goto done4;
									break;
								case whatsit_node:
								case glue_node:
								case penalty_node:
								case ins_node:
								case adjust_node:
								case mark_node:
									goto done4;
									break;
								default:
									goto done1;
									break;
								}
							s = link(s);
						}
					done4:
						#pragma endregion
						hyphenate();
					}
				done1:
					;
				}
				#pragma endregion
				break;
			case kern_node:
				if (subtype(cur_p) == _explicit) kern_break;
				else act_width += width(cur_p);
				break;
			case ligature_node:
				f = font(lig_char(cur_p));
				act_width += char_width(f, char_info(f, character(lig_char(cur_p))));
				break;

			case disc_node:
				#pragma region <Try to break after a discretionary fragment, then goto done5 869>
				s = pre_break(cur_p); disc_width = 0;
				if (s == null) try_break(ex_hyphen_penalty, hyphenated);
				else {
					do {
						#pragma region <Add the width of node s to disc_width 870>
						if (is_char_node(s)) {
							f = font(s); disc_width += char_width(f, char_info(f, character(s)));
						}
						else
							switch (type(s)) {
							case ligature_node:
								f = font(lig_char(s));
								disc_width += char_width(f, char_info(f, character(lig_char(s))));
								break;
							case hlist_node:
							case vlist_node:
							case rule_node:
							case kern_node:
								disc_width += width(s);
								break;

							default:
								confusion(TEX_STRING("disc3"));
								break;
							}
						
						#pragma endregion
						s = link(s);
					} while (!(s == null));
					act_width += disc_width; try_break(hyphen_penalty, hyphenated);
					act_width -= disc_width;
				}
				r = replace_count(cur_p); s = link(cur_p);
				while (r > 0) {
					#pragma region <Add the width of node s to act_width 871>
					if (is_char_node(s)) {
						f = font(s); act_width += char_width(f, char_info(f, character(s)));
					}
					else switch (type(s)) {
					case ligature_node:
						f = font(lig_char(s));
						act_width += char_width(f, char_info(f, character(lig_char(s))));
						break;
					case hlist_node:
					case vlist_node:
					case rule_node:
					case kern_node:
						act_width += width(s);
						break;

					default:
						confusion(TEX_STRING("disc4"));
						break;
					}
					#pragma endregion
					decr(r); s = link(s);
				}
				prev_p = cur_p; cur_p = s; goto done5;
				#pragma endregion
				break;
			case math_node:
				auto_breaking = (subtype(cur_p) == after); kern_break;
				break;
			case penalty_node:
				try_break(penalty(cur_p), unhyphenated);
				break;
			case mark_node:
			case ins_node:
			case adjust_node:
				//do_nothing
				break;

			default:
				confusion(TEX_STRING("paragraph"));
				break;
			}
			prev_p = cur_p; cur_p = link(cur_p);
		done5:
			;
		}
			#pragma endregion

		if (cur_p == null)
			#pragma region <Try the final line break at the end of the paragraph, ... 873>
		{
			try_break(eject_penalty, hyphenated);
			if (link(active) != last_active) {
				#pragma region <Find an active node with fewest demerits 874>
				r = link(active); fewest_demerits = awful_bad;
				do {
					if(type(r) != delta_node)
						if (total_demerits(r) < fewest_demerits) {
							fewest_demerits = total_demerits(r); best_bet = r;
						}
					r = link(r);
				} while (!(r == last_active));
				best_line = line_number(best_bet);
				#pragma endregion
				if (looseness == 0) goto done;
				#pragma region <Find the best active node for the desired looseness 875>
				r = link(active); actual_looseness = 0;
				do {
					if (type(r) != delta_node) {
						line_diff = line_number(r) - best_line;
						if ((line_diff < actual_looseness && looseness <= line_diff) ||
							(line_diff > actual_looseness && looseness >= line_diff)) {
							best_bet = r; actual_looseness = line_diff; fewest_demerits = total_demerits(r);
						}
						else if (line_diff == actual_looseness && total_demerits(r) < fewest_demerits) {
							best_bet = r; fewest_demerits = total_demerits(r);
						}
					}
					r = link(r);
				} while (!(r == last_active));
				best_line = line_number(best_bet);
				#pragma endregion
				if (actual_looseness == looseness || final_pass) goto done;
			}
		}
			#pragma endregion

		#pragma region <Clean up the memory by removing the break nodes 865>
		q = link(active);
		while (q != last_active) {
			cur_p = link(q);
			if (type(q) == delta_node) free_node(q, delta_node_size);
			else free_node(q, active_node_size);
			q = cur_p;
		}
		q = passive;
		while (q != null) {
			cur_p = link(q); free_node(q, passive_node_size); q = cur_p;
		}
		#pragma endregion

		if (!second_pass) {
			//stat
#ifndef NO_STAT
			if (tracing_paragraphs > 0) print_nl(TEX_STRING("@secondpass"));
#endif
			//tats
			threshold = tolerance; second_pass = true; final_pass = (emergency_stretch <= 0);
		}
		else {
			//stat
#ifndef NO_STAT
			if (tracing_paragraphs > 0) print_nl(TEX_STRING("@emergencypass"));
#endif
			//tats
			background[2] += emergency_stretch; final_pass = true;
		}
	}
done:
	//stat
#ifndef NO_STAT
	if (tracing_paragraphs > 0) {
		end_diagnostic(true); normalize_selector();
	}
#endif
	//tats
	#pragma endregion

	#pragma region <Break the paragraph at the chosen breakpoins, justify the resulting lines to the correct widths... 876>

	post_line_break(final_widow_penalty);

	#pragma endregion

	#pragma region <Clean up memory by removing the break nodes 865>
	q = link(active);
	while (q != last_active) {
		cur_p = link(q);
		if (type(q) == delta_node) free_node(q, delta_node_size);
		else free_node(q, active_node_size);
		q = cur_p;
	}
	q = passive;
	while (q != null) {
		cur_p = link(q); free_node(q, passive_node_size); q = cur_p;
	}

	#pragma endregion

	pack_begin_line = 0;

}


// 826
pointer finite_shrink(pointer p)
{
	pointer q;
	if (no_shrink_error_yet) {
		no_shrink_error_yet = false;
		print_err(TEX_STRING("Infinite glue shrinkage found in a paragraph"));
		help5(TEX_STRING("The paragraph just ended includes some glue that has"),
			TEX_STRING("infinite shrinkability, e.g., `\hskip 0pt minus 1fil'."),
			TEX_STRING("Such glue doesn't belong there---it allows a paragraph"),
			TEX_STRING("of any length to fit on one line. But it's safe to proceed,"),
			TEX_STRING("since the offensive shrinkability has been made finite."));
		error();
	}
	q = new_spec(p); shrink_order(q) = normal; delete_glue_ref(p);
	return q;
}

//877
void post_line_break(int final_widow_penalty)
{
	pointer q, r, s;
	bool disc_break;
	bool post_disc_break;
	scaled cur_width;
	scaled cur_indent;
	quarterword t;
	int pen;
	halfword cur_line;

	#pragma region <Reverse the links of the relevant passive nodes, setting cur_p to the first breakpoint 878>
	q = break_node(best_bet); cur_p = null;
	do {
		r = q; q = prev_break(q); next_break(r) = cur_p; cur_p = r;
	} while (!(q == null));
	#pragma endregion
	cur_line = prev_graf + 1;
	do {
		#pragma region <Justify the line ending at breakpoint cur_p, and append it to the current vertical list.. 880>

		#pragma region <Modify the end of the line to reflect the nature of the break and to include .. 881>
		q = cur_break(cur_p); disc_break = false; post_disc_break = false;
		if(q!=null)
			if (type(q) == glue_node) {
				delete_glue_ref(glue_ptr(q)); glue_ptr(q) = right_skip; subtype(q) = right_skip_code + 1;
				add_glue_ref(right_skip); goto done;
			}
			else {
				if(type(q) == disc_node)
					#pragma region <Change discretionary to compulsory and set disc_break=true 882>
				{
					t = replace_count(q);

					#pragma region <Destroy the t nodes following q, and make r point to the following node 883>
					if (t == 0) r = link(q);
					else {
						r = q;
						while (t > 1) {
							r = link(r); decr(t);
						}
						s = link(r); r = link(s); link(s) = null; flush_node_list(link(q)); replace_count(q) = 0;
					}
					#pragma endregion
					if (post_break(q) != null)
						#pragma region <Transplant the post-break list 884>
					{
						s = post_break(q);
						while (link(s) != null) s = link(s);
						link(s) = r; r = post_break(q); post_break(q) = null; post_disc_break = true;
					}
						#pragma endregion
					if (pre_break(q) != null)
						#pragma region <Transplant the pre-break list 885>
					{
						s = pre_break(q); link(q) = s;
						while (link(s) != null) s = link(s);
						pre_break(q) = null; q = s;
					}
						#pragma endregion
					link(q) = r; disc_break = true;
				}
					#pragma endregion
				else if (type(q) == math_node || type(q) == kern_node) width(q) = 0;
			}
		else {
			q = temp_head;
			while (link(q) != null) q = link(q);
		}

		#pragma region <Put the rightskip glue after node q 886>
		r = new_param_glue(right_skip_code); link(r) = link(q); link(q) = r; q = r;
		#pragma endregion
	done:
		#pragma endregion

		#pragma region <Put the leftskip glue at the left and detach this line 887>
		r = link(q); link(q) = null; q = link(temp_head); link(temp_head) = r;
		if (left_skip != zero_glue) {
			r = new_param_glue(left_skip_code); link(r) = q; q = r;
		}
		#pragma endregion

		#pragma region <Call the packaging subroutine, setting just_box to the justified box 889>
		if (cur_line > last_special_line) {
			cur_width = second_width; cur_indent = second_indent;
		}
		else if (par_shape_ptr == null) {
			cur_width = first_width; cur_indent = first_indent;
		}
		else {
			cur_width = mem[par_shape_ptr + 2 * cur_line].sc;
			cur_indent = mem[par_shape_ptr + 2 * cur_line - 1].sc;
		}
		adjust_tail = adjust_head; just_box = hpack(q, cur_width, exactly); shift_amount(just_box) = cur_indent;
		#pragma endregion

		#pragma region <Append the new box to the current vertical list, followed by the list of special nodes .. 888>
		append_to_vlist(just_box);
		if (adjust_head != adjust_tail) {
			link(tail) = link(adjust_head); tail = adjust_tail;
		}
		adjust_tail = null;
		#pragma endregion

		#pragma region <Append a penalty node, if a nonzero penalty is appropriate 890>
		if (cur_line + 1 != best_line) {
			pen = inter_line_penalty;
			if (cur_line == prev_graf + 1) pen += club_penalty;
			if (cur_line + 2 == best_line) pen += final_widow_penalty;
			if (disc_break) pen += broken_penalty;
			if (pen != 0) {
				r = new_penalty(pen); link(tail) = r; tail = r;
			}
		}
		#pragma endregion


		#pragma endregion
		incr(cur_line); cur_p = next_break(cur_p);
		if(cur_p!=null)
			if (!post_disc_break)
				#pragma region <Prune unwanted nodes at the beginning of the next line 879>
			{
				r = temp_head;
				while (1) {
					q = link(r);
					if (q == cur_break(cur_p)) goto done1;
					if (is_char_node(q)) goto done1;
					if (non_discardable(q)) goto done1;
					if (type(q) == kern_node)
						if (subtype(q) != _explicit) goto done1;
					r = q;
				}
			done1:
				if (r != temp_head) {
					link(r) = null; flush_node_list(link(temp_head)); link(temp_head) = q;
				}
			}
				#pragma endregion
	} while (!(cur_p == null));

	if (cur_line != best_line || link(temp_head) != null)
		confusion(TEX_STRING("line breaking"));
	prev_graf = best_line - 1;
}

// 906
small_number reconstitute(small_number j, small_number n, halfword bchar, halfword hchar)
{
	pointer p;
	pointer t;
	four_quarters q;
	halfword cur_rh;
	halfword test_char;
	scaled w;
	font_index k;

	hyphen_passed = 0; t = hold_head; w = 0; link(hold_head) = null;

	#pragma region <Set up data structures with the cursor following position j 908>
	cur_l = qi(hu[j]); cur_q = t;
	if (j == 0) {
		ligature_present = init_lig; p = init_list;
		if (ligature_present) lft_hit = init_lft;
		while (p > null) {
			append_charnode_to_t(character(p)); p = link(p);
		}
	}
	else if (cur_l < non_char) append_charnode_to_t(quarterword(cur_l));
	lig_stack = null; set_cur_r;
	#pragma endregion

mycontinue:
	#pragma region <If theres a ligature or constant.. 909>
	if (cur_l == non_char) {
		k = bchar_label[hf];
		if (k == non_address) goto done; else q = font_info[k].qqqq;
	}
	else {
		q = char_info(hf, cur_l);
		if (char_tag(q) != lig_tag) goto done;
		k = lig_kern_start(hf, q); q = font_info[k].qqqq;
		if (skip_byte(q) > stop_flag) {
			k = lig_kern_restart(hf, q); q = font_info[k].qqqq;
		}
	}
	if (cur_rh < non_char) test_char = cur_rh; else test_char = cur_r;
	while (1)
	{
		if(next_char(q) == test_char)
			if(skip_byte(q)<= stop_flag)
				if (cur_rh < non_char) {
					hyphen_passed = j; hchar = non_char; cur_rh = non_char; goto mycontinue;
				}
				else {
					if(hchar<non_char)
						if (myodd(hyf[j])) {
							hyphen_passed = j; hchar = non_char;
						}
					if (op_byte(q) < kern_flag)
						#pragma region <Carry out a ligature replacement, updating the cursor structure ... 911
					{
						if (cur_l == non_char) lft_hit = true;
						if (j == n)
							if (lig_stack == null) rt_hit = true;
						check_interrupt;
						switch (op_byte(q)) {
						case qi(1):
						case qi(5):
							cur_l = rem_byte(q);
							ligature_present = true;
							break;
						case qi(2):
						case qi(6):
							cur_r = rem_byte(q);
							if (lig_stack > null) character(lig_stack) = (quarterword)cur_r;
							else {
								lig_stack = new_lig_item((quarterword)cur_r);
								if (j == n) bchar = non_char;
								else {
									p = get_avail(); lig_ptr(lig_stack) = p; 

									// overflow check
									if (qi(hu[j + 1]) > 255) {
										printf("overflow assignment2 911\n");
										exit(1);
									}
									/////////////
									
									character(p) = (quarterword)qi(hu[j + 1]); 
									font(p) = hf;
								}
							}
							break;
						case qi(3):
							cur_r = rem_byte(q);
							p = lig_stack; lig_stack = new_lig_item((quarterword)cur_r); link(lig_stack) = p;
							break;
						case qi(7):
						case qi(11):
							wrap_lig(false);
							cur_q = t; cur_l = rem_byte(q); ligature_present = true;
							break;
						default:
							cur_l = rem_byte(q); ligature_present = true;
							if (lig_stack > null) pop_lig_stack;
							else if (j == n) goto done;
							else {
								// overflow check
								if (cur_r > 255) {
									printf("Overflow assignment4 911\n");
									exit(1);
								}
								/////////////
								
								append_charnode_to_t(quarterword(cur_r)); incr(j); set_cur_r;
							}
							break;
						}
						if (op_byte(q) > qi(4))
							if (op_byte(q) != qi(7)) goto done;
						goto mycontinue;
						
					}
						#pragma endregion
					w = char_kern(hf, q); goto done;
				}
		if (skip_byte(q) >= stop_flag)
			if (cur_rh == non_char) goto done;
			else {
				cur_rh = non_char; goto mycontinue;
			}
		k = k + qo(skip_byte(q)) + 1; q = font_info[k].qqqq;
	}
done:

	#pragma endregion

	#pragma region <Append a ligature and/or kern to the translation; ... 910>
	wrap_lig(rt_hit);
	if (w != 0) {
		link(t) = new_kern(w); t = link(t); w = 0;
	}
	if (lig_stack > null) {
		cur_q = t; cur_l = character(lig_stack); ligature_present = true; pop_lig_stack;
		goto mycontinue;
	}
	#pragma endregion

	return j;
}

// 895
void hyphenate()
{
	#pragma region <Local variables for hyphenation 901>
	unsigned char i, j, l; //0..65
	pointer q, r, s;
	halfword bchar;

	//912
	pointer major_tail, minor_tail;
	ASCII_code c;
	unsigned char c_loc; // 0..63
	int r_count;
	pointer hyf_node;

	// 922
	trie_pointer z;
	int v;

	//929
	hyph_pointer h;
	str_number k;
	pool_pointer u;


	#pragma endregion

	#pragma region <Find hyphen locations for the word in hc, or return 923>
	for (j = 0; j <= hn; j++) hyf[j] = 0;
	#pragma region <Look for the word hc[1..hn] in the exception table and goto found ...930>
	h = hc[1]; incr(hn); hc[hn] = cur_lang;
	for (j = 2; j <= hn; j++) h = (h + h + hc[j]) % hyph_size;
	while (1) {
		#pragma region <If the string hyph_word[h] is less than ... goto found 931>
		k = hyph_word[h];
		if (k == 0) goto not_found;
		if (length(k) < hn) goto not_found;
		if (length(k) == hn) {
			j = 1; u = str_start[k];
			do {
				if (so(str_pool[u]) < hc[j]) goto not_found;
				if (so(str_pool[u]) > hc[j]) goto done;
				incr(j); incr(u);
			} while (!(j > hn));
			#pragma region <Insert hyphens as specified in hyph_list[h] 932>
			s = hyph_list[h];
			while (s != null) {
				hyf[info(s)] = 1; s = link(s);
			}
			#pragma endregion
			decr(hn); goto found;

		}
	done:

		#pragma endregion
		if (h > 0) decr(h); else h = hyph_size;
	}
not_found:
	decr(hn);
	#pragma endregion
	if (trie_char(cur_lang + 1) != qi(cur_lang)) goto myexit;
	hc[0] = 0; hc[hn + 1] = 0; hc[hn + 2] = 256;
	for (j = 0; j <= hn - r_hyf + 1; j++) {
		z = trie_link(cur_lang + 1) + hc[j]; l = j;
		while (hc[l] == qo(trie_char(z))) {
			if (trie_op(z) != min_quarterword)
				#pragma region <Store maximum values in the hyf table 924>
			{
				v = trie_op(z);
				do {
					v = v + op_start[cur_lang]; i = l - hyf_distance[v];
					if (hyf_num[v] > hyf[i]) hyf[i] = hyf_num[v];
					v = hyf_next[v];
				} while (!(v == min_quarterword));
			}
				#pragma endregion
			incr(l); z = trie_link(z) + hc[l];
		}
	}
found:
	for (j = 0; j <= l_hyf - 1; j++) hyf[j] = 0;
	for (j = 0; j <= r_hyf - 1; j++) hyf[hn - j] = 0;

	#pragma endregion


	#pragma region <If no hyphens were found, return 902>
	for (j = l_hyf; j <= hn - r_hyf; j++)
		if (myodd(hyf[j])) goto found1;
	goto myexit;
found1:

	#pragma endregion

	#pragma region <Replace nodes ha..hb by a sequence of nodes that includes the discretionary hyphens 903>
	q = link(hb); link(hb) = null; r = link(ha); link(ha) = null; bchar = hyf_bchar;
	if (is_char_node(ha))
		if (font(ha) != hf) goto found2;
		else {
			init_list = ha; init_lig = false; hu[0] = qo(character(ha));
		}
	else if (type(ha) == ligature_node)
		if (font(lig_char(ha)) != hf) goto found2;
		else {
			init_list = lig_ptr(ha); init_lig = true; init_lft = (subtype(ha) > 1);
			hu[0] = qo(character(lig_char(ha)));
			if(init_list==null)
				if (init_lft) {
					hu[0] = 256; init_lig = false;
				}
			free_node(ha, small_node_size);
		}
	else {
		if (!is_char_node(r))
			if (type(r) == ligature_node)
				if (subtype(r) > 1) goto found2;
		j = 1; s = ha; init_list = null; goto common_ending;
	}
	s = cur_p;
	while (link(s) != ha) s = link(s);
	j = 0; goto common_ending;
found2:
	s = ha; j = 0; hu[0] = 256; init_lig = false; init_list = null;
common_ending:
	flush_node_list(r);
	#pragma region <Reconstitute nodes for the hyphenated word, inserting discretionary hyphens 913>
	do {
		l = j; j = reconstitute(j, hn, bchar, qi(hyf_char)) + 1;
		if (hyphen_passed == 0) {
			link(s) = link(hold_head);
			while (link(s) > null) s = link(s);
			if (myodd(hyf[j - 1])) {
				l = j; hyphen_passed = j - 1; link(hold_head) = null;
			}
		}
		if (hyphen_passed > 0)
			#pragma region < Create and append a discretionary node as an alternative... 914>

			do {
				r = get_node(small_node_size); link(r) = link(hold_head); type(r) = disc_node; major_tail = r;
				r_count = 0;
				while (link(major_tail) > null) advance_major_tail;
				i = hyphen_passed; hyf[i] = 0;
				#pragma region <Put the characters hu[l..i] and a hyphen into pre_break(r) 915>
				minor_tail = null; pre_break(r) = null; hyf_node = new_character(hf, hyf_char);
				if (hyf_node != null) {
					incr(i); c = hu[i]; hu[i] = hyf_char; free_avail(hyf_node);
				}
				while (l <= i) {
					l = reconstitute(l, i, font_bchar[hf], non_char) + 1;
					if (link(hold_head) > null) {
						if (minor_tail == null) pre_break(r) = link(hold_head);
						else link(minor_tail) = link(hold_head);
						minor_tail = link(hold_head);
						while (link(minor_tail) > null) minor_tail = link(minor_tail);
					}
				}
				if (hyf_node != null) {
					hu[i] = c;
					l = i; decr(i);
				}
				#pragma endregion
				#pragma region <Put the characters hu[i+1..] into post_break(r)... 916>
				minor_tail = null; post_break(r) = null; c_loc = 0;
				if (bchar_label[hf] != non_address) {
					decr(l); c = hu[l]; c_loc = l; hu[l] = 256;
				}
				while (l < j) {
					do {
						l = reconstitute(l, hn, bchar, non_char) + 1;
						if (c_loc > 0) {
							hu[c_loc] = c; c_loc = 0;
						}
						if (link(hold_head) > null) {
							if (minor_tail == null) post_break(r) = link(hold_head);
							else link(minor_tail) = link(hold_head);
							minor_tail = link(hold_head);
							while (link(minor_tail) > null) minor_tail = link(minor_tail);
						}
							
					} while (!(l >= j));
					while (l > j)
						#pragma region <Append characters of hu[j..] to major_tail advancing j 917>
					{
						j = reconstitute(j, hn, bchar, non_char) + 1;
						link(major_tail) = link(hold_head);
						while (link(major_tail) > null) advance_major_tail;
					}
						#pragma endregion
				}
				#pragma endregion
				#pragma region <Move pointer s to the end of the current list, and set replace_count(r) approp... 918>
				if (r_count > 127) {
					link(s) = link(r); link(r) = null; flush_node_list(r);
				}
				else {
					link(s) = r; replace_count(r) = r_count;
				}
				s = major_tail;
				#pragma endregion
				hyphen_passed = j - 1; link(hold_head) = null;
			} while (!(!myodd(hyf[j - 1])));

		#pragma endregion
	} while (!(j > hn));
	link(s) = q;
	#pragma endregion
	flush_list(init_list);
	#pragma endregion
	myexit:
		  ;
}

// 1096
void end_graf()
{
	if (mode == hmode)
	{
		if (head == tail) pop_nest();
		else line_break(widow_penalty);
		normal_paragraph(); error_count = 0;
	}
}

// 1099
void begin_insert_or_adjust()
{
	if (cur_cmd == vadjust) cur_val = 255;
	else {
		scan_eight_bit_int();
		if (cur_val == 255) {
			print_err(TEX_STRING("You can't ")); 
			print_esc(TEX_STRING("insert")); print_int(255);
			help1(TEX_STRING("I'm changing to \insert0; box 255 is special."));
			error();
			cur_val = 0;
		}
	}
	saved(0) = cur_val; incr(save_ptr); new_save_level(insert_group); scan_left_brace(); normal_paragraph();
	push_nest(); mode = (mode_type)-vmode; prev_depth = ignore_depth;
}

//1101
void make_mark()
{
	pointer p;
	p = scan_toks(false, true); p = get_node(small_node_size); type(p) = mark_node;
	subtype(p) = 0;
	mark_ptr(p) = def_ref; link(tail) = p; tail = p;
}

//1103
void append_penalty()
{
	scan_int(); tail_append(new_penalty(cur_val));
	if (mode == vmode) build_page();
}

//1105
void delete_last()
{
	pointer p, q;
	quarterword m;
	if (mode == vmode && tail == head) 
		#pragma region <Apologize for inability to do the operation now, unless unskip follows non-glue 1106>
	{

		if (cur_chr != glue_node || last_glue != max_halfword) {
			you_cant();
			help2(TEX_STRING("Sorry...I usually can't take things from the current page."),
				TEX_STRING("Try `I\vskip-\lastskip' instead."));
			if (cur_chr == kern_node)  help_line[0] = TEX_STRING("Try `I\kern-\lastkern' instead.");
			else if (cur_chr != glue_node)
				help_line[0] = TEX_STRING("Perhaps you can make the output routine do it.");
			error();
		}
	}
		#pragma endregion
	else {
		if(!is_char_node(tail))
			if (type(tail) == cur_chr) {
				q = head;
				do {
					p = q;
					if(!is_char_node(q))
						if (type(q) == disc_node) {
							for (m = 1; m <= replace_count(q); m++) p = link(p);
							if (p == tail)
								return;
						}
					q = link(p);
				} while (!(q == tail));
				link(p) = null; flush_node_list(tail); tail = p;
			}
	}
}

//1110
void unpackage()
{
	pointer p;
	int c; // box_code..copy_code, 0..1

	c = cur_chr; scan_eight_bit_int(); p = box(cur_val);
	if (p == null)
		return;
	if (myabs(mode) == mmode || (myabs(mode) == vmode && type(p) != vlist_node) ||
		(myabs(mode) == hmode && type(p) != hlist_node)) {
		print_err(TEX_STRING("Incompatible list can't be unboxed"));
		help3(TEX_STRING("Sorry, Pandora. (You sneaky devil.)"),
			TEX_STRING("I refuse to unbox an \hbox in vertical mode or vice versa."),
			TEX_STRING("And I can't open any boxes in math mode."));
		error();
		return;
	}
	if (c == copy_code) link(tail) = copy_node_list(list_ptr(p));
	else {
		link(tail) = list_ptr(p); box(cur_val) = null; free_node(p, box_node_size);
	}
	while (link(tail) != null) tail = link(tail);
}

// 1043
void app_space()
{
	pointer q;
	if (space_factor >= 2000 && xspace_skip != zero_glue)
		q = new_param_glue(xspace_skip_code);
	else {
		if (space_skip != zero_glue)
			main_p = space_skip;
		else
			#pragma region <Find the glue specification, main_p, for text spaces in the current font 1042>
		{
			main_p = font_glue[cur_font];
			if (main_p == null) {
				main_p = new_spec(zero_glue); main_k = param_base[cur_font] + space_code;
				width(main_p) = font_info[main_k].sc;
				stretch(main_p) = font_info[main_k + 1].sc;
				shrink(main_p) = font_info[main_k + 2].sc;
				font_glue[cur_font] = main_p;
			}
		}
			#pragma endregion
		main_p = new_spec(main_p);
		#pragma region <Modify the glue specification in main_p according to the space factor 1044>
		if (space_factor >= 2000)
			width(main_p) = width(main_p) + extra_space(cur_font);
		stretch(main_p) = xn_over_d(stretch(main_p), space_factor, 1000);
		shrink(main_p) = xn_over_d(shrink(main_p), 1000, space_factor);
		#pragma endregion
		q = new_glue(main_p); glue_ref_count(main_p) = null;
	}
	link(tail) = q; tail = q;
}

// 1243
void alter_aux()
{
	halfword c;
	if (cur_chr != myabs(mode))
		report_illegal_case();
	else {
		c = cur_chr; scan_optional_equals();
		if (c == vmode) {
			scan_normal_dimen;
			prev_depth = cur_val;
		}
		else {
			scan_int();
			if (cur_val <= 0 || cur_val > 32767) {
				print_err(TEX_STRING("Bad space factor"));
				help1(TEX_STRING("I allow only values in the range 1..32767 here."));
				int_error(cur_val);
			}
			else
				space_factor = cur_val;
		}
	}
}
// 1244
void alter_prev_graf()
{
	unsigned int p;
	nest[nest_ptr] = cur_list; p = nest_ptr;
	while (myabs(nest[p].mode_field) != vmode)
		decr(p);
	scan_optional_equals();
	scan_int();
	if (cur_val < 0) {
		print_err(TEX_STRING("Bad "));
		print_esc(TEX_STRING("prevgraf"));
		help1(TEX_STRING("I allow only nonnegative values here."));
		int_error(cur_val);
	}
	else {
		nest[p].pg_field = cur_val;
		cur_list = nest[nest_ptr];
	}
}

// 1245
void alter_page_so_far()
{
	int c; // 0..7
	c = cur_chr;
	scan_optional_equals();
	scan_normal_dimen;
	page_so_far[c] = cur_val;
}

//1246
void alter_integer()
{
	int c; // 0..1
	c = cur_chr;
	scan_optional_equals();
	scan_int();
	if (c == 0)
		dead_cycles = cur_val;
	else
		insert_penalties = cur_val;
}

// 1247
void alter_box_dimen()
{
	small_number c;
	eight_bits b;
	c = cur_chr; scan_eight_bit_int(); b = cur_val; scan_optional_equals(); scan_normal_dimen;
	if (box(b) != null) mem[box(b) + c].sc = cur_val;
}

// 1336
//init
#ifndef NO_INIT
void init_prim()
{
	no_new_control_sequence = false;

	#pragma region <Put each of tex primitives into the hash table 226>
	primitive(TEX_STRING("lineskip"), assign_glue, glue_base + line_skip_code);
	primitive(TEX_STRING("baselineskip"), assign_glue, glue_base + baseline_skip_code);
	primitive(TEX_STRING("parskip"), assign_glue, glue_base + par_skip_code);
	primitive(TEX_STRING("abovedisplayskip"), assign_glue, glue_base + above_display_skip_code);
	primitive(TEX_STRING("belowdisplayskip"), assign_glue, glue_base + below_display_skip_code);
	primitive(TEX_STRING("abovedisplayshortskip"), assign_glue, glue_base + above_display_short_skip_code);
	primitive(TEX_STRING("belowdisplayshortskip"), assign_glue, glue_base + below_display_short_skip_code);
	primitive(TEX_STRING("leftskip"), assign_glue, glue_base + left_skip_code);
	primitive(TEX_STRING("rightskip"), assign_glue, glue_base + right_skip_code);
	primitive(TEX_STRING("topskip"), assign_glue, glue_base + top_skip_code);
	primitive(TEX_STRING("splittopskip"), assign_glue, glue_base + split_top_skip_code);
	primitive(TEX_STRING("tabskip"), assign_glue, glue_base + tab_skip_code);
	primitive(TEX_STRING("spaceskip"), assign_glue, glue_base + space_skip_code);
	primitive(TEX_STRING("xspaceskip"), assign_glue, glue_base + xspace_skip_code);
	primitive(TEX_STRING("parfillskip"), assign_glue, glue_base + par_fill_skip_code);
	primitive(TEX_STRING("thinmuskip"), assign_mu_glue, glue_base + thin_mu_skip_code);
	primitive(TEX_STRING("medmuskip"), assign_mu_glue, glue_base + med_mu_skip_code);
	primitive(TEX_STRING("thickmuskip"), assign_mu_glue, glue_base + thick_mu_skip_code);

	// 230
	primitive(TEX_STRING("output"), assign_toks, output_routine_loc);
	primitive(TEX_STRING("everypar"), assign_toks, every_par_loc);
	primitive(TEX_STRING("everymath"), assign_toks, every_math_loc);
	primitive(TEX_STRING("everydisplay"), assign_toks, every_display_loc);
	primitive(TEX_STRING("everyhbox"), assign_toks, every_hbox_loc);
	primitive(TEX_STRING("everyvbox"), assign_toks, every_vbox_loc);
	primitive(TEX_STRING("everyjob"), assign_toks, every_job_loc);
	primitive(TEX_STRING("everycr"), assign_toks, every_cr_loc);
	primitive(TEX_STRING("errhelp"), assign_toks, err_help_loc);

	//238
	primitive(TEX_STRING("pretolerance"), assign_int, int_base + pretolerance_code);
	primitive(TEX_STRING("tolerance"), assign_int, int_base + tolerance_code);
	primitive(TEX_STRING("linepenalty"), assign_int, int_base + line_penalty_code);
	primitive(TEX_STRING("hyphenpenalty"), assign_int, int_base + hyphen_penalty_code);
	primitive(TEX_STRING("exhyphenpenalty"), assign_int, int_base + ex_hyphen_penalty_code);
	primitive(TEX_STRING("clubpenalty"), assign_int, int_base + club_penalty_code);
	primitive(TEX_STRING("widowpenalty"), assign_int, int_base + widow_penalty_code);
	primitive(TEX_STRING("displaywidowpenalty"), assign_int, int_base + display_widow_penalty_code);
	primitive(TEX_STRING("brokenpenalty"), assign_int, int_base + broken_penalty_code);
	primitive(TEX_STRING("binoppenalty"), assign_int, int_base + bin_op_penalty_code);
	primitive(TEX_STRING("relpenalty"), assign_int, int_base + rel_penalty_code);
	primitive(TEX_STRING("predisplaypenalty"), assign_int, int_base + pre_display_penalty_code);
	primitive(TEX_STRING("postdisplaypenalty"), assign_int, int_base + post_display_penalty_code);
	primitive(TEX_STRING("interlinepenalty"), assign_int, int_base + inter_line_penalty_code);
	primitive(TEX_STRING("doublehyphendemerits"), assign_int, int_base + double_hyphen_demerits_code);
	primitive(TEX_STRING("finalhyphendemerits"), assign_int, int_base + final_hyphen_demerits_code);
	primitive(TEX_STRING("adjdemerits"), assign_int, int_base + adj_demerits_code);
	primitive(TEX_STRING("mag"), assign_int, int_base + mag_code);
	primitive(TEX_STRING("delimiterfactor"), assign_int, int_base + delimiter_factor_code);
	primitive(TEX_STRING("looseness"), assign_int, int_base + looseness_code);
	primitive(TEX_STRING("time"), assign_int, int_base + time_code);
	primitive(TEX_STRING("day"), assign_int, int_base + day_code);
	primitive(TEX_STRING("month"), assign_int, int_base + month_code);
	primitive(TEX_STRING("year"), assign_int, int_base + year_code);
	primitive(TEX_STRING("showboxbreadth"), assign_int, int_base + show_box_breadth_code);
	primitive(TEX_STRING("showboxdepth"), assign_int, int_base + show_box_depth_code);
	primitive(TEX_STRING("hbadness"), assign_int, int_base + hbadness_code);
	primitive(TEX_STRING("vbadness"), assign_int, int_base + vbadness_code);
	primitive(TEX_STRING("pausing"), assign_int, int_base + pausing_code);
	primitive(TEX_STRING("tracingonline"), assign_int, int_base + tracing_online_code);
	primitive(TEX_STRING("tracingmacros"), assign_int, int_base + tracing_macros_code);
	primitive(TEX_STRING("tracingstats"), assign_int, int_base + tracing_stats_code);
	primitive(TEX_STRING("tracingparagraphs"), assign_int, int_base + tracing_paragraphs_code);
	primitive(TEX_STRING("tracingpages"), assign_int, int_base + tracing_pages_code);
	primitive(TEX_STRING("tracingoutput"), assign_int, int_base + tracing_output_code);
	primitive(TEX_STRING("tracinglostchars"), assign_int, int_base + tracing_lost_chars_code);
	primitive(TEX_STRING("tracingcommands"), assign_int, int_base + tracing_commands_code);
	primitive(TEX_STRING("tracingrestores"), assign_int, int_base + tracing_restores_code);
	primitive(TEX_STRING("uchyph"), assign_int, int_base + uc_hyph_code);
	primitive(TEX_STRING("outputpenalty"), assign_int, int_base + output_penalty_code);
	primitive(TEX_STRING("maxdeadcycles"), assign_int, int_base + max_dead_cycles_code);
	primitive(TEX_STRING("hangafter"), assign_int, int_base + hang_after_code);
	primitive(TEX_STRING("floatingpenalty"), assign_int, int_base + floating_penalty_code);
	primitive(TEX_STRING("globaldefs"), assign_int, int_base + global_defs_code);
	primitive(TEX_STRING("fam"), assign_int, int_base + cur_fam_code);
	primitive(TEX_STRING("escapechar"), assign_int, int_base + escape_char_code);
	primitive(TEX_STRING("defaulthyphenchar"), assign_int, int_base + default_hyphen_char_code);
	primitive(TEX_STRING("defaultskewchar"), assign_int, int_base + default_skew_char_code);
	primitive(TEX_STRING("endlinechar"), assign_int, int_base + end_line_char_code);
	primitive(TEX_STRING("newlinechar"), assign_int, int_base + new_line_char_code);
	primitive(TEX_STRING("language"), assign_int, int_base + language_code);
	primitive(TEX_STRING("lefthyphenmin"), assign_int, int_base + left_hyphen_min_code);
	primitive(TEX_STRING("righthyphenmin"), assign_int, int_base + right_hyphen_min_code);
	primitive(TEX_STRING("holdinginserts"), assign_int, int_base + holding_inserts_code);
	primitive(TEX_STRING("errorcontextlines"), assign_int, int_base + error_context_lines_code);

	//248
	primitive(TEX_STRING("parindent"), assign_dimen, dimen_base + par_indent_code);
	primitive(TEX_STRING("mathsurround"), assign_dimen, dimen_base + math_surround_code);
	primitive(TEX_STRING("lineskiplimit"), assign_dimen, dimen_base + line_skip_limit_code);
	primitive(TEX_STRING("hsize"), assign_dimen, dimen_base + hsize_code);
	primitive(TEX_STRING("vsize"), assign_dimen, dimen_base + vsize_code);
	primitive(TEX_STRING("maxdepth"), assign_dimen, dimen_base + max_depth_code);
	primitive(TEX_STRING("splitmaxdepth"), assign_dimen, dimen_base + split_max_depth_code);
	primitive(TEX_STRING("boxmaxdepth"), assign_dimen, dimen_base + box_max_depth_code);
	primitive(TEX_STRING("hfuzz"), assign_dimen, dimen_base + hfuzz_code);
	primitive(TEX_STRING("vfuzz"), assign_dimen, dimen_base + vfuzz_code);
	primitive(TEX_STRING("delimitershortfall"), assign_dimen, dimen_base + delimiter_shortfall_code);
	primitive(TEX_STRING("nulldelimiterspace"), assign_dimen, dimen_base + null_delimiter_space_code);
	primitive(TEX_STRING("scriptspace"), assign_dimen, dimen_base + script_space_code);
	primitive(TEX_STRING("predisplaysize"), assign_dimen, dimen_base + pre_display_size_code);
	primitive(TEX_STRING("displaywidth"), assign_dimen, dimen_base + display_width_code);
	primitive(TEX_STRING("displayindent"), assign_dimen, dimen_base + display_indent_code);
	primitive(TEX_STRING("overfullrule"), assign_dimen, dimen_base + overfull_rule_code);
	primitive(TEX_STRING("hangindent"), assign_dimen, dimen_base + hang_indent_code);
	primitive(TEX_STRING("hoffset"), assign_dimen, dimen_base + h_offset_code);
	primitive(TEX_STRING("voffset"), assign_dimen, dimen_base + v_offset_code);
	primitive(TEX_STRING("emergencystretch"), assign_dimen, dimen_base + emergency_stretch_code);

	//265
	primitive(TEX_STRING(" "), ex_space, 0);
	primitive(TEX_STRING("/"), ital_corr, 0);
	primitive(TEX_STRING("accent"), accent, 0);
	primitive(TEX_STRING("advance"), advance, 0);
	primitive(TEX_STRING("afterassignment"), after_assignment, 0);
	primitive(TEX_STRING("aftergroup"), after_group, 0);
	primitive(TEX_STRING("begingroup"), begin_group, 0);
	primitive(TEX_STRING("char"), char_num, 0);
	primitive(TEX_STRING("csname"), cs_name, 0);
	primitive(TEX_STRING("delimiter"), delim_num, 0);
	primitive(TEX_STRING("divide"), divide, 0);
	primitive(TEX_STRING("endcsname"), end_cs_name, 0);
	primitive(TEX_STRING("endgroup"), end_group, 0);
	text(frozen_end_group) = TEX_STRING("endgroup");
	eqtb[frozen_end_group] = eqtb[cur_val];
	primitive(TEX_STRING("expandafter"), expand_after, 0);
	primitive(TEX_STRING("font"), def_font, 0);
	primitive(TEX_STRING("fontdimen"), assign_font_dimen, 0);
	primitive(TEX_STRING("halign"), halign, 0);
	primitive(TEX_STRING("hrule"), hrule, 0);
	primitive(TEX_STRING("ignorespaces"), ignore_spaces, 0);
	primitive(TEX_STRING("insert"), insert, 0);
	primitive(TEX_STRING("mark"), mark, 0);
	primitive(TEX_STRING("mathaccent"), math_accent, 0);
	primitive(TEX_STRING("mathchar"), math_char_num, 0);
	primitive(TEX_STRING("mathchoice"), math_choice, 0);
	primitive(TEX_STRING("multiply"), multiply, 0);
	primitive(TEX_STRING("noalign"), no_align, 0);
	primitive(TEX_STRING("noboundary"), no_boundary, 0);
	primitive(TEX_STRING("noexpand"), no_expand, 0);
	primitive(TEX_STRING("nonscript"), non_script, 0);
	primitive(TEX_STRING("omit"), omit, 0);
	primitive(TEX_STRING("parshape"), set_shape, 0);
	primitive(TEX_STRING("penalty"), break_penalty, 0);
	primitive(TEX_STRING("prevgraf"), set_prev_graf, 0);
	primitive(TEX_STRING("radical"), radical, 0);
	primitive(TEX_STRING("read"), read_to_cs, 0);
	primitive(TEX_STRING("relax"), relax, 256);
	text(frozen_relax)  = TEX_STRING("relax"); eqtb[frozen_relax] = eqtb[cur_val];
	primitive(TEX_STRING("setbox"), set_box, 0);
	primitive(TEX_STRING("the"), the, 0);
	primitive(TEX_STRING("toks"), toks_register, 0);
	primitive(TEX_STRING("vadjust"), vadjust, 0);
	primitive(TEX_STRING("valign"), valign, 0);
	primitive(TEX_STRING("vcenter"), vcenter, 0);
	primitive(TEX_STRING("vrule"), vrule, 0);

	// 334
	primitive(TEX_STRING("par"), par_end, 256);
	par_loc = cur_val;
	par_token = cs_token_flag + par_loc;

	// 376
	primitive(TEX_STRING("input"), input, 0);
	primitive(TEX_STRING("endinput"), input, 1);

	// 383
	primitive(TEX_STRING("topmark"), top_bot_mark, top_mark_code);
	primitive(TEX_STRING("firstmark"), top_bot_mark, first_mark_code);
	primitive(TEX_STRING("botmark"), top_bot_mark, bot_mark_code);
	primitive(TEX_STRING("splitfirstmark"), top_bot_mark, split_first_mark_code);
	primitive(TEX_STRING("splitbotmark"), top_bot_mark, split_bot_mark_code);

	// 411
	primitive(TEX_STRING("count"), _register, int_val);
	primitive(TEX_STRING("dimen"), _register, dimen_val);
	primitive(TEX_STRING("skip"), _register, glue_val);
	primitive(TEX_STRING("muskip"), _register, mu_val);

	// 416
	primitive(TEX_STRING("spacefactor"), set_aux, hmode);
	primitive(TEX_STRING("prevdepth"), set_aux, vmode);
	primitive(TEX_STRING("deadcycles"), set_page_int, 0);
	primitive(TEX_STRING("insertpenalties"), set_page_int, 1);
	primitive(TEX_STRING("wd"), set_box_dimen, width_offset);
	primitive(TEX_STRING("ht"), set_box_dimen, height_offset);
	primitive(TEX_STRING("dp"), set_box_dimen, depth_offset);
	primitive(TEX_STRING("lastpenalty"), last_item, int_val);
	primitive(TEX_STRING("lastkern"), last_item, dimen_val);
	primitive(TEX_STRING("lastskip"), last_item, glue_val);
	primitive(TEX_STRING("inputlineno"), last_item, input_line_no_code);
	primitive(TEX_STRING("badness"), last_item, badness_code);

	// 468
	primitive(TEX_STRING("number"), convert, number_code);
	primitive(TEX_STRING("romannumeral"), convert, roman_numeral_code);
	primitive(TEX_STRING("string"), convert, string_code);
	primitive(TEX_STRING("meaning"), convert, meaning_code);
	primitive(TEX_STRING("fontname"), convert, font_name_code);
	primitive(TEX_STRING("jobname"), convert, job_name_code);

	// 487
	primitive(TEX_STRING("if"), if_test, if_char_code);
	primitive(TEX_STRING("ifcat"), if_test, if_cat_code);
	primitive(TEX_STRING("ifnum"), if_test, if_int_code);
	primitive(TEX_STRING("ifdim"), if_test, if_dim_code);
	primitive(TEX_STRING("ifodd"), if_test, if_odd_code);
	primitive(TEX_STRING("ifvmode"), if_test, if_vmode_code);
	primitive(TEX_STRING("ifhmode"), if_test, if_hmode_code);
	primitive(TEX_STRING("ifmmode"), if_test, if_mmode_code);
	primitive(TEX_STRING("ifinner"), if_test, if_inner_code);
	primitive(TEX_STRING("ifvoid"), if_test, if_void_code);
	primitive(TEX_STRING("ifhbox"), if_test, if_hbox_code);
	primitive(TEX_STRING("ifvbox"), if_test, if_vbox_code);
	primitive(TEX_STRING("ifx"), if_test, ifx_code);
	primitive(TEX_STRING("ifeof"), if_test, if_eof_code);
	primitive(TEX_STRING("iftrue"), if_test, if_true_code);
	primitive(TEX_STRING("iffalse"), if_test, if_false_code);
	primitive(TEX_STRING("ifcase"), if_test, if_case_code);

	// 491
	primitive(TEX_STRING("fi"), fi_or_else, fi_code);
	text(frozen_fi) = TEX_STRING("fi");
	eqtb[frozen_fi] = eqtb[cur_val];
	primitive(TEX_STRING("or"), fi_or_else, or_code);
	primitive(TEX_STRING("else"), fi_or_else, else_code);

	// 553
	primitive(TEX_STRING("nullfont"), set_font, null_font);
	text(frozen_null_font) = TEX_STRING("nullfont");
	eqtb[frozen_null_font] = eqtb[cur_val];

	// 780
	primitive(TEX_STRING("span"), tab_mark, span_code);
	primitive(TEX_STRING("cr"), car_ret, cr_code);
	text(frozen_cr) = TEX_STRING("cr");
	eqtb[frozen_cr] = eqtb[cur_val];
	primitive(TEX_STRING("crcr"), car_ret, cr_cr_code);
	text(frozen_end_template) = TEX_STRING("endtemplate");
	text(frozen_endv) = TEX_STRING("endtemplate");
	eq_type(frozen_endv) = endv;
	equiv(frozen_endv) = null_list;
	eq_level(frozen_endv) = level_one;
	eqtb[frozen_end_template] = eqtb[frozen_endv];
	eq_type(frozen_end_template) = end_template;

	// 983
	primitive(TEX_STRING("pagegoal"), set_page_dimen, 0);
	primitive(TEX_STRING("pagetotal"), set_page_dimen, 1);
	primitive(TEX_STRING("pagestretch"), set_page_dimen, 2);
	primitive(TEX_STRING("pagefilstretch"), set_page_dimen, 3);
	primitive(TEX_STRING("pagefillstretch"), set_page_dimen, 4);
	primitive(TEX_STRING("pagefilllstretch"), set_page_dimen, 5);
	primitive(TEX_STRING("pageshrink"), set_page_dimen, 6);
	primitive(TEX_STRING("pagedepth"), set_page_dimen, 7);

	// 1052
	primitive(TEX_STRING("end"), stop, 0);
	primitive(TEX_STRING("dump"), stop, 1);

	// 1058
	primitive(TEX_STRING("hskip"), hskip, skip_code);
	primitive(TEX_STRING("hfil"), hskip, fil_code);
	primitive(TEX_STRING("hfill"), hskip, fill_code);
	primitive(TEX_STRING("hss"), hskip, ss_code);
	primitive(TEX_STRING("hfilneg"), hskip, fil_neg_code);
	primitive(TEX_STRING("vskip"), vskip, skip_code);
	primitive(TEX_STRING("vfil"), vskip, fil_code);
	primitive(TEX_STRING("vfill"), vskip, fill_code);
	primitive(TEX_STRING("vss"), vskip, ss_code);
	primitive(TEX_STRING("vfilneg"), vskip, fil_neg_code);
	primitive(TEX_STRING("mskip"), mskip, mskip_code);
	primitive(TEX_STRING("kern"), kern, _explicit);
	primitive(TEX_STRING("mkern"), mkern, mu_glue);

	// 1071
	primitive(TEX_STRING("moveleft"), hmove, 1);
	primitive(TEX_STRING("moveright"), hmove, 0);
	primitive(TEX_STRING("raise"), vmove, 1);
	primitive(TEX_STRING("lower"), vmove, 0);
	primitive(TEX_STRING("box"), make_box, box_code);
	primitive(TEX_STRING("copy"), make_box, copy_code);
	primitive(TEX_STRING("lastbox"), make_box, last_box_code);
	primitive(TEX_STRING("vsplit"), make_box, vsplit_code);
	primitive(TEX_STRING("vtop"), make_box, vtop_code);
	primitive(TEX_STRING("vbox"), make_box, vtop_code + vmode);
	primitive(TEX_STRING("hbox"), make_box, vtop_code + hmode);
	primitive(TEX_STRING("shipout"), leader_ship, a_leaders - 1);
	primitive(TEX_STRING("leaders"), leader_ship, a_leaders);
	primitive(TEX_STRING("cleaders"), leader_ship, c_leaders);
	primitive(TEX_STRING("xleaders"), leader_ship, x_leaders);
		
	// 1088
	primitive(TEX_STRING("indent"), start_par, 1);
	primitive(TEX_STRING("noindent"), start_par, 0);

	// 1107
	primitive(TEX_STRING("unpenalty"), remove_item, penalty_node);
	primitive(TEX_STRING("unkern"), remove_item, kern_node);
	primitive(TEX_STRING("unskip"), remove_item, glue_node);
	primitive(TEX_STRING("unhbox"), un_hbox, box_code);
	primitive(TEX_STRING("unhcopy"), un_hbox, copy_code);
	primitive(TEX_STRING("unvbox"), un_vbox, box_code);
	primitive(TEX_STRING("unvcopy"), un_vbox, copy_code);

	// 1114
	primitive(TEX_STRING("-"), discretionary, 1);
	primitive(TEX_STRING("discretionary"), discretionary, 0);


	// 1141
	primitive(TEX_STRING("eqno"), eq_no, 0);
	primitive(TEX_STRING("leqno"), eq_no, 1);

	// 1156
	primitive(TEX_STRING("mathord"), math_comp, ord_noad);
	primitive(TEX_STRING("mathop"), math_comp, op_noad);
	primitive(TEX_STRING("mathbin"), math_comp, bin_noad);
	primitive(TEX_STRING("mathrel"), math_comp, rel_noad);
	primitive(TEX_STRING("mathopen"), math_comp, open_noad);
	primitive(TEX_STRING("mathclose"), math_comp, close_noad);
	primitive(TEX_STRING("mathpunct"), math_comp, punct_noad);
	primitive(TEX_STRING("mathinner"), math_comp, inner_noad);
	primitive(TEX_STRING("underline"), math_comp, under_noad);
	primitive(TEX_STRING("overline"), math_comp, over_noad);
	primitive(TEX_STRING("displaylimits"), limit_switch, normal);
	primitive(TEX_STRING("limits"), limit_switch, limits);
	primitive(TEX_STRING("nolimits"), limit_switch, no_limits);

	// 1168
	primitive(TEX_STRING("displaystyle"), math_style, display_style);
	primitive(TEX_STRING("textstyle"), math_style, text_style);
	primitive(TEX_STRING("scriptstyle"), math_style, script_style);
	primitive(TEX_STRING("scriptscriptstyle"), math_style, script_script_style);

	// 1178
	primitive(TEX_STRING("above"), above, above_code);
	primitive(TEX_STRING("over"), above, over_code);
	primitive(TEX_STRING("atop"), above, atop_code);
	primitive(TEX_STRING("abovewithdelims"), above, delimited_code + above_code);
	primitive(TEX_STRING("overwithdelims"), above, delimited_code + over_code);
	primitive(TEX_STRING("atopwithdelims"), above, delimited_code + atop_code);

	// 1188
	primitive(TEX_STRING("left"), left_right, left_noad);
	primitive(TEX_STRING("right"), left_right, right_noad);
	text(frozen_right) = TEX_STRING("right");
	eqtb[frozen_right] = eqtb[cur_val];

	//1208
	primitive(TEX_STRING("long"), prefix, 1);
	primitive(TEX_STRING("outer"), prefix, 2);
	primitive(TEX_STRING("global"), prefix, 4);
	primitive(TEX_STRING("def"), def, 0);
	primitive(TEX_STRING("gdef"), def, 1);
	primitive(TEX_STRING("edef"), def, 2);
	primitive(TEX_STRING("xdef"), def, 3);

	// 1218
	primitive(TEX_STRING("let"), let, normal);
	primitive(TEX_STRING("futurelet"), let, normal + 1);

	//1222
	primitive(TEX_STRING("chardef"), shorthand_def, char_def_code);
	primitive(TEX_STRING("mathchardef"), shorthand_def, math_char_def_code);
	primitive(TEX_STRING("countdef"), shorthand_def, count_def_code);
	primitive(TEX_STRING("dimendef"), shorthand_def, dimen_def_code);
	primitive(TEX_STRING("skipdef"), shorthand_def, skip_def_code);
	primitive(TEX_STRING("muskipdef"), shorthand_def, mu_skip_def_code);
	primitive(TEX_STRING("toksdef"), shorthand_def, toks_def_code);

	// 1230
	primitive(TEX_STRING("catcode"), def_code, cat_code_base);
	primitive(TEX_STRING("lccode"), def_code, lc_code_base);
	primitive(TEX_STRING("sfcode"), def_code, sf_code_base);
	primitive(TEX_STRING("textfont"), def_family, math_font_base);
	primitive(TEX_STRING("scriptfont"), def_family, math_font_base+script_size);
	primitive(TEX_STRING("scriptscriptfont"), def_family, math_font_base + script_script_size);
	primitive(TEX_STRING("mathcode"), def_code, math_code_base);
	primitive(TEX_STRING("uccode"), def_code, uc_code_base);
	primitive(TEX_STRING("delcode"), def_code, del_code_base);

	// 1249
	primitive(TEX_STRING("hyphenation"), hyph_data, 0);
	primitive(TEX_STRING("patterns"), hyph_data, 1);

	// 1254
	primitive(TEX_STRING("hyphenchar"), assign_font_int, 0);
	primitive(TEX_STRING("skewchar"), assign_font_int, 1);

	// 1262
	primitive(TEX_STRING("batchmode"), set_interaction, batch_mode);
	primitive(TEX_STRING("nonstopmode"), set_interaction, nonstop_mode);
	primitive(TEX_STRING("scrollmode"), set_interaction, scroll_mode);
	primitive(TEX_STRING("errorstopmode"), set_interaction, error_stop_mode);

	// 1272
	primitive(TEX_STRING("openin"), in_stream, 1);
	primitive(TEX_STRING("closein"), in_stream, 0);

	// 1277
	primitive(TEX_STRING("message"), message, 0);
	primitive(TEX_STRING("errmessage"), message, 1);

	// 1286
	primitive(TEX_STRING("lowercase"), case_shift, lc_code_base);
	primitive(TEX_STRING("uppercase"), case_shift, uc_code_base);

	// 1291
	primitive(TEX_STRING("show"), xray, show_code);
	primitive(TEX_STRING("showbox"), xray, show_box_code);
	primitive(TEX_STRING("showthe"), xray, show_the_code);
	primitive(TEX_STRING("showlists"), xray, show_lists);

	// 1344
	primitive(TEX_STRING("openout"), extension, open_node);
	primitive(TEX_STRING("write"), extension, write_node); write_loc = cur_val;
	primitive(TEX_STRING("closeout"), extension, close_node);
	primitive(TEX_STRING("special"), extension, special_node);
	primitive(TEX_STRING("immediate"), extension, immediate_code);
	primitive(TEX_STRING("setlanguage"), extension, set_language_code);

	#pragma endregion

	no_new_control_sequence = true;
}
#endif
//tini


// these are macros in tex.web but I use functions instead
// 1305

void dump_wd(memory_word memword)
{
	fwrite(&memword, sizeof memword, 1, fmt_file);
}

void dump_int(int n)
{
	fwrite(&n, sizeof n, 1, fmt_file);
}

void dump_hh(two_halves halves)
{
	fwrite(&halves, sizeof halves, 1, fmt_file);
}

void dump_qqqq(four_quarters fq)
{
	fwrite(&fq, sizeof fq, 1, fmt_file);
}

// 1306
void undump_wd(memory_word *memword)
{
	fread(memword, sizeof *memword, 1, fmt_file);
}

void undump_int(int *anint)
{
	fread(anint, sizeof *anint, 1, fmt_file);
}

void undump_hh(two_halves *hh)
{
	fread(hh, sizeof *hh, 1, fmt_file);
}

void undump_qqqq(four_quarters *qqqq)
{
	fread(qqqq, sizeof *qqqq, 1, fmt_file);
}



// 1302

//init
#ifndef NO_INIT
void store_fmt_file()
{
	int j, k, l;
	pointer p, q;
	int x;
	four_quarters w;

	#pragma region <If dumping is not allowed abort 1304>
	if (save_ptr != 0) {
		print_err(TEX_STRING("You can't dump inside a group"));
		help1(TEX_STRING("`{...\dump}' is a no-no."));
		succumb();
	}
	#pragma endregion

	#pragma region <Create the format_ident, open the format file and inform the user that dumping has begun 1328>
	selector = new_string;
	print(TEX_STRING(" (preloaded format="));
	print(job_name);
	print_char(TEX_STRING(" "));
	print_int(year);
	print_char(TEX_STRING("."));
	print_int(month);
	print_char(TEX_STRING("."));
	print_int(day);
	print_char(TEX_STRING(")"));
	if (interaction == batch_mode) selector = log_only;
	else
		selector = term_and_log;
	str_room(1); format_ident = make_string(); pack_job_name(format_extension);
	while (!w_open_out(&fmt_file)) prompt_file_name(TEX_STRING("format file name"), format_extension);

	print_nl(TEX_STRING("Beginning to dump on file "));
	slow_print(w_make_name_string(fmt_file));
	flush_string;
	print_nl(TEX_STRING(""));
	slow_print(format_ident);
	#pragma endregion

	#pragma region <Dump constants for consistency check 1307>
	dump_int(@$);
	dump_int(mem_bot);
	dump_int(mem_top);
	dump_int(eqtb_size);
	dump_int(hash_prime);
	dump_int(hyph_size);
	#pragma endregion

	#pragma region <Dump the string pool 1309>
	dump_int(pool_ptr); dump_int(str_ptr);
	for (k = 0; k <= str_ptr; k++) dump_int(str_start[k]);
	k = 0;
	while (k + 4 < pool_ptr) {
		dump_four_ASCII;
		k += 4;
	}
	k = pool_ptr - 4;
	dump_four_ASCII;
	print_ln();
	print_int(str_ptr);
	print(TEX_STRING(" strings of total length "));
	print_int(pool_ptr);
	#pragma endregion

	#pragma region <Dump the dynamic memory 1311>
	sort_avail();
	var_used = 0; dump_int(lo_mem_max);
	dump_int(rover);
	p = mem_bot;
	q = rover;
	x = 0;
	do {
		for (k = p; k <= q + 1; k++) dump_wd(mem[k]);
		x = x + q + 2 - p; var_used = var_used + q - p; p = q + node_size(q); q = rlink(q);
	} while (!(q == rover));
	var_used = var_used + lo_mem_max - p; dyn_used = mem_end + 1 - hi_mem_min;
	for (k = p; k <= lo_mem_max; k++) dump_wd(mem[k]);
	x = x + lo_mem_max + 1 - p; dump_int(hi_mem_min); dump_int(avail);
	for (k = hi_mem_min; k <= mem_end; k++) dump_wd(mem[k]);
	x = x + mem_end + 1 - hi_mem_min; p = avail;
	while (p != null) {
		decr(dyn_used); p = link(p);
	}
	dump_int(var_used); dump_int(dyn_used); print_ln(); print_int(x);
	print(TEX_STRING(" memory locations dumped; current usage is "));
	print_int(var_used); print_char(TEX_STRING("&"));
	print_int(dyn_used);
	#pragma endregion

	#pragma region <Dump the table of equivalents 1313>
	#pragma region <Dump regions 1 to 4 of eqtb 1315>
	k = active_base;
	do { 
		j = k;
		while (j < int_base - 1) {
			if (equiv(j) == equiv(j + 1) && eq_type(j) == eq_type(j + 1) && eq_level(j) == eq_level(j + 1))
				goto found1;
			incr(j);
		}
		l = int_base; goto done1;
	found1:
		incr(j); l = j;
		while (j < int_base - 1) {
			if (equiv(j) != equiv(j + 1) || eq_type(j) != eq_type(j + 1) || eq_level(j) != eq_level(j + 1))
				goto done1;
			incr(j);
		}
	done1:
		dump_int(l - k);
		while (k < l) {
			dump_wd(eqtb[k]); incr(k);
		}
		k = j + 1; dump_int(k - l);
	} while (!(k == int_base));
	#pragma endregion

		
	#pragma region <Dump regions 5 and 6 of eqtb 1316>
	do {
		j = k;
		while (j < eqtb_size) {
			if (eqtb[j].an_int == eqtb[j + 1].an_int)
				goto found2;
			incr(j);
		}
		l = eqtb_size + 1; goto done2;
	found2:
		incr(j); l = j;
		while (j < eqtb_size) {
			if (eqtb[j].an_int != eqtb[j + 1].an_int)
				goto done2;
			incr(j);
		}
	done2:
		dump_int(l - k);
		while (k < l) {
			dump_wd(eqtb[k]); incr(k);
		}
		k = j + 1; dump_int(k - l);
	} while (!(k > eqtb_size));
	#pragma endregion


	dump_int(par_loc); dump_int(write_loc);

	#pragma region <dump the hash table 1318>
	dump_int(hash_used); cs_count = frozen_control_sequence - 1 - hash_used;
	for(p = hash_base; p<=hash_used;p++)
		if (text(p) != 0) {
			dump_int(p); dump_hh(hash[p]); incr(cs_count);
		}
	for (p = hash_used + 1; p <= undefined_control_sequence - 1; p++) dump_hh(hash[p]);
	dump_int(cs_count);
	print_ln();
	print_int(cs_count);
	print(TEX_STRING(" multiletter control sequences"));
	#pragma endregion

	#pragma endregion

	#pragma region <Dump the font information 1320>
	dump_int(fmem_ptr);
	for (k = 0; k <= fmem_ptr - 1; k++) dump_wd(font_info[k]);
	dump_int(font_ptr);
	for (k = null_font; k <= font_ptr; k++)
	#pragma region <Dump the array info for internal font number k 1322>
	{
		dump_qqqq(font_check[k]); dump_int(font_size[k]); dump_int(font_dsize[k]);
		dump_int(font_params[k]);
		dump_int(hyphen_char[k]); dump_int(skew_char[k]);
		dump_int(font_name[k]); dump_int(font_area[k]);
		dump_int(font_bc[k]); dump_int(font_ec[k]);
		dump_int(char_base[k]); dump_int(width_base[k]); dump_int(height_base[k]);
		dump_int(depth_base[k]); dump_int(italic_base[k]); dump_int(lig_kern_base[k]);
		dump_int(kern_base[k]); dump_int(exten_base[k]); dump_int(param_base[k]);
		dump_int(font_glue[k]);
		dump_int(bchar_label[k]); dump_int(font_bchar[k]); dump_int(font_false_bchar[k]);
		print_nl(TEX_STRING("\font")); print_esc(font_id_text(k)); 
		print_char(TEX_STRING("="));
		print_file_name(font_name[k], font_area[k], TEX_STRING(""));
		if (font_size[k] != font_dsize[k]) {
			print(TEX_STRING(" at ")); print_scaled(font_size[k]);
			print(TEX_STRING("pt"));
		}
	}
	#pragma endregion

	print_ln(); print_int(fmem_ptr - 7); print(TEX_STRING(" words of font info for "));
	print_int(font_ptr - font_base); print(TEX_STRING(" preloaded font"));
	if (font_ptr != font_base + 1) print_char(TEX_STRING("s"));
	#pragma endregion

	#pragma region <Dump the hyphenation tables 1324>
	dump_int(hyph_count);
	for(k =0;k<=hyph_size;k++)
		if (hyph_word[k] != 0) {
			dump_int(k); dump_int(hyph_word[k]); dump_int(hyph_list[k]);
		}
	print_ln(); print_int(hyph_count); print(TEX_STRING(" hyphenation exception"));
	if (hyph_count != 1) print_char(TEX_STRING("s"));
	if (trie_not_ready) init_trie();
	dump_int(trie_max);
	for (k = 0; k <= trie_max; k++) dump_hh(trie[k]);
	dump_int(trie_op_ptr);
	for (k = 1; k <= trie_op_ptr; k++) {
		dump_int(hyf_distance[k]); dump_int(hyf_num[k]); dump_int(hyf_next[k]);
	}
	print_nl(TEX_STRING("Hyphenation trie of length "));
	print_int(trie_max); print(TEX_STRING(" has "));
	print_int(trie_op_ptr); print(TEX_STRING(" op"));
	if (trie_op_ptr != 1) print_char(TEX_STRING("s"));
	print(TEX_STRING(" out of ")); print_int(trie_op_size);
	for (k=256; k--;)
		if (trie_used[k] > min_quarterword) {
			print_nl(TEX_STRING("  ")); print_int(qo(trie_used[k]));
			print(TEX_STRING(" for language ")); print_int(k);
			dump_int(k); dump_int(qo(trie_used[k]));
		}
	#pragma endregion

	#pragma region <Dump a couple more things and the closing check word 1326>
	dump_int(interaction); dump_int(format_ident); dump_int(69069);
	tracing_stats = 0;
	#pragma endregion

	#pragma region <Close the format file 1329>
	w_close(fmt_file);

	#pragma endregion
}
#endif
//tini

int main(int argc, char **argv)
{
	// 1332
	history = fatal_error_stop;
	// t_open_out open the terminal for ouput
	// no need to do this in C

	set_paths();
	
	#pragma region <check the constant values for consistency 14>
	bad = 0;
	if (half_error_line<30 || half_error_line > error_line - 15) bad = 1;
	if (max_print_line < 60) bad = 2;
	if (dvi_buf_size % 8 != 0) bad = 3;
	if (mem_bot + 1100 > mem_top) bad = 4;
	if (hash_prime > hash_size) bad = 5;
	if (max_in_open >= 128) bad = 6;
	if (mem_top < 256 + 11) bad = 7;

	// 111
	//init
#ifndef NO_INIT	
	if (mem_min != mem_bot || mem_max != mem_top) bad = 10;
#endif
	//tini
	if (mem_min > mem_bot || mem_max < mem_top) bad = 10;
	if (min_quarterword > 0 || max_quarterword < 127) bad = 11;
	if (min_halfword > 0 || max_halfword < 32767) bad = 12;
	if (min_quarterword < min_halfword || max_quarterword > max_halfword) bad = 13;
	if (mem_min < min_halfword || mem_max >= max_halfword ||
		mem_bot - mem_min > max_halfword + 1) bad = 14;
	if (font_base < min_quarterword || font_max > max_quarterword) bad = 15;
	if (font_max > font_base + 256) bad = 16;
	if (save_size > max_halfword) bad = 18;
	if (max_quarterword - min_quarterword < 255) bad = 19;

	//290
	if (cs_token_flag + undefined_control_sequence > max_halfword) bad = 21;

	// 522
	if (format_default_length > file_name_size) bad = 31;

	// 1249
	if (2 * max_halfword < mem_top - mem_min) bad = 41;
	

	#pragma endregion

	if (bad > 0) {
		wterm_ln_s("Ouch---my internal constants have been clobbered");
		goto final_end;
	}
	initialize();
	//init
#ifndef NO_INIT
	if (!get_strings_started())
		goto final_end;
	init_prim();
	init_str_ptr = str_ptr; init_pool_ptr = pool_ptr; fix_date_and_time();
#endif
	//tini

	#pragma region <Initialize the output routines 55>
	selector = term_only; tally = 0; term_offset = 0; file_offset = 0;

	char formatname[257];
	formatname[0] = 0;

	if (argc > 1) {
		// check for format=
		if (argv[1][0] == '-') {
			if (strlen(argv[1] + 1) > 8 && strncmp(argv[1] + 1, "format=", 7) == 0)
				strcpy(formatname, argv[1] + 8);
		}
	}

	if (formatname[0] != 0) {
		size_t flen = strlen(formatname);
		if (flen > 4 && strcmp(formatname + flen - 4, ".fmt") == 0)
			;
		else {
			if (flen + 4 < sizeof formatname - 1)
				strcat(formatname, ".fmt");
		}

		strcpy(name_of_file.get_c_str(), formatname);
		bool fmt_loaded = false;
		if (w_open_in(&fmt_file)) {
			fmt_loaded = load_fmt_file();
			w_close(fmt_file);
		}
		if (!fmt_loaded) {
			printf("! Error loading format file %s\n", formatname);
			goto final_end;
		}
	}
	
	// 61
	wterm_s(banner);
	if (format_ident == 0) wterm_ln_s(" (no format preloaded)");
	else {
		slow_print(format_ident);
		print_ln();
	}
	update_terminal();

	// 528
	job_name = 0; name_in_progress = false; log_opened = false;

	//533
	output_file_name = 0;

	#pragma endregion

	#pragma region <Get the first line of input and prepare to start 1337

	#pragma region <Initialize the input routines 331>
	input_ptr = 0; max_in_stack = 0; in_open = 0; open_parens = 0; max_buf_stack = 0;
	param_ptr = 0; max_param_stack = 0; first = buf_size;
	do { buffer[first] = 0; decr(first);
	} while (!(first == 0));
	scanner_status = normal; warning_index = null; first = 1; state = new_line; start = 1; index = (enum_token_type)0;
	line = 0; name = 0; force_eof = false; align_state = 1000000;
	if (!init_terminal(argc, argv)) goto final_end;
	limit = last; first = last + 1;
	#pragma endregion

	if (format_ident == 0 || buffer[loc] == TEX_STRING("&")) {
		if (format_ident != 0) initialize();
		if (!open_fmt_file()) goto final_end;
		if (!load_fmt_file()) {
			w_close(fmt_file);
			goto final_end;
		}
		w_close(fmt_file);
		while (loc < limit&&buffer[loc] == TEX_STRING(" ")) incr(loc);
	}
	if (end_line_char_inactive) decr(limit);
	else buffer[limit] = end_line_char;
	fix_date_and_time();

	#pragma region <Compute the magic offset 765>
	magic_offset = str_start[math_spacing] - 9 * ord_noad;
	#pragma endregion

	#pragma region <Initialize the print selector based on interaction 75>
	if (interaction == batch_mode) selector = no_print;
	else selector = term_only;
	#pragma endregion

	if (loc < limit && cat_code(buffer[loc]) != escape) start_input();

	#pragma endregion

	history = spotless;
	main_control();
	final_cleanup();


	do_end_of_TEX();
	
final_end:
	do_final_end();

	return 0;
}

