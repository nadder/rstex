/*
This program, let's call it rsTeX to not confuse it with any other TeX system
is copyright (C) 2018 by Richard Sandberg (mylodon at gmail dot com).
The original tex.web is copyright (C) 1982 by Donald Knuth.

License,
This program is for educational purpose only, all commercial use
is strictly forbidden.

This is a manual translation of tex.web version 3.14159265 into C++.
Mostly it's a direct translation of the original pascal source with very minimal changes.
The amount of C++ (that is not also C) used is very minimal. Notably I added an array
class to keep the same indexing as in the orignal and to also get boundschecking.
With some work it's possible to use straight C arrays instead but this will make
the code alot more cluttered. I also use the stream classes to print statistics,
this can easily be changed to C format routines instead, if one wishes.
But who has a C compiler and no C++ compiler these days? The C++ compiler needs
to support C++11 or later. If not it's probably not too much work to change
the few places where I use those features.

What is the purpose of this program? Well, I've long been fascinated by
Donald Knuth and his work and especially TeX. TeX is one of the most well
documented programs out there and the source code is of course readily available
but, one lacking feature of current implementations is that because the source code is
machine converted into C it's not easy to understand or step through the code
in a debugger. So that's why I decided to translate the program to C++. By doing so
one also hopefully gains some understanding of what the code does.
Another aspect was that I was interested in knowing how long it would take
to write the program. I didn't keep a stop watch at hand but a rough estimate is
that it took about 30 hours to type the whole program in and more than twice that to
fix all typos and other bugs introduced. Which was kind of what I expected except I 
thought the debugging time would be on par with the time it took to type it in.
Had I been more systematic in my approach and introduced more asserts and checks
from the beginning the debugging time would have been considerably shorter.

The program consists of two files rstex.h.pre and rstex.cpp.pre.
These two files must be preprocessed by another program which converts all
special strings in the program to numbers (as the original tangle program does),
and makes a string pool file.
After this preprocessing we are left with three files rstex.h,
rstex.cpp, and tex.pool.
rstex.cpp can then be compiled by any non-ancient C++ compiler, and the executable can be run.

Notable omissions:
* Currently no path searching is done so all files the program needs are supposed
  to exist in the current directory. (Maybe should add checking of a few locations given by env. vars).
* No special defines for excluding init, stat, or debug code (most likely easy to add these),
  although I don't think it hurts much to keep it in.
* No other files needed for a complete system is included, i.e. fmt files, fonts, tfm files
  macro packages etc.

Disclaimer,
This is NOT the official version of TeX, it is only based upon the official version of TeX.
It may contain bugs not present in the official version. It does pass the trip test,
but the trip test does not test everything. In no way shall the author of this program
be responsible for any damages, direct or indirect, that may result out of its use.
It is not meant to be a working typesetting system, it is meant for educational purpose,
for those who want to understand how this complex software works.

*/

#pragma once
#include <cstdio>
#include <cassert>
template<typename T, int minindex, int maxindex>
class Array
{
public:
	Array()  {}
	T& operator[](int x) {
		assert(x >= minindex && x <= maxindex);
		return _array[x - minindex];
	}

	T* get_c_str() {
		assert(sizeof _array / sizeof *_array > 0);
		_array[sizeof _array / sizeof *_array - 1] = T(0);
		return &_array[0];
	}

private:
	T _array[maxindex - minindex + 1];
};

// 2
#define banner "This is rsTeX, Version 1.0.1"

// 36
#define loc cur_input.loc_field

// 11
const int mem_max = 30000;
//const int mem_max = 3000; // triptex
const int mem_min = 0;
//const int mem_min = 1; // triptex
const int buf_size = 500;
const int error_line = 72;
//const int error_line = 64; // triptex
const int half_error_line = 42;
//const int half_error_line = 32; // triptex
const int max_print_line = 79;
//const int max_print_line = 72; // triptex
const int stack_size = 200;
const int max_in_open = 6;
const int font_max = 75;
const int font_mem_size = 20000;
const int param_size = 60;
const int nest_size = 40;
const int max_strings = 3000;
const int string_vacancies = 8000;
const int pool_size = 40000;
const int save_size = 600;
const int trie_size = 8000;
const int trie_op_size = 500;
const int dvi_buf_size = 800;
const int file_name_size = 40;
const char pool_name[file_name_size+1] = "tex.pool";

// 13
int bad;

// 18
typedef unsigned char ASCII_code;

// 19
typedef unsigned char text_char;
const int first_text_char = 0;
const int last_text_char = 255;

// 20
Array<ASCII_code, 0, 255> xord;
Array<text_char, 0, 255> xchr;

// 38
#define so(s) s
#define si(s) s

typedef int str_number; // 0.. max_strings
typedef int pool_pointer; // 0 .. pool_size
typedef unsigned char packed_ASCII_code; // 0 .. 255

// 25
typedef unsigned char eight_bits;
typedef FILE* alpha_file;
typedef FILE* byte_file;

// 32
alpha_file term_in = stdin;
alpha_file term_out = stdout;

// 39
Array<packed_ASCII_code, 0, pool_size> str_pool;
Array<pool_pointer, 0, max_strings> str_start;
pool_pointer pool_ptr;
str_number str_ptr;
pool_pointer init_pool_ptr;
str_number init_str_ptr;

// 50
alpha_file pool_file;

// 54
const int no_print = 16;
const int term_only = 17;
const int log_only = 18;
const int term_and_log = 19;
const int pseudo = 20;
const int new_string = 21;
const int max_selector = 21;

alpha_file log_file;
int selector;
unsigned char dig[23];
int tally;
int term_offset;
int file_offset;

Array<ASCII_code, 0, error_line> trick_buf;
int trick_count;
int first_count;

// 56
#define wterm_s(s) fputs(s, term_out)
#define wterm_c(s) fputc(s, term_out)
#define wterm_ln_s(s) do {fputs(s, term_out);fputc('\n',term_out);} while(0)
#define wterm_cr fputc('\n',term_out)
#define wlog_s(s) do{\
  fputs(s, log_file);\
}while(0)

#define wlog_c(s) do{\
  fputc(s, log_file);\
}while(0)

#define wlog_ln_s(s) do{\
  fputs(s, log_file);\
  fputc('\n', log_file);\
}while (0)

#define wlog_cr do{\
  fputc('\n',log_file);\
}while(0)

// 16
#define negate(s) (s = -s)
#define incr(n) (n++)
#define decr(n) (n--)
const int empty = 0;

// 40
#define length(num) (str_start[num+1]-str_start[num])

// 41
#define cur_length (pool_ptr - str_start[str_ptr])

// 42
#define append_char(thechar) do{\
  str_pool[pool_ptr]=thechar;\
  pool_ptr++;\
}while(0)

#define flush_char pool_ptr--

#define str_room(num) do{\
  if (pool_ptr + num > pool_size)\
    overflow(TEX_STRING("pool size"), pool_size - init_pool_ptr);\
}while(0)

// 44
#define flush_string do {\
  str_ptr--;\
  pool_ptr = str_start[str_ptr];\
}while(0)

//48
#define app_lc_hex(num) do {\
  l=num;\
  if(l<10)\
    append_char(l+TEX_STRING("0"));\
  else append_char(l-10+TEX_STRING("a"));\
}while(0)

// 51
// Add extra parameter if we should close the file
#define bad_pool(str, do_close) do {\
  puts(str);\
  if(do_close) a_close(pool_file);\
  return false;\
} while(0)

// 68
#define print_ASCII print

// 71
#define prompt_input(s) do{\
  wake_up_terminal();\
  print(s);\
  term_input();\
}while(0)

// 73
const int batch_mode = 0;
const int nonstop_mode = 1;
const int scroll_mode = 2;
const int error_stop_mode = 3;

unsigned char interaction;

#define print_err(s) do {\
  if(interaction == error_stop_mode)\
    wake_up_terminal();\
  print_nl(TEX_STRING("! "));\
  print(s);\
} while(0)

// 76
const int spotless = 0;
const int warning_issued = 1;
const int error_message_issued = 2;
const int fatal_error_stop = 3;

bool deletions_allowed;
bool set_box_allowed;
int history;
int error_count; // -1..100

// 79

#define help0 (help_ptr=0)
#define help1(s) do{help_ptr = 1;help_line[0]=s;}while(0)
#define help2(s1,s2) do{help_ptr=2;help_line[1]=s1;help_line[0] = s2;}while(0)
#define help3(s1,s2,s3) do{help_ptr=3;help_line[2]=s1;help_line[1] = s2;help_line[0] = s3;}while(0)
#define help4(s1,s2,s3,s4) do{help_ptr=4;help_line[3]=s1;help_line[2] = s2;help_line[1] = s3;help_line[0]=s4;}while(0)
#define help5(s1,s2,s3,s4,s5) do{help_ptr=5;help_line[4] = s1;help_line[3]=s2;help_line[2] = s3;help_line[1] = s4;help_line[0]=s5;}while(0)
#define help6(s1,s2,s3,s4,s5,s6) do{help_ptr=6;help_line[5] = s1;help_line[4] = s2;help_line[3]=s3;help_line[2] = s4;help_line[1] = s5;help_line[0]=s6;}while(0)

//str_number help_line[6];
Array<str_number, 0, 5> help_line;
char help_ptr;
bool use_err_help;

// 93
#define succumb do{\
  if(interaction==error_stop_mode)\
    interaction=scroll_mode;\
  if(log_opened)\
    error();\
/*debug*/\
  if(interaction > batch_mode)\
    debug_help();\
/*gubed*/\
  history=fatal_error_stop;\
  jump_out();\
}\
while(0)

// 96
#define check_interrupt if(interrupt!=0)pause_for_instructions()

int interrupt;
bool OK_to_interrupt;

// 12
const int mem_bot = 0;
//const int mem_bot = 1; // triptex
const int mem_top = 30000;
//const int mem_top = 3000; // triptex
const int font_base = 0;
const int hash_size = 2100;
const int hash_prime = 1777;
const int hyph_size = 307;

// 22
const int null_code = 0;
const int carriage_return = 13;
const int invalid_code = 127;

// 26
Array<char, 1, file_name_size+1> name_of_file;
int name_length;

// 30
int first;
int last;
int max_buf_stack;

Array<ASCII_code, 0, buf_size> buffer;

//101
const int unity = 0200000;
const int two = 0400000;
typedef int scaled;
typedef int nonnegative_integer; // 0..017777777777
typedef int small_number; // 0.. 63

// 110
const int min_quarterword = 0;
const int max_quarterword = 255;
const int min_halfword = 0;
const int max_halfword = 65535;

// 113
#define sc union_t.an_int

typedef unsigned char quarterword;
typedef unsigned short halfword;
typedef unsigned char two_choices;
typedef unsigned char four_choices;

// 121
// make this function instead
//#define free_avail(s) do{link(s) = avail;avail=s;/*stat*/decr(dyn_used);/*tats*/}while(0)

// 221
#define eq_level_field(s) s.union_t.hh.union_t.struct_t.b1
#define eq_type_field(s) s.union_t.hh.union_t.struct_t.b0
#define equiv_field(s) s.union_t.hh.rh
#define eq_level(s) eq_level_field(eqtb[s])
#define eq_type(s) eq_type_field(eqtb[s])
#define equiv(s) equiv_field(eqtb[s])
const int level_zero = min_quarterword;
const int level_one = level_zero + 1;

// Region 2 of eqtb
// 222
enum equiv_region2_code : halfword
{
	active_base = 1,
	single_base = active_base + 256,
	null_cs = single_base + 256,
	hash_base = null_cs + 1,
	frozen_control_sequence = hash_base + hash_size,
	frozen_protection = frozen_control_sequence,
	frozen_cr = frozen_control_sequence + 1,
	frozen_end_group = frozen_control_sequence + 2,
	frozen_right = frozen_control_sequence + 3,
	frozen_fi = frozen_control_sequence + 4,
	frozen_end_template = frozen_control_sequence + 5,
	frozen_endv = frozen_control_sequence + 6,
	frozen_relax = frozen_control_sequence + 7,
	end_write = frozen_control_sequence + 8,
	frozen_dont_expand = frozen_control_sequence + 9,
	frozen_null_font = frozen_control_sequence + 10,
	font_id_base = frozen_null_font - font_base,
	undefined_control_sequence = frozen_null_font + 257,
	glue_base = undefined_control_sequence + 1,
};

// Region 3 of eqtb
// 224
enum equiv_region3_code : halfword
{
	line_skip_code = 0,
	baseline_skip_code = 1,
	par_skip_code = 2,
	above_display_skip_code = 3,
	below_display_skip_code = 4,
	above_display_short_skip_code = 5,
	below_display_short_skip_code = 6,
	left_skip_code = 7,
	right_skip_code = 8,
	top_skip_code = 9,
	split_top_skip_code = 10,
	tab_skip_code = 11,
	space_skip_code = 12,
	xspace_skip_code = 13,
	par_fill_skip_code = 14,
	thin_mu_skip_code = 15,
	med_mu_skip_code = 16,
	thick_mu_skip_code = 17,

};
const int glue_pars = 18;
const int skip_base = glue_base + glue_pars;
const int mu_skip_base = skip_base + 256;
const int local_base = mu_skip_base + 256;

#define skip(s) equiv(skip_base + s)
#define mu_skip(s) equiv(mu_skip_base+s)
#define glue_par(s) equiv(glue_base+s)
#define line_skip glue_par(line_skip_code)
#define baseline_skip glue_par(baseline_skip_code)
#define par_skip glue_par(par_skip_code)
#define above_display_skip glue_par(above_display_skip_code)
#define below_display_skip glue_par(below_display_skip_code)
#define above_display_short_skip glue_par(above_display_short_skip_code)
#define below_display_short_skip glue_par(below_display_short_skip_code)
#define left_skip glue_par(left_skip_code)
#define right_skip glue_par(right_skip_code)
#define top_skip glue_par(top_skip_code)
#define split_top_skip glue_par(split_top_skip_code)
#define tab_skip glue_par(tab_skip_code)
#define space_skip glue_par(space_skip_code)
#define xspace_skip glue_par(xspace_skip_code)
#define par_fill_skip glue_par(par_fill_skip_code)
#define thin_mu_skip glue_par(thin_mu_skip_code)
#define med_mu_skip glue_par(med_mu_skip_code)
#define thick_mu_skip glue_par(thick_mu_skip_code)

// region 4 of eqtb
// 230
enum equiv_region4_loc : halfword
{
	par_shape_loc = local_base,
	output_routine_loc = local_base + 1,
	every_par_loc = local_base + 2,
	every_math_loc = local_base + 3,
	every_display_loc = local_base + 4,
	every_hbox_loc = local_base + 5,
	every_vbox_loc = local_base + 6,
	every_job_loc = local_base + 7,
	every_cr_loc = local_base + 8,
	err_help_loc = local_base + 9,
	toks_base = local_base + 10,
	box_base = toks_base + 256,
	cur_font_loc = box_base + 256,
};

const int math_font_base = cur_font_loc + 1;
const int cat_code_base = math_font_base + 48;
const int lc_code_base = cat_code_base + 256;
const int uc_code_base = lc_code_base + 256;
const int sf_code_base = uc_code_base + 256;
const int math_code_base = sf_code_base + 256;
const int int_base = math_code_base + 256;

#define par_shape_ptr equiv(par_shape_loc)
#define output_routine equiv(output_routine_loc)
#define every_par equiv(every_par_loc)
#define every_math equiv(every_math_loc)
#define every_display equiv(every_display_loc)
#define every_hbox equiv(every_hbox_loc)
#define every_vbox equiv(every_vbox_loc)
#define every_job equiv(every_job_loc)
#define every_cr equiv(every_cr_loc)
#define err_help equiv(err_help_loc)
#define toks(s) equiv(toks_base+s)
#define box(s) equiv(box_base + s)
#define cur_font equiv(cur_font_loc)
#define fam_fnt(s) equiv(math_font_base+s)
#define cat_code(s) equiv(cat_code_base+s)
#define lc_code(s) equiv(lc_code_base+s)
#define uc_code(s) equiv(uc_code_base+s)
#define sf_code(s) equiv(sf_code_base+s)
#define math_code(s) equiv(math_code_base+s)

// 232
#define null_font font_base
const int var_code = 070000;

// 247
enum equiv_region6_code : halfword
{
	par_indent_code = 0,
	math_surround_code = 1,
	line_skip_limit_code = 2,
	hsize_code = 3,
	vsize_code = 4,
	max_depth_code = 5,
	split_max_depth_code = 6,
	box_max_depth_code = 7,
	hfuzz_code = 8,
	vfuzz_code = 9,
	delimiter_shortfall_code = 10,
	null_delimiter_space_code = 11,
	script_space_code = 12,
	pre_display_size_code = 13,
	display_width_code = 14,
	display_indent_code = 15,
	overfull_rule_code = 16,
	hang_indent_code = 17,
	h_offset_code = 18,
	v_offset_code = 19,
	emergency_stretch_code = 20,
};

const int dimen_pars = 21;

//const int scaled_base = dimen_base + dimen_pars; // moved this below eqtb five becuase dimen base is defined there
//const int eqtb_size = scaled_base + 255; // moved this below eqtb five 

#define dimen(s) (eqtb[scaled_base+s].sc)
#define dimen_par(s) (eqtb[dimen_base+s].sc)
#define par_indent dimen_par(par_indent_code)
#define math_surround dimen_par(math_surround_code)
#define line_skip_limit dimen_par(line_skip_limit_code)
#define hsize dimen_par(hsize_code)
#define vsize dimen_par(vsize_code)
#define max_depth dimen_par(max_depth_code)
#define split_max_depth dimen_par(split_max_depth_code)
#define box_max_depth dimen_par(box_max_depth_code)
#define hfuzz dimen_par(hfuzz_code)
#define vfuzz dimen_par(vfuzz_code)
#define delimiter_shortfall dimen_par(delimiter_shortfall_code)
#define null_delimiter_space dimen_par(null_delimiter_space_code)
#define script_space dimen_par(script_space_code)
#define pre_display_size dimen_par(pre_display_size_code)
#define display_width dimen_par(display_width_code)
#define display_indent dimen_par(display_indent_code)
#define overfull_rule dimen_par(overfull_rule_code)
#define hang_indent dimen_par(hang_indent_code)
#define h_offset dimen_par(h_offset_code)
#define v_offset dimen_par(v_offset_code)
#define emergency_stretch dimen_par(emergency_stretch_code)

// 236
// Region five of eqtb
enum equiv_region5_code : halfword
{
	pretolerance_code = 0,
	tolerance_code = 1,
	line_penalty_code = 2,
	hyphen_penalty_code = 3,
	ex_hyphen_penalty_code = 4,
	club_penalty_code = 5,
	widow_penalty_code = 6,
	display_widow_penalty_code = 7,
	broken_penalty_code = 8,
	bin_op_penalty_code = 9,
	rel_penalty_code = 10,
	pre_display_penalty_code = 11,
	post_display_penalty_code = 12,
	inter_line_penalty_code = 13,
	double_hyphen_demerits_code = 14,
	final_hyphen_demerits_code = 15,
	adj_demerits_code = 16,
	mag_code = 17,
	delimiter_factor_code = 18,
	looseness_code = 19,
	time_code = 20,
	day_code = 21,
	month_code = 22,
	year_code = 23,
	show_box_breadth_code = 24,
	show_box_depth_code = 25,
	hbadness_code = 26,
	vbadness_code = 27,
	pausing_code = 28,
	tracing_online_code = 29,
	tracing_macros_code = 30,
	tracing_stats_code = 31,
	tracing_paragraphs_code = 32,
	tracing_pages_code = 33,
	tracing_output_code = 34,
	tracing_lost_chars_code = 35,
	tracing_commands_code = 36,
	tracing_restores_code = 37,
	uc_hyph_code = 38,
	output_penalty_code = 39,
	max_dead_cycles_code = 40,
	hang_after_code = 41,
	floating_penalty_code = 42,
	global_defs_code = 43,
	cur_fam_code = 44,
	escape_char_code = 45,
	default_hyphen_char_code = 46,
	default_skew_char_code = 47,
	end_line_char_code = 48,
	new_line_char_code = 49,
	language_code = 50,
	left_hyphen_min_code = 51,
	right_hyphen_min_code = 52,
	holding_inserts_code = 53,
	error_context_lines_code = 54,
};

const int int_pars = 55;
const int count_base = int_base + int_pars;
const int del_code_base = count_base + 256;
const int dimen_base = del_code_base + 256;
const int scaled_base = dimen_base + dimen_pars; // moved this from up above in eqtb four becuase dimen base is defined here

const int eqtb_size = scaled_base + 255; // moved this below scaled base

#define del_code(s) (eqtb[del_code_base+s].union_t.an_int)
#define count(s) (eqtb[count_base+s].union_t.an_int)
#define int_par(s) (eqtb[int_base+s].union_t.an_int)

#define pretolerance int_par(pretolerance_code);
#define tolerance int_par(tolerance_code)
#define line_penalty int_par(line_penalty_code)
#define hyphen_penalty int_par(hyphen_penalty_code)
#define ex_hyphen_penalty int_par(ex_hyphen_penalty_code)
#define club_penalty int_par(club_penalty_code)
#define widow_penalty int_par(widow_penalty_code)
#define display_widow_penalty int_par(display_widow_penalty_code)
#define broken_penalty int_par(broken_penalty_code)
#define bin_op_penalty int_par(bin_op_penalty_code)
#define rel_penalty int_par(rel_penalty_code)
#define pre_display_penalty int_par(pre_display_penalty_code)
#define post_display_penalty int_par(post_display_penalty_code)
#define inter_line_penalty int_par(inter_line_penalty_code)
#define double_hyphen_demerits int_par(double_hyphen_demerits_code)
#define final_hyphen_demerits int_par(final_hyphen_demerits_code)
#define adj_demerits int_par(adj_demerits_code)
#define mag int_par(mag_code)
#define delimiter_factor int_par(delimiter_factor_code)
#define looseness int_par(looseness_code)
#define _time int_par(time_code)
#define day int_par(day_code)
#define month int_par(month_code)
#define year int_par(year_code)
#define show_box_breadth int_par(show_box_breadth_code)
#define show_box_depth int_par(show_box_depth_code)
#define hbadness int_par(hbadness_code)
#define vbadness int_par(vbadness_code)
#define pausing int_par(pausing_code)
#define tracing_online int_par(tracing_online_code)
#define tracing_macros int_par(tracing_macros_code)
#define tracing_stats int_par(tracing_stats_code)
#define tracing_paragraphs int_par(tracing_paragraphs_code)
#define tracing_pages int_par(tracing_pages_code)
#define tracing_output int_par(tracing_output_code)
#define tracing_lost_chars int_par(tracing_lost_chars_code)
#define tracing_commands int_par(tracing_commands_code)
#define tracing_restores int_par(tracing_restores_code)
#define uc_hyph int_par(uc_hyph_code)
#define output_penalty int_par(output_penalty_code)
#define max_dead_cycles int_par(max_dead_cycles_code)
#define hang_after int_par(hang_after_code)
#define floating_penalty int_par(floating_penalty_code)
#define global_defs int_par(global_defs_code)
#define cur_fam int_par(cur_fam_code)
#define escape_char int_par(escape_char_code)
#define default_hyphen_char int_par(default_hyphen_char_code)
#define default_skew_char int_par(default_skew_char_code)
#define end_line_char int_par(end_line_char_code)
#define new_line_char int_par(new_line_char_code)
#define language int_par(language_code)
#define left_hyphen_min int_par(left_hyphen_min_code)
#define right_hyphen_min int_par(right_hyphen_min_code)
#define holding_inserts int_par(holding_inserts_code)
#define error_context_lines int_par(error_context_lines_code)

// 104
bool arith_error;
scaled _remainder;

// 105
#define nx_plus_y(s1,s2,s3) (mult_and_add(s1,s2,s3,07777777777))
#define mult_integers(s1,s2) (mult_and_add(s1,s2,0,017777777777))

// 108
const int inf_bad = 10000;

// 109
#define set_glue_ratio_zero(n) n=0.0
#define set_glue_ratio_one(n) n=1.0
#define _float(n) (float)n
#define unfloat(n) glue_ratio(n)

// No need to use this macro
//#define float_constant(n) n.0

typedef float glue_ratio;

// 112
#define qi(n) (n+min_quarterword)
#define qo(n) (n-min_quarterword)
#define hi(n) (n+min_halfword)
#define ho(n) (n-min_halfword)

typedef struct two_halves
{
	halfword rh;
	union {
		halfword lh;
		struct {
			quarterword b0;
			quarterword b1;
		} struct_t;
	} union_t;
} two_halves;

typedef struct {
	quarterword b0;
	quarterword b1;
	quarterword b2;
	quarterword b3;
} four_quarters;

typedef struct
{
	union {
		int an_int;
		glue_ratio gr;
		two_halves hh;
		four_quarters qqqq;
	} union_t;
} memory_word;

typedef FILE* word_file;

// 115
#define pointer halfword
#define null min_halfword

pointer temp_ptr;

// 116
Array<memory_word, mem_min, mem_max> mem;
pointer lo_mem_max;
pointer hi_mem_min;

// 117
int var_used, dyn_used;

// 118
#define link(n) mem[n].union_t.hh.rh
#define info(n) mem[n].union_t.hh.union_t.lh

pointer avail;
pointer mem_end;

// 124
#define empty_flag max_halfword
#define is_empty(n) (link(n) == empty_flag)
#define node_size info
#define llink(n) (info(n+1))
#define rlink(n) (link(n+1))

pointer rover;

//133
#define type(n) mem[n].union_t.hh.union_t.struct_t.b0
#define subtype(n) mem[n].union_t.hh.union_t.struct_t.b1

// 134
#define is_char_node(n) (n >= hi_mem_min)
#define font type
#define character subtype

// 135
enum node_type : unsigned char
{
	hlist_node = 0,
	vlist_node = 1,
	rule_node = 2,
	ins_node = 3,
	mark_node = 4,
	adjust_node = 5,
	ligature_node = 6,
	disc_node = 7,
	whatsit_node = 8,
	math_node = 9,
	glue_node = 10,
	kern_node = 11,
	penalty_node = 12,
	unset_node = 13,
	style_node = unset_node + 1,
	choice_node = unset_node + 2,
	ord_noad = unset_node + 3,
	op_noad = ord_noad + 1,
	bin_noad = ord_noad + 2,
	rel_noad = ord_noad + 3,
	open_noad = ord_noad + 4,
	close_noad = ord_noad + 5,
	punct_noad = ord_noad + 6,
	inner_noad = ord_noad + 7,
	radical_noad = inner_noad + 1,
	fraction_noad = radical_noad + 1,
	under_noad = fraction_noad + 1,
	over_noad = under_noad + 1,
	accent_noad = over_noad + 1,
	vcenter_noad = accent_noad + 1,
	left_noad = vcenter_noad + 1,
	right_noad = left_noad + 1,

};

enum whatsit_type : unsigned char
{
	open_node = 0,
	write_node = 1,
	close_node = 2,
	special_node = 3,
	language_node = 4,

};

// 135
//const int hlist_node = 0;
const int box_node_size = 7;
const int width_offset = 1;
const int depth_offset = 2;
const int height_offset = 3;
#define width(n) (mem[n+width_offset].sc)
#define depth(n) (mem[n+depth_offset].sc)
#define height(n) (mem[n+height_offset].sc)
#define shift_amount(n) (mem[n+4].sc)
const int list_offset = 5;
#define list_ptr(n) link(n+list_offset)
#define glue_order(n) subtype(n+list_offset)
#define glue_sign(n) type(n+list_offset)
const int normal = 0;
const int stretching = 1;
const int shrinking = 2;
const int glue_offset = 6;
#define glue_set(n) mem[n+glue_offset].union_t.gr

// 137

// 138
const int rule_node_size = 4;
const int null_flag = -010000000000;
#define is_running(s) (s == null_flag)

// 140
const int ins_node_size = 5;
#define float_cost(s) mem[s+1].union_t.an_int
#define ins_ptr(s) info(s+4)
#define split_top_ptr(s) link(s+4)

// 141
const int small_node_size = 2;
#define mark_ptr(s) mem[s+1].union_t.an_int

// 142
#define adjust_ptr mark_ptr

// 143
#define lig_char(s) (s+1)
#define lig_ptr(s) link(lig_char(s))

// 145
#define replace_count subtype
#define pre_break llink
#define post_break rlink

// 146

// 147
const int before = 0;
const int after = 1;

// 148
#define precedes_break(n) (type(n) < math_node)
#define non_discardable(n) (type(n) < math_node)

// glue 149
const int cond_math_glue = 98;
const int mu_glue = 99;
const int a_leaders = 100;
const int c_leaders = 101;
const int x_leaders = 102;
#define glue_ptr llink
#define leader_ptr rlink

// glue 150
const int glue_spec_size = 4;
#define glue_ref_count(n) link(n)
#define stretch(n) (mem[n+2].sc)
#define shrink(n) (mem[n+3].sc)
#define stretch_order type
#define shrink_order subtype
const int fil = 1;
const int fill = 2;
const int filll = 3;

typedef int glue_ord; // normal .. filll

// 155
const int _explicit = 1;
const int acc_kern = 2;

// 157
const int inf_penalty = inf_bad;
const int eject_penalty = -inf_penalty;
#define penalty(s) mem[s+1].union_t.an_int

// 159
#define glue_stretch(s) mem[s+glue_offset].sc
#define glue_shrink shift_amount
#define span_count subtype

// 162
const int zero_glue = mem_bot;
const int fil_glue = zero_glue + glue_spec_size;
const int fill_glue = fil_glue + glue_spec_size;
const int ss_glue = fill_glue + glue_spec_size;
const int fil_neg_glue = ss_glue + glue_spec_size;
const int lo_mem_stat_max = fil_neg_glue + glue_spec_size - 1;

const int page_ins_head = mem_top;
const int contrib_head = mem_top - 1;
const int page_head = mem_top - 2;
const int temp_head = mem_top - 3;
const int hold_head = mem_top - 4;
const int adjust_head = mem_top - 5;
const int active = mem_top - 7;
const int align_head = mem_top - 8;
const int end_span = mem_top - 9;
const int omit_template = mem_top - 10;
const int null_list = mem_top - 11;
const int lig_trick = mem_top - 12;
const int garbage = mem_top - 12;
const int backup_head = mem_top - 13;
const int hi_mem_stat_min = mem_top - 13;
const int hi_mem_stat_usage = 14;

// 165
//debug
bool _free[mem_max  + 1];
bool was_free[mem_max  + 1];
pointer was_mem_end, was_lo_max, was_hi_min;
bool panicking;
//gubed

// 173
int font_in_short_display;

// 180
#define node_list_display(s) do{\
  append_char(TEX_STRING("."));\
  show_node_list(s);\
  flush_char;\
}while(0)

// 181
int depth_threshold;
int breadth_max;

// 200
#define token_ref_count(n) info(n)

// 201
#define fast_delete_glue_ref(s) do{\
  if(glue_ref_count(s) == null)\
    free_node(s,glue_spec_size);\
  else decr(glue_ref_count(s));\
}while(0)
// 203
#define add_token_ref(n) incr(token_ref_count(n))
#define add_glue_ref(n) incr(glue_ref_count(n))

// 207
const int relax = 0;
const int endv = 9;
const int par_end = 13;
const int match = 13;
const int end_match = 14;
const int stop = 14;
const int delim_num = 15;
const int max_char_code = 15;

// 208
const int min_internal = 68;
const int max_non_prefixed_command = 70;

// 209
const int max_internal = 89;
const int max_command = 100;

// 207
enum cmd_code : halfword
{
	// cat codes
	escape = 0,
	left_brace = 1,
	right_brace = 2,
	math_shift = 3,
	tab_mark = 4,
	car_ret = 5,
	out_param = 5,
	mac_param = 6,
	sup_mark = 7,
	sub_mark = 8,
	ignore = 9,
	spacer = 10,
	letter = 11,
	other_char = 12,
	active_char = 13,
	comment = 14,
	invalid_char = 15,

	// other
	char_num = 16,
	math_char_num = 17,
	mark = 18,
	xray = 19,
	make_box = 20,
	hmove = 21,
	vmove = 22,
	un_hbox = 23,
	un_vbox = 24,
	remove_item = 25,
	hskip = 26,
	vskip = 27,
	mskip = 28,
	kern = 29,
	mkern = 30,
	leader_ship = 31,
	halign = 32,
	valign = 33,
	no_align = 34,
	vrule = 35,
	hrule = 36,
	insert = 37,
	vadjust = 38,
	ignore_spaces = 39,
	after_assignment = 40,
	after_group = 41,
	break_penalty = 42,
	start_par = 43,
	ital_corr = 44,
	accent = 45,
	math_accent = 46,
	discretionary = 47,
	eq_no = 48,
	left_right = 49,
	math_comp = 50,
	limit_switch = 51,
	above = 52,
	math_style = 53,
	math_choice = 54,
	non_script = 55,
	vcenter = 56,
	case_shift = 57,
	message = 58,
	extension = 59,
	in_stream = 60,
	begin_group = 61,
	end_group = 62,
	omit = 63,
	ex_space = 64,
	no_boundary = 65,
	radical = 66,
	end_cs_name = 67,

	char_given = 68,
	math_given = 69,
	last_item = 70,

	toks_register = 71,
	assign_toks = 72,
	assign_int = 73,
	assign_dimen = 74,
	assign_glue = 75,
	assign_mu_glue = 76,
	assign_font_dimen = 77,
	assign_font_int = 78,
	set_aux = 79,
	set_prev_graf = 80,
	set_page_dimen = 81,
	set_page_int = 82,
	set_box_dimen = 83,
	set_shape = 84,
	def_code = 85,
	def_family = 86,
	set_font = 87,
	def_font = 88,
	_register = 89,

	advance = 90,
	multiply = 91,
	divide = 92,
	prefix = 93,
	let = 94,
	shorthand_def = 95,
	read_to_cs = 96,
	def = 97,
	set_box = 98,
	hyph_data = 99,
	set_interaction = 100,

	undefined_cs = max_command + 1,
	expand_after = max_command + 2,
	no_expand = max_command + 3,
	input = max_command + 4,
	if_test = max_command + 5,
	fi_or_else = max_command + 6,
	cs_name = max_command + 7,
	convert = max_command + 8,
	the = max_command + 9,
	top_bot_mark = max_command + 10,
	call = max_command + 11,
	long_call = max_command + 12,
	outer_call = max_command + 13,
	long_outer_call = max_command + 14,
	end_template = max_command + 15,
	dont_expand = max_command + 16,
	glue_ref = max_command + 17,
	shape_ref = max_command + 18,
	box_ref = max_command + 19,
	data = max_command + 20,
};

// 210

// 211
enum mode_type : short
{
	undefined_mode = 0,
	vmode = 1,
	hmode = vmode + max_command + 1,
	mmode = hmode + max_command + 1,
	neg_vmode = -vmode,
	neg_hmode = -hmode,
	neg_mmode = -mmode
};

// 212
typedef struct
{
	mode_type mode_field; // -mmode..mmode
	pointer head_field;
	pointer tail_field;
	int pg_field;
	int ml_field;
	memory_word aux_field;
} list_state_record;

const int ignore_depth = -65536000;

// 213
#define mode cur_list.mode_field
#define head cur_list.head_field
#define tail cur_list.tail_field
#define prev_graf cur_list.pg_field
#define aux cur_list.aux_field
#define prev_depth aux.sc
#define space_factor aux.union_t.hh.union_t.lh
#define clang aux.union_t.hh.rh
#define incompleat_noad aux.union_t.an_int
#define mode_line cur_list.ml_field

Array<list_state_record, 0, nest_size> nest;
int nest_ptr;
int max_nest_stack;
list_state_record cur_list;
short shown_mode;

// 214
#define tail_append(s) do{\
  link(tail) = s;\
  tail = link(tail);\
}while(0)

// 246
int old_setting;

// 256
#define next(n) (hash[n].union_t.lh)
#define text(n) (hash[n].rh)
#define hash_is_full (hash_used == hash_base)
#define font_id_text(n) text(font_id_base+n)

Array<two_halves, hash_base, undefined_control_sequence - 1> hash;
pointer hash_used;
bool no_new_control_sequence;
int cs_count;

// 268
#define save_type(n) (save_stack[n].union_t.hh.union_t.struct_t.b0)
#define save_level(n) (save_stack[n].union_t.hh.union_t.struct_t.b1)
#define save_index(n) (save_stack[n].union_t.hh.rh)

enum save_type_type : quarterword
{
	restore_old_value = 0,
	restore_zero = 1,
	insert_token=2,
	level_boundary=3
};

// 269
enum group_code : quarterword
{
	bottom_level = 0,
	simple_group = 1,
	hbox_group = 2,
	adjusted_hbox_group = 3,
	vbox_group = 4,
	vtop_group = 5,
	align_group = 6,
	no_align_group = 7,
	output_group = 8,
	math_group = 9,
	disc_group = 10,
	insert_group = 11,
	vcenter_group = 12,
	math_choice_group = 13,
	semi_simple_group = 14,
	math_shift_group = 15,
	math_left_group = 16,
};
unsigned char max_group_code = 16;

// 271
Array<memory_word, 0, save_size> save_stack;
int save_ptr;
int max_save_stack;
quarterword cur_level;
group_code cur_group;
int cur_boundary;

// 273
#define check_full_save_stack do\
{\
  if(save_ptr > max_save_stack)\
  {\
    max_save_stack=save_ptr;\
   if(max_save_stack > save_size-6)\
     overflow(TEX_STRING("save size"),save_size);\
  }\
}\
while(0)

// 274
#define saved(s) save_stack[save_ptr+s].union_t.an_int

// 286
int mag_set;

// 289
const int cs_token_flag = 07777;
const int left_brace_token = 0400;
const int left_brace_limit = 01000;
const int right_brace_token = 01000;
const int right_brace_limit = 01400;
const int math_shift_token = 01400;
const int tab_token = 02000;
const int out_param_token = 02400;
const int space_token = 05040;
const int letter_token = 05400;
const int other_token = 06000;
const int match_token = 06400;
const int end_match_token = 07000;

// 297
eight_bits cur_cmd;
halfword cur_chr;
pointer cur_cs;
halfword cur_tok;

// 298
#define chr_cmd(s) do{print(s);print_ASCII(chr_code); }while(0)

// 303
enum input_state_var : quarterword
{
	token_list = 0,
	mid_line = 1,
	skip_blanks = 2 + max_char_code,
	new_line = 3 + max_char_code + max_char_code
};

enum enum_token_type : quarterword
{
	parameter = 0,
	u_template = 1,
	v_template = 2,
	backed_up = 3,
	inserted = 4,
	macro = 5,
	output_text = 6,
	every_par_text = 7,
	every_math_text = 8,
	every_display_text = 9,
	every_hbox_text = 10,
	every_vbox_text = 11,
	every_job_text = 12,
	every_cr_text = 13,

	mark_text = 14,
	write_text = 15,
};

// 300
typedef struct
{
	input_state_var state_field;
	enum_token_type index_field;
	halfword start_field;
	halfword loc_field;
	halfword limit_field;
	halfword name_field;
} in_state_record;

// 301
Array<in_state_record, 0, stack_size> input_stack;
int input_ptr;
int max_in_stack;
in_state_record cur_input;

// 302
#define state cur_input.state_field
#define index cur_input.index_field
#define start cur_input.start_field
#define limit cur_input.limit_field
#define name cur_input.name_field

// 304
#define terminal_input (name==0)
#define cur_file input_file[index]

int in_open;
int open_parens;
Array<alpha_file, 1, max_in_open> input_file;
int line;
Array<int, 1, max_in_open> line_stack;
// 305
const int skipping = 1;
const int defining = 2;
const int matching = 3;
const int aligning = 4;
const int absorbing = 5;

char scanner_status;
pointer warning_index;
pointer def_ref;

// 307
#define token_type index
#define param_start limit

// 308
Array<pointer, 0, param_size> param_stack;
int param_ptr;
int max_param_stack;

// 309
int align_state;

// 310
int base_ptr;

// 316
#define begin_pseudoprint do {l = tally;tally=0;selector=pseudo;trick_count=1000000;}while(0)
#define set_trick_count do {first_count = tally;trick_count=tally+1+error_line-half_error_line;if(trick_count<error_line)trick_count=error_line;}while(0)

// 321
#define push_input do{\
  if(input_ptr > max_in_stack){\
    max_in_stack=input_ptr;\
    if(input_ptr==stack_size)\
      overflow(TEX_STRING("input stack size"),stack_size);\
  }\
  input_stack[input_ptr]=cur_input;\
  incr(input_ptr);\
}while(0)

// 322
#define pop_input do{\
  decr(input_ptr);\
  cur_input=input_stack[input_ptr];\
}while(0)

// 323
#define back_list(s) begin_token_list(s,backed_up)
#define ins_list(s) begin_token_list(s,inserted)

// 333
pointer par_loc;
halfword par_token;

// 344
#define any_state_plus(s) \
mid_line+s:\
case skip_blanks+s:\
case new_line+s

// 347
#define add_delims_to(s) \
s+math_shift:\
case s+tab_mark:\
case s+mac_param:\
case s+sub_mark:\
case s+letter:\
case s+other_char

// 352
#define is_hex(s) ((s >= TEX_STRING("0") && s <= TEX_STRING("9")) || (s >= TEX_STRING("a") && s <= TEX_STRING("f")))

#define hex_to_cur_chr do{\
  if(c <= TEX_STRING("9")) \
    cur_chr = c-TEX_STRING("0");\
  else \
    cur_chr=c-TEX_STRING("a")+10;\
  if(cc <= TEX_STRING("9")) cur_chr = 16*cur_chr+cc-TEX_STRING("0");\
  else cur_chr = 16*cur_chr+cc-TEX_STRING("a")+10;\
}while(0)

// 358
const int no_expand_flag = 257;

// 360
#define end_line_char_inactive (end_line_char < 0 || end_line_char > 255)

// 361
bool force_eof;

// 122
// make this function instead, bah, we don't need to use this one just replace with get_avail
// #define fast_get_avail(s) ...

// 371
#define store_new_token(s) do{\
  q = get_avail();\
  link(p) = q;\
  info(q)=s;\
  p=q;\
}while(0)

// we don't need to be so fast
//#define fast_store_new_token(s) do{fast_get_avail(q);link(p)=q;info(q) = s;p=q;}while(0)

// 382
const int top_mark_code = 0;
const int first_mark_code = 1;
const int bot_mark_code = 2;
const int split_first_mark_code = 3;
const int split_bot_mark_code = 4;
#define top_mark cur_mark[top_mark_code]
#define first_mark cur_mark[first_mark_code]
#define bot_mark cur_mark[bot_mark_code]
#define split_first_mark cur_mark[split_first_mark_code]
#define split_bot_mark cur_mark[split_bot_mark_code]

Array<pointer, top_mark_code, split_bot_mark_code> cur_mark;

// 387
int long_state;

// 388
Array<pointer, 0, 8> pstack;

// 410
const int int_val = 0;
const int dimen_val = 1;
const int glue_val = 2;
const int mu_val = 3;
const int ident_val = 4;
const int tok_val = 5;

int cur_val;
int cur_val_level;

// 413
#define scanned_result(s,t) do{cur_val=s;cur_val_level=t;}while(0)

// 416
const int input_line_no_code = glue_val + 1;
const int badness_code = glue_val + 2;

// 421
const int max_dimen = 07777777777;

// 438
const int octal_token = other_token + TEX_STRING("'");
const int hex_token = other_token + TEX_STRING("""");
const int alpha_token = other_token + TEX_STRING("`");
const int point_token = other_token + TEX_STRING(".");
const int continental_point_token = other_token + TEX_STRING(",");

small_number radix;

// 445
const int _infinity = 017777777777;
const int zero_token = other_token + TEX_STRING("0");
const int A_token = letter_token + TEX_STRING("A");
const int other_A_token = other_token + TEX_STRING("A");

// 447
glue_ord cur_order;

// 448
const int attach_fraction = 88;
const int attach_sign = 89;
#define scan_normal_dimen scan_dimen(false,false,false)

//458
#define set_conversion(s, t) do{num = s; denom=t;}while(0)

// 463
const int default_rule = 26214;

// 468
const int number_code = 0;
const int roman_numeral_code = 1;
const int string_code = 2;
const int meaning_code = 3;
const int font_name_code = 4;
const int job_name_code = 5;


// 480
const int closed = 2;
const int just_open = 1;

Array<alpha_file, 0, 15> read_file;
Array<int, 0, 16> read_open;

// 487
const int if_char_code = 0;
const int if_cat_code = 1;
const int if_int_code = 2;
const int if_dim_code = 3;
const int if_odd_code = 4;
const int if_vmode_code = 5;
const int if_hmode_code = 6;
const int if_mmode_code = 7;
const int if_inner_code = 8;
const int if_void_code = 9;
const int if_hbox_code = 10;
const int if_vbox_code = 11;
const int ifx_code = 12;
const int if_eof_code = 13;
const int if_true_code = 14;
const int if_false_code = 15;
const int if_case_code = 16;

// 489
const int if_node_size = 2;
#define if_line_field(s) mem[s+1].union_t.an_int
const int if_code = 1;
const int fi_code = 2;
const int else_code = 3;
const int or_code = 4;

pointer cond_ptr;
int if_limit;
small_number cur_if;
int if_line;

// 493
int skip_line;

// 506
#define get_x_token_or_active_char do{\
get_x_token();\
if(cur_cmd == relax)\
    if(cur_chr == no_expand_flag){\
      cur_cmd = active_char; cur_chr = cur_tok-cs_token_flag-active_base;\
    }\
}while(0)

// 512
str_number cur_name;
str_number cur_area;
str_number cur_ext;

// 513
pool_pointer area_delimiter;
pool_pointer ext_delimiter;

//514

#define TEX_area TEX_STRING("")
#define TEX_font_area TEX_STRING("")

// 527
bool name_in_progress;
str_number job_name;
bool log_opened;

// 519
#define append_to_name(s) do{\
  c = s;\
  incr(k);\
  if(k<=file_name_size)\
    name_of_file[k]=xchr[c];\
}while(0)

// 529
#define pack_cur_name pack_file_name(cur_name, cur_area, cur_ext)

// 532
#define ensure_dvi_open do{\
  if(output_file_name == 0) {\
    if(job_name == 0) open_log_file();\
    pack_job_name(TEX_STRING(".dvi"));\
    while(!b_open_out(&dvi_file)) prompt_file_name(TEX_STRING("file name for output"), TEX_STRING(".dvi"));\
    output_file_name = b_make_name_string(dvi_file);\
  }\
}while(0)

byte_file dvi_file;
str_number output_file_name;
str_number log_name;

// 539
byte_file tfm_file;

// 544
const int no_tag = 0;
const int lig_tag = 1;
const int list_tag = 2;
const int ext_tag = 3;

// 545
#define stop_flag qi(128)
#define kern_flag qi(128)
#define skip_byte(s) s.b0
#define next_char(s) s.b1
#define op_byte(s) s.b2
#define rem_byte(s) s.b3

// 546
#define ext_top(s) s.b0
#define ext_mid(s) s.b1
#define ext_bot(s) s.b2
#define ext_rep(s) s.b3

// 547
const int slant_code = 1;
const int space_code = 2;
const int space_stretch_code = 3;
const int space_shrink_code = 4;
const int x_height_code = 5;
const int quad_code = 6;
const int extra_space_code = 7;

// 548
typedef int internal_font_number; // font_base .. font_max
typedef int font_index; // 0 .. font_mem_size

// 549
#define non_char qi(256)
const int non_address = 0;

Array<memory_word, 0, font_mem_size> font_info;
font_index fmem_ptr;
internal_font_number font_ptr;

Array<four_quarters, font_base, font_max> font_check;
Array<scaled, font_base, font_max> font_size;
Array<scaled, font_base, font_max> font_dsize;
Array<font_index, font_base, font_max> font_params;
Array<str_number, font_base, font_max> font_name;
Array<str_number, font_base, font_max> font_area;
Array<eight_bits, font_base, font_max> font_bc;
Array<eight_bits, font_base, font_max> font_ec;
Array<pointer, font_base, font_max> font_glue;
Array<bool, font_base, font_max> font_used;
Array<int, font_base, font_max> hyphen_char;
Array<int, font_base, font_max> skew_char;
Array<font_index, font_base, font_max> bchar_label;
Array<int, font_base, font_max> font_bchar;
Array<int, font_base, font_max> font_false_bchar;

// 550
Array<int, font_base, font_max> char_base;
Array<int, font_base, font_max> width_base;
Array<int, font_base, font_max> height_base;
Array<int, font_base, font_max> depth_base;
Array<int, font_base, font_max> italic_base;
Array<int, font_base, font_max> lig_kern_base;
Array<int, font_base, font_max> kern_base;
Array<int, font_base, font_max> exten_base;
Array<int, font_base, font_max> param_base;

// 554
#define char_info(s,t) font_info[char_base[s] + t].union_t.qqqq
#define char_width(s,t) font_info[width_base[s]+t.b0].sc
#define char_exists(s) (s.b0 > min_quarterword)
#define char_italic(s,t) font_info[italic_base[s]+(qo(t.b2))/4].sc
#define height_depth(s) qo(s.b1)
#define char_height(s,t) font_info[height_base[s]+(t)/16].sc
#define char_depth(s,t) font_info[depth_base[s]+(t) % 16].sc
#define char_tag(s) ((qo(s.b2)) % 4)

// 555
four_quarters null_character;

// 557
#define char_kern(s,t) font_info[kern_base[s] + 256*op_byte(t)+rem_byte(t)].sc
#define kern_base_offset 256*(128+min_quarterword)
#define lig_kern_start(s,t) lig_kern_base[s]+rem_byte(t)
#define lig_kern_restart(s,t) lig_kern_base[s]+256*op_byte(t)+rem_byte(t)+32768-kern_base_offset

// 558
#define slant(s) font_info[slant_code+param_base[s]].sc
#define space(s) font_info[space_code+param_base[s]].sc
#define space_stretch(s) font_info[space_stretch_code+param_base[s]].sc
#define space_shrink(s) font_info[space_shrink_code+param_base[s]].sc
#define x_height(s) font_info[x_height_code+param_base[s]].sc
#define quad(s) font_info[quad_code+param_base[s]].sc
#define extra_space(s) font_info[extra_space_code+param_base[s]].sc

// 587
const int id_byte = 2;

// 560
const int bad_tfm = 11;
#define _abort goto bad_tfm

// 561
#define start_font_error_message do{\
	print_err(TEX_STRING("Font "));\
	sprint_cs(u);\
	print_char(TEX_STRING("="));\
	print_file_name(nom,aire,TEX_STRING(""));\
	if(s>=0) {\
		print(TEX_STRING(" at "));\
		print_scaled(s);\
		print(TEX_STRING("pt"));\
	}\
	else if(s!=-1000) {\
		print(TEX_STRING(" scaled "));\
		print_int(-s);\
	}\
}while(0)

// 564
#define read_sixteen(s) do{\
	unsigned char s1;\
	unsigned char s2;\
	s1 = fgetc(tfm_file);\
	s2 = fgetc(tfm_file);\
	if(s1>127) _abort;\
	s = s1 * 0400 + s2;\
} while(0)

#define store_four_quarters(s) do{\
	a = fgetc(tfm_file);\
	b = fgetc(tfm_file);\
	c = fgetc(tfm_file);\
	d = fgetc(tfm_file);\
	qw.b0 = qi(a);\
	qw.b1 = qi(b);\
	qw.b2 = qi(c);\
	qw.b3 = qi(d);\
	s=qw;\
}while(0)

// 570
#define check_byte_range(s) do{if(s<bc || s > ec)_abort;}while(0)
#define current_character_being_worked_on k+bc-fmem_ptr

// 571
#define store_scaled(s) do{\
	a=fgetc(tfm_file);\
	b=fgetc(tfm_file);\
	c=fgetc(tfm_file);\
	d=fgetc(tfm_file);\
	sw = (((((d*z)/0400)+(c*z)) / 0400)+(b*z)) / beta;\
	if(a==0) s=sw;\
	else if(a==255) s = sw - alpha;\
	else _abort;\
}while(0)

// 573
#define check_existence(s) do{\
	check_byte_range(s);\
	qw = char_info(f,s);\
	if(!char_exists(qw)) _abort;\
}while(0)

// 576
#define adjust(s) s[f] = qo(s[f])

// 253
Array<memory_word, active_base, eqtb_size> eqtb;

Array<quarterword, int_base, eqtb_size> xeq_level;
// 520
const int format_default_length = 9;
const int format_area_length = 11;
const int format_ext_length = 4;
#define format_extension TEX_STRING(".fmt")
Array<char, 1, format_default_length+1> TEX_format_default;
// 586
namespace dvi_const {
	const int set_char_0 = 0;
	const int set1 = 128;
	const int set_rule = 132;
	const int put_rule = 137;
	const int nop = 138;
	const int bop = 139;
	const int eop = 140;
	const int push = 141;
	const int pop = 142;
	const int right1 = 143;
	const int w0 = 147;
	const int w1 = 148;
	const int x0 = 152;
	const int x1 = 153;
	const int down1 = 157;
	const int y0 = 161;
	const int y1 = 162;
	const int z0 = 166;
	const int z1 = 167;
	const int fnt_num_0 = 171;
	const int fnt1 = 235;
	const int xxx1 = 239;
	const int xxx4 = 242;
	const int fnt_def1 = 243;
	const int pre = 247;
	const int post = 248;
	const int post_post = 249;
}

// 592
int total_pages;
scaled max_v;
scaled max_h;
int max_push;
int last_bop;
int dead_cycles;
bool doing_leaders;

quarterword c, f;
scaled rule_ht, rule_dp, rule_wd;
pointer g;
int lq, lr;

//594
typedef int dvi_index;

// 595
Array<eight_bits, 0, dvi_buf_size> dvi_buf;
dvi_index half_buf;
dvi_index dvi_limit;
dvi_index dvi_ptr;
int dvi_offset;
int dvi_gone;

// 598
#define dvi_out(s) do {\
  dvi_buf[dvi_ptr] = s;\
  incr(dvi_ptr);\
  if (dvi_ptr==dvi_limit)\
    dvi_swap();\
}while(0)
// 605
const int movement_node_size = 3;
#define location(s) mem[s+2].union_t.an_int

pointer down_ptr, right_ptr;

// 608
const int y_here = 1;
const int z_here = 2;
const int yz_OK = 3;
const int y_OK = 4;
const int z_OK = 5;
const int d_fixed = 6;

// 611
const int none_seen = 0;
const int y_seen = 6;
const int z_seen = 12;

// 616
#define synch_h do{\
if(cur_h != dvi_h) {\
movement(cur_h-dvi_h, dvi_const::right1);\
dvi_h=cur_h;\
}\
}while(0)

#define synch_v do{\
	if(cur_v != dvi_v) {\
		movement(cur_v-dvi_v, dvi_const::down1);\
		dvi_v=cur_v;\
	}\
}while(0)

scaled dvi_h, dvi_v;
scaled cur_h, cur_v;
internal_font_number dvi_f;
int cur_s;

// 625
#define billion 1000000000.0f
#define vet_glue(s) do{glue_temp = s; if(glue_temp>billion) glue_temp=billion;else if(glue_temp < -billion) glue_temp=-billion;}while(0)

// 644
const int exactly = 0;
const int additional = 1;

//#define natural 0,additional // Don't know how to define this in C++, is it possible?

// 646
Array<scaled, normal, filll> total_stretch;

Array<scaled, normal, filll> total_shrink;
int last_badness;

// 647
pointer adjust_tail;

// 661
int pack_begin_line;

// 668
#define vpack(s,t,u) vpackage(s,t,u,max_dimen)

// 681
const int noad_size = 4;
#define nucleus(s) (s+1)
#define supscr(s) (s+2)
#define subscr(s) (s+3)
#define math_type link
#define fam font
const int math_char = 1;
const int sub_box = 2;
const int sub_mlist = 3;
const int math_text_char = 4;

// 682
const int limits = 1;
const int no_limits = 2;

// 683
#define left_delimiter(s) (s+4)
#define right_delimiter(s) (s+5)

const int radical_noad_size = 5;

const int fraction_noad_size = 6;
#define small_fam(s) mem[s].union_t.qqqq.b0
#define small_char(s) mem[s].union_t.qqqq.b1
#define large_fam(s) mem[s].union_t.qqqq.b2
#define large_char(s) mem[s].union_t.qqqq.b3
#define thickness width
const int default_code = 010000000000;
#define numerator supscr
#define denominator subscr


// 684
two_halves empty_field;
four_quarters null_delimiter;

// 687
const int accent_noad_size = 5;
#define accent_chr(s) (s+4)

#define delimiter nucleus
#define scripts_allowed(s) (type(s)>= ord_noad && type(s) < left_noad)

// 688
//const int style_node = unset_node + 1;
const int style_node_size = 3;
enum math_style : small_number
{
	display_style = 0,
	text_style = 2,
	script_style = 4,
	script_script_style = 6,
};

const int cramped = 1;

// 689
//const int choice_node = unset_node + 2;
#define display_mlist(s) info(s+1)
#define text_mlist(s) link(s+1)
#define script_mlist(s) info(s+2)
#define script_script_mlist(s) link(s+2)


// 699
enum math_size :small_number {
	text_size = 0,
	script_size = 16,
	script_script_size = 32,
};

// 700
#define math_x_height(s) font_info[5+param_base[fam_fnt(2+s)]].sc
#define math_quad(s) font_info[6+param_base[fam_fnt(2+s)]].sc
#define num1(s) font_info[8+param_base[fam_fnt(2+s)]].sc
#define num2(s) font_info[9+param_base[fam_fnt(2+s)]].sc
#define num3(s) font_info[10+param_base[fam_fnt(2+s)]].sc
#define denom1(s) font_info[11+param_base[fam_fnt(2+s)]].sc
#define denom2(s) font_info[12+param_base[fam_fnt(2+s)]].sc
#define sup1(s) font_info[13+param_base[fam_fnt(2+s)]].sc
#define sup2(s) font_info[14+param_base[fam_fnt(2+s)]].sc
#define sup3(s) font_info[15+param_base[fam_fnt(2+s)]].sc
#define sub1(s) font_info[16+param_base[fam_fnt(2+s)]].sc
#define sub2(s) font_info[17+param_base[fam_fnt(2+s)]].sc
#define sup_drop(s) font_info[18+param_base[fam_fnt(2+s)]].sc
#define sub_drop(s) font_info[19+param_base[fam_fnt(2+s)]].sc
#define delim1(s) font_info[20+param_base[fam_fnt(2+s)]].sc
#define delim2(s) font_info[21+param_base[fam_fnt(2+s)]].sc
#define axis_height(s) font_info[22+param_base[fam_fnt(2+s)]].sc


const int total_mathsy_params = 22;

// 701
#define default_rule_thickness font_info[8+param_base[fam_fnt(3+cur_size)]].sc
#define big_op_spacing1 font_info[9+param_base[fam_fnt(3+cur_size)]].sc
#define big_op_spacing2 font_info[10+param_base[fam_fnt(3+cur_size)]].sc
#define big_op_spacing3 font_info[11+param_base[fam_fnt(3+cur_size)]].sc
#define big_op_spacing4 font_info[12+param_base[fam_fnt(3+cur_size)]].sc
#define big_op_spacing5 font_info[13+param_base[fam_fnt(3+cur_size)]].sc
const int total_mathex_params = 13;

//702
#define cramped_style(s) (2*(s/2)+cramped)
#define sub_style(s) (2*(s/4) + script_style+cramped)
#define sup_style(s) (2*(s/4)+script_style+(s%2))
#define num_style(s) (s+2-2*(s/6))
#define denom_style(s) (2*(s/2)+cramped + 2 - 2*(s/6))

// 716
#define mu_mult(s) nx_plus_y(n, s, xn_over_d(s, f, 0200000))

// 719
pointer cur_mlist;
small_number cur_style;
small_number cur_size;
scaled cur_mu;
bool mlist_penalties;

// 724
internal_font_number cur_f;
quarterword cur_c;
four_quarters cur_i;

// 725
#define new_hlist(s) mem[nucleus(s)].union_t.an_int

// 731
#define choose_mlist(s) do{p = s(q); s(q) = null;}while(0)

// 764
#define math_spacing TEX_STRING("0234000122*4000133**3**344*0400400*000000234000111*1111112341011")
int magic_offset;

// 769
#define u_part(s) mem[s+height_offset].union_t.an_int
#define v_part(s) mem[s+depth_offset].union_t.an_int
#define extra_info(s) info(s+list_offset)

// 770
#define preamble link(align_head)
const int align_stack_node_size = 5;

pointer cur_align;
pointer cur_span;
pointer cur_loop;
pointer align_ptr;
pointer cur_head, cur_tail;

// 780
const int span_code = 256;
const int cr_code = 257;
const int cr_cr_code = cr_code + 1;
const int end_template_token = cs_token_flag + frozen_end_template;

// 797
const int span_node_size = 2;

// 814
pointer just_box;

// 817
const int tight_fit = 3;
const int loose_fit = 1;
const int very_loose_fit = 0;
const int decent_fit = 2;

// 819
const int active_node_size = 3;
#define fitness subtype
#define break_node rlink
#define line_number llink
#define total_demerits(s) mem[s+2].union_t.an_int
const int unhyphenated = 0;
const int hyphenated = 1;
#define last_active active

// 821
const int passive_node_size = 2;
#define cur_break rlink
#define prev_break llink
#define serial info

pointer passive;
pointer printed_node;
halfword pass_number;

//822
const int delta_node_size = 7;
const int delta_node = 2;

// 823
#define do_all_six(s) do{s(1); s(2); s(3); s(4); s(5); s(6);}while(0)

Array<scaled, 1, 6> active_width;
Array<scaled, 1, 6> cur_active_width;
Array<scaled, 1, 6> background;
Array<scaled, 1, 6> break_width;

// 825
#define check_shrinkage(s) do{\
  if (shrink_order(s) != normal && shrink(s) != 0)\
    s = finite_shrink(s);\
}while(0)

bool no_shrink_error_yet;

// 828
pointer cur_p;
bool second_pass;
bool final_pass;
int threshold;

//829
#define copy_to_cur_active(s) cur_active_width[s] = active_width[s]
const int deactivate = 60;

//832
#define update_width(s) cur_active_width[s] += mem[r+s].sc

// 833
const int awful_bad = 07777777777;

Array<int, very_loose_fit, tight_fit> minimal_demerits;
int minimum_demerits;

Array<pointer, very_loose_fit, tight_fit> best_place;
Array<halfword, very_loose_fit, tight_fit> best_pl_line;

//837
#define set_break_width_to_background(s) break_width[s] = background[s]

// 839
scaled disc_width;

// 843
#define convert_to_break_width(s) do{\
  mem[prev_r+s].sc = mem[prev_r+s].sc-cur_active_width[s] + break_width[s];\
}while(0)

#define store_break_width(s) do{\
	active_width[s] = break_width[s];\
}while(0)

#define new_delta_to_break_width(s) do{\
  mem[q+s].sc = break_width[s] - cur_active_width[s];\
}while(0)

// 844
#define new_delta_from_break_width(s) do{\
  mem[q+s].sc = cur_active_width[s] - break_width[s];\
}while(0)

// 847
halfword easy_line;
halfword last_special_line;
scaled first_width;
scaled second_width;
scaled first_indent;
scaled second_indent;

// 860
#define combine_two_deltas(s) mem[prev_r+s].sc += mem[r+s].sc
#define downdate_width(s) cur_active_width[s] -= mem[prev_r+s].sc

// 861
#define update_active(s) active_width[s] += mem[r+s].sc

//864
#define store_background(s) active_width[s] = background[s]

//866
#define act_width active_width[1]
#define kern_break do{\
  if(!is_char_node(link(cur_p))&&auto_breaking)\
    if(type(link(cur_p))==glue_node)\
      try_break(0,unhyphenated);\
  act_width += width(cur_p);\
}while(0)

// 872
pointer best_bet;
int fewest_demerits;
halfword best_line;
int actual_looseness;
int line_diff;

//877
#define next_break prev_break

// 892
Array<int, 0, 65> hc;
small_number hn;
pointer ha, hb;
internal_font_number hf;
Array<int, 0, 63> hu;

int hyf_char;
ASCII_code cur_lang, init_cur_lang;
int l_hyf, r_hyf, init_l_hyf, init_r_hyf;
halfword hyf_bchar;

// 900
Array<char, 0, 64> hyf;
pointer init_list;
bool init_lig;
bool init_lft;

// 905
small_number hyphen_passed;

// 907
halfword cur_l, cur_r;
pointer cur_q;
pointer lig_stack;
bool ligature_present;
bool lft_hit, rt_hit;

// 908
#define append_charnode_to_t(s) do{\
  link(t) = get_avail();t = link(t); font(t) = hf; character(t) = s;\
}while(0)

#define set_cur_r do{\
  if(j<n) cur_r = qi(hu[j+1]); else cur_r = bchar;\
  if(myodd(hyf[j])) cur_rh = hchar; else cur_rh = non_char;\
}while(0)

//910
#define wrap_lig(s) do{\
  if(ligature_present) {\
    p = new_ligature((quarterword)hf,(quarterword)cur_l,link(cur_q));\
    if(lft_hit) {\
	  subtype(p) = 2; lft_hit = false;\
	}\
	if (s)\
	  if (lig_stack == null) {\
	    incr(subtype(p)); rt_hit = false;\
	  }\
	link(cur_q) = p; t = p; ligature_present = false;\
  }\
}while (0)

#define pop_lig_stack do{\
  if(lig_ptr(lig_stack) > null) {\
    link(t) = lig_ptr(lig_stack);\
	t = link(t); incr(j);\
  }\
  p = lig_stack; lig_stack = link(p); free_node(p, small_node_size);\
  if (lig_stack == null) set_cur_r; else cur_r = character(lig_stack);\
}while(0)

//914
#define advance_major_tail do{major_tail = link(major_tail);incr(r_count);}while(0)

// 920
typedef int trie_pointer; // 0..trie_size

// 921
#define trie_link(s) trie[s].rh
#define trie_char(s) trie[s].union_t.struct_t.b1
#define trie_op(s) trie[s].union_t.struct_t.b0

Array<two_halves, 0, trie_size> trie;
Array<small_number, 1, trie_op_size> hyf_distance;
Array<small_number, 1, trie_op_size> hyf_num;
Array<quarterword, 1, trie_op_size> hyf_next;
Array<int, 0, 255> op_start;

// 925
typedef int hyph_pointer; // 0..hyph_size

// 926
Array<str_number, 0, hyph_size> hyph_word;

Array<pointer, 0, hyph_size> hyph_list;
hyph_pointer hyph_count;


// 934
#define set_cur_lang do{\
  if (language <= 0) cur_lang = 0;\
  else if(language > 255) cur_lang=0;\
  else cur_lang=language;\
}while(0)

// 943
//init

Array<unsigned, -trie_op_size, trie_op_size> trie_op_hash;
Array<quarterword, 0, 255> trie_used;
Array<ASCII_code, 1, trie_op_size> trie_op_lang;
Array<quarterword, 1, trie_op_size> trie_op_val;

int trie_op_ptr;

// 947
#define trie_root trie_l[0]

//init
Array<packed_ASCII_code, 0, trie_size> trie_c;
Array<packed_ASCII_code, 0, trie_size> trie_o;
Array<trie_pointer, 0, trie_size> trie_l;
Array<trie_pointer, 0, trie_size> trie_r;

trie_pointer trie_ptr;
Array<trie_pointer, 0, trie_size> trie_hash;
//tini

// 950
#define trie_ref trie_hash
#define trie_back(s) trie[s].union_t.lh

// init
Array<bool, 1, trie_size>  trie_taken;
Array<trie_pointer, 0, 255> trie_min;
trie_pointer trie_max;
bool trie_not_ready;
// tini

// 970
#define active_height active_width
#define cur_height active_height[1]
#define set_height_zero(s) active_height[s] = 0

// 971
scaled best_height_plus_depth;

// 
const int deplorable = 100000;

// 980
const int inserts_only = 1;
const int box_there = 2;

pointer page_tail;
char page_contents;
scaled page_max_depth;
pointer best_page_break;
int least_page_cost;
scaled best_size;

// 981
const int page_ins_node_size = 4;
const int inserting = 0;
const int split_up = 1;
#define broken_ptr(s) link(s+1)
#define broken_ins(s) info(s+1)
#define last_ins_ptr(s) link(s+2)
#define best_ins_ptr(s) info(s+2)

// 982
#define page_goal page_so_far[0]
#define page_total page_so_far[1]
#define page_shrink page_so_far[6]
#define page_depth page_so_far[7]

Array<scaled, 0, 7> page_so_far;
pointer last_glue;
int last_penalty;
scaled last_kern;
int insert_penalties;

// 985
#define print_plus(s,t) do {if(page_so_far[s] != 0) {print(TEX_STRING(" plus "));print_scaled(page_so_far[s]);print(t);}}while(0)

// 987
#define set_page_so_far_zero(s) page_so_far[s] = 0

// 989
bool output_active;

// 995
#define contrib_tail nest[0].tail_field

// 1032
internal_font_number main_f;
four_quarters main_i;
four_quarters main_j;
font_index main_k;
pointer main_p;
int main_s;
halfword bchar;
halfword false_bchar;
bool cancel_boundary;
bool ins_disc;

// 1034
#define adjust_space_factor do{\
  main_s = sf_code(cur_chr);\
  if(main_s==1000)\
    space_factor=1000;\
  else if(main_s < 1000) {\
    if(main_s > 0)\
      space_factor = main_s;\
  }\
  else if(space_factor < 1000)\
    space_factor=1000;\
  else space_factor=main_s;\
}while(0)


// 1035
#define pack_lig(s) \
do{\
	main_p = new_ligature((quarterword)main_f, (quarterword)cur_l, link(cur_q));\
	if(lft_hit) {\
		subtype(main_p) = 2;\
		lft_hit = false;\
	}\
	if (s) \
		if(lig_stack==null) {\
			incr(subtype(main_p));\
			rt_hit=false;\
		}\
	link(cur_q) = main_p; \
	tail = main_p; \
	ligature_present = false; \
}while (0)

#define wrapup(s) do{\
if(cur_l < non_char) {\
  if(link(cur_q)>null)\
    if(character(tail)==qi(hyphen_char[main_f]))\
      ins_disc=true;\
  if(ligature_present)\
    pack_lig(s);\
  if(ins_disc){\
    ins_disc = false;\
    if(mode>0)tail_append(new_disc());\
  }\
}\
} while(0)

// 1045
#define any_mode(s) vmode+s:case hmode+s:case mmode+s
#define non_math(s) vmode+s:case hmode+s

// 1058
const int fil_code = 0;
const int fill_code = 1;
const int ss_code = 2;
const int fil_neg_code = 3;
const int skip_code = 4;
const int mskip_code = 5;

// 1071
enum enum_context_code : int
{
	box_flag = 010000000000,
	ship_out_flag = box_flag + 512,
	leader_flag = box_flag + 513,
};

enum enum_chr_code : int
{
	box_code = 0,
	copy_code = 1,
	last_box_code = 2,
	vsplit_code = 3,
	vtop_code = 4,
};

// 1074
pointer cur_box;

// 1151
#define fam_in_range ((cur_fam >= 0)&& (cur_fam < 16))


// 1178
const int above_code = 0;
const int over_code = 1;
const int atop_code = 2;
const int delimited_code = 3;

// 1214
#define global (a>=4)
#define define(s,t,u) if(global)geq_define(s,t,u);else eq_define(s,t,u)
#define word_define(s,t) if(global)geq_word_define(s,t);else eq_word_define(s,t)

// 1222
enum enum_def_code : halfword
{
	char_def_code = 0,
	math_char_def_code = 1,
	count_def_code = 2,
	 dimen_def_code = 3,
	skip_def_code = 4,
	mu_skip_def_code = 5,
	toks_def_code = 6,
};

// 1266
halfword after_token;

// 1281
bool long_help_seen;

// 1291
const int show_code = 0;
const int show_box_code = 1;
const int show_the_code = 2;
const int show_lists = 3;

// 1299
str_number format_ident;

// 1303
const int bad_fmt = 6666;
#define too_small(s) do{\
wake_up_terminal();\
wterm_s("---! Must increase the ");\
wterm_ln_s(s);\
goto bad_fmt;\
}while(0)

// 1306
#define undump(a,b,c) do{\
	undump_int(&x);\
	if(x<a||x>b) goto bad_fmt;\
	else c = x;\
}while(0)

#define undump_size(a,b,c,d) do{\
	undump_int(&x);\
	if(x<a) goto bad_fmt;\
	if(x>b) too_small(c);\
	else d = x;\
}while(0)

// 1309
#define dump_four_ASCII do {\
	w.b0 = qi(so(str_pool[k]));\
	w.b1 = qi(so(str_pool[k+1]));\
	w.b2 = qi(so(str_pool[k+2]));\
	w.b3 = qi(so(str_pool[k+3]));\
	dump_qqqq(w);\
}while(0)

word_file fmt_file;

// 1310
#define undump_four_ASCII do{\
undump_qqqq(&w);\
	str_pool[k] = si(qo(w.b0));\
	str_pool[k+1] = si(qo(w.b1));\
	str_pool[k+2] = si(qo(w.b2));\
	str_pool[k+3] = si(qo(w.b3));\
}while(0)

// 1331
int ready_already;

// 1338
const int breakpoint = 888;

// 1341
const int write_node_size = 2;
const int open_node_size = 3;

#define what_lang(s) link(s+1)
#define what_lhm(s) type(s+1)
#define what_rhm(s) subtype(s+1)
#define write_tokens(s) link(s+1)
#define write_stream(s) info(s+1)
#define open_name(s) link(s+1)
#define open_area(s) info(s+2)
#define open_ext(s) link(s+2)


// 1342
Array<alpha_file, 0, 15> write_file;
Array<bool, 0, 17> write_open;
// 1344
const int immediate_code = 4;
const int set_language_code = 5;

// 1345
pointer write_loc;

//1362
#define adv_past(s) do{\
  if(subtype(s) == language_node) {\
    cur_lang = (ASCII_code)what_lang(s);\
    l_hyf = what_lhm(s);\
    r_hyf = what_rhm(s);\
  }\
}while(0)

// 1371
#define end_write_token cs_token_flag + end_write

// function headers
bool a_open_in(FILE **f);
bool a_open_out(FILE **f);
bool b_open_in(FILE **f);
bool b_open_out(FILE **f);
bool w_open_in(FILE **f);
bool w_open_out(FILE **f);
void a_close(FILE *f);
void b_close(FILE *f);
void w_close(FILE *f);
bool input_ln(FILE *fp, bool bypass_eoln);
void print(int s);
void print_char(ASCII_code s);
void print_the_digs(eight_bits k);
void print_int(int n);
void print_ln();
void print_nl(str_number s);
void slow_print(int s);
void print_esc(str_number s);
void overflow(str_number s, int n);
str_number make_string();
bool str_eq_buf(str_number s, int k);
bool str_eq_str(str_number s, str_number t);
bool get_strings_started();

void jump_out();
void open_log_file();
void debug_help();
void error();

str_number make_name_string();
str_number w_make_name_string(word_file f);
str_number b_make_name_string(byte_file f);
str_number a_make_name_string(alpha_file f);
void print_two(int n);
void close_files_and_terminate();
void do_end_of_TEX();
void fatal_error(str_number s);
void final_cleanup();
void init_prim();
void fix_date_and_time();
void primitive(str_number s, quarterword c, halfword o);
void end_token_list();
void give_err_help();
void pack_file_name(str_number n, str_number a, str_number e);
void pause_for_instructions();
void get_token();
void get_next();
void main_control();
void begin_token_list(pointer p, quarterword t);
void begin_diagnostic();
void end_diagnostic(bool blank_line);
void print_cs(int p);
void print_skip_param(int n);
void store_fmt_file();
void token_show(pointer p);
pointer id_lookup(int j, int l);
void check_outer_validity();
pointer get_avail();
void back_input();
void ins_error();
void back_error();
void runaway();
void show_token_list(int p, int q, int l);
void app_space();
void get_x_token();
void macro_call();
void expand();
pointer str_toks(pool_pointer b);
void conv_toks();
void conditional();
void ins_the_toks();
void change_if_limit(small_number l, pointer p);
pointer new_param_glue(small_number n);
pointer new_spec(pointer p);
scaled xn_over_d(scaled x, int n, int d);
pointer new_glue(pointer q);
pointer get_node(int s);
pointer the_toks();
void print_scaled(scaled s);
void print_spec(int p, str_number s);
void print_glue(scaled d, int order, str_number s);
void scan_something_internal(small_number level, bool negative);
void show_cur_cmd_chr();
void print_mode(int m);
void mu_error();
void scan_int();
void scan_font_ident();
void scan_eight_bit_int();
void scan_four_bit_int();
void scan_fifteen_bit_int();
void int_error(int n);
void find_font_dimen(bool writing);
void check_mem(bool print_locs);
void geq_define(pointer p, quarterword t, halfword e);
void geq_word_define(pointer p, int w);
void scan_optional_equals();
void get_r_token();
void alter_integer();
void alter_page_so_far();
void alter_prev_graf();
void alter_aux();
void alter_box_dimen();
//int myabs(int c);
void report_illegal_case();
bool scan_keyword(str_number s);
void read_toks(int n, pointer r);
pointer scan_toks(bool macro_def, bool xpand);
bool privileged();
void you_cant();
void new_font(small_number a);
void new_hyph_exceptions();
void new_interaction();
pointer new_null_box();
void new_patterns();
internal_font_number read_font_info(pointer u, str_number nom, str_number aire, scaled s);
void scan_file_name();
void scan_left_brace();
pointer new_penalty(int m);
void build_page();
void sprint_cs(pointer p);
halfword badness(scaled t, scaled s);
void fire_up(pointer c);
void scan_dimen(bool mu, bool inf, bool shortcut);
void scan_glue(small_number level);
void trap_zero_glue();
void do_register_command(small_number a);
void scan_box(int box_context);
void insert_dollar_sign();
pointer scan_rule_spec();
scaled x_over_n(scaled x, int n);
void ensure_vbox(eight_bits n);
void freeze_page_specs(small_number s);
void box_error(eight_bits n);
void show_box(pointer p);
void show_node_list(int p);
void print_current_string();
void print_totals();
pointer vert_break(pointer p, scaled h, scaled d);
pointer new_skip_param(small_number n);
pointer scan_rule_spec();
pointer new_rule();
void do_extension();
void new_write_whatsit(small_number w);
void new_whatsit(small_number s, small_number w);
void out_what(pointer p);
void special_out(pointer p);
void movement(scaled w, eight_bits o);
small_number norm_min(int h);
void append_kern();
void append_glue();
pointer new_kern(scaled w);
void after_math();
void new_save_level(group_code c);
void unsave();
void off_save();
void new_graf(bool indented);
void indent_in_hmode();
void normal_paragraph();
void end_graf();
void head_for_vmode();
void begin_insert_or_adjust();
void make_mark();
void append_penalty();
void delete_last();
void unpackage();
void append_to_vlist(pointer b);
void package(small_number c);
void extra_right_brace();
pointer vpackage(pointer p, scaled h, small_number m, scaled l);
void pop_nest();
void push_nest();
void build_discretionary();
void flush_node_list(pointer p);
void align_peek();
pointer new_noad();
void build_choices();
pointer fin_mlist(pointer p);
void fin_align();
void init_span(pointer p);
void init_row();
void init_col();
void push_math(group_code c);
void pop_alignment();
void push_alignment();
pointer hpack(pointer p, scaled w, small_number m);
void box_end(int box_context);
void ship_out(pointer p);
pointer copy_node_list(pointer p);
void flush_math();
pointer new_math(scaled w, small_number s);
void mlist_to_hlist();
int half(int x);
void resume_after_display();
pointer vsplit(eight_bits n, scaled h);
void scan_spec(group_code c, bool three_codes);
pointer new_lig_item(quarterword c);
pointer new_ligature(quarterword f, quarterword c, pointer q);
pointer new_disc();
void line_break(int final_widow_penalty);
void append_italic_correction();
pointer prune_page_top(pointer p);
void append_discretionary();
void make_accent();
void align_error();
void omit_error();
void no_align_error();
void init_align();
void do_endv();
void cs_error();
void init_math();
void start_eq_no();
void scan_math(pointer p);
void set_math_char(int c);
void scan_twenty_seven_bit_int();
pointer new_style(small_number s);
void fix_language();
void open_or_close_in();
void issue_message();
void shift_case();
void show_whatever();
void save_for_after(halfword t);
void math_limit_switch();
void math_radical();
void math_ac();
void scan_delimiter(pointer p, bool r);
void show_activities();
void math_left_right();
void math_fraction();
void sub_sup();
void append_choices();
pointer new_choice();
void char_warning(internal_font_number f, eight_bits c);
void print_meaning();
void pack_job_name(str_number s);
void dump_wd(memory_word memword);
void dump_int(int n);
void dump_hh(two_halves halves);
void dump_qqqq(four_quarters fq);
void sort_avail();
void write_out(pointer p);
void start_input();
void firm_up_the_line();
bool open_fmt_file();
void pack_buffered_name(small_number n, int a, int b);
bool load_fmt_file();
void undump_wd(memory_word *memword);
void undump_int(int *anint);
void undump_hh(two_halves *hh);
void undump_qqqq(four_quarters *qqqq);
void print_font_and_char(int p);
void print_mark(int p);
void print_rule_dimen(scaled d);
void print_write_whatsit(str_number s, pointer p);
void print_file_name(int n, int a, int e);
void short_display(int p);
void init_trie();
void first_fit(trie_pointer p);
void trie_pack(trie_pointer p);
trie_pointer compress_trie(trie_pointer p);
void trie_fix(trie_pointer p);
trie_pointer trie_node(trie_pointer p);
void x_token();
scaled round_decimals(small_number k);
scaled mult_and_add(int n, scaled x, scaled y, scaled max_answer);
void print_roman_int(int n);
void pass_text();
void insert_relax();
pointer finite_shrink(pointer p);
pointer new_character(internal_font_number f, eight_bits c);
void hyphenate();
void post_line_break(int final_widow_penalty);
void dvi_swap();
void dvi_four(int x);
void do_assignments();
quarterword new_trie_op(small_number d, small_number n, quarterword v);
void scan_char_num();
void restore_trace(pointer p, str_number s);
void show_eqtb(pointer n);
void print_param(int n);
void print_length_param(int n);
void print_style(int c);
void print_hex(int n);
void print_size(int s);
bool fin_col();
void fin_row();
void begin_box(int box_context);
void hlist_out();
void vlist_out();
void dvi_font_def(internal_font_number f);
void prune_movements(int l);
void dvi_pop(int l);
void get_preamble_token();
void make_fraction(pointer q);
scaled make_op(pointer q);
void make_ord(pointer q);
void make_radical(pointer q);
void make_over(pointer q);
void make_under(pointer q);
void make_vcenter(pointer q);
void make_math_accent(pointer q);
pointer math_glue(pointer g, scaled m);
void math_kern(pointer p, scaled m);
small_number make_left_right(pointer q, small_number style, scaled max_d, scaled max_h);
pointer var_delimiter(pointer d, small_number s, scaled v);
pointer char_box(internal_font_number f, quarterword c);
void stack_into_box(pointer b, internal_font_number f, quarterword c);
scaled height_plus_depth(internal_font_number f, quarterword c);
pointer rebox(pointer b, scaled w);
pointer fraction_rule(scaled t);
pointer overbar(pointer b, scaled k, scaled t);
void fetch(pointer a);
void make_scripts(pointer q, scaled delta);
void print_subsidiary_data(pointer p, ASCII_code c);
void show_info();
void print_fam_and_char(pointer p);
void print_delimiter(pointer p);
void normalize_selector();
void search_mem(pointer p);
void free_avail(pointer s);
void do_final_end();
